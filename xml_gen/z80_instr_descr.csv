instruction,description
ADC,"ADd with Carry. Adds values together, adding an additional 1 if Carry is set."
ADD,"Adds values together."
AND,"Performs the bitwise AND operator."
BIT,"test Bit. Tests if a bit is set on a target value."
CALL,"Like JP (including the ability to have conditions), but PUSHes the PC before jumping. Used for subroutine calls."
CCF,"Complement Carry Flag. Inverts the carry flag. (Does not, as might be assumed, clear it!) Also sets H to the previous value of the carry flag."
CP,"ComPare. Sets the flags as if a SUB was performed but does not perform it. Legal combinations are the same as SUB. This is commonly used to set the flags to perform an equality or greater/less test."
CPD,"ComPare and Decrement. Compares the byte pointed to by HL with the contents of A and sets Z if it matches or S if the comparison goes negative. Then subtracts 1 from HL and subtracts 1 from BC."
CPDR,"ComPare and Decrement Repeated. Automatically loops CPIR until either Z is set (A is found in the byte pointed to by HL) or P/V is reset (BC reached 0)." Flag effects are the same as CPD except that one of the two terminating flag conditions will always be true."
CPI,"CoPare and Increment. Compares the byte pointed to by HL with the contents of A and sets Z if it matches or S if the comparison goes negative. Then adds 1 to HL and subtracts 1 from BC. P/V is set to (BC!=0), i.e. set when non zero."
CPIR,"ComPare and Increment Repeated. Automatically loops CPI until either Z is set (A is found in the byte pointed to by HL) or P/V is reset (BC reached 0). Flag effects are the same as CPI except that one of the two terminating flag conditions will always be true."
CPL,"ComPLement. Inverts the contents of the accumulator."
DAA,"Decimal Adjust Accumulator. Modifies the contents of the accumulator based on the flags left by previous operation to correct for binary coded decimal (BCD)."
DEC,"DECrment. Decrements the target by one. Flag effects are the same as INC except H refers to borrow, not carry; and P/V is set if the target held $80."
DI,"Disable Interrupts. Disables maskable interrupts."
DJNZ,"Decrement reg. b and Jump if Not Zero. Decrements B then performs JR NZ.. to the given address. Used for encapsulating loops."
EI,"Enable Interrupts. Enables maskable interrupts (after next instruction, i.e. for example: EI RET - the interrupt may happen only after RET instruction is finished (or "EI DI" pair of instructions will not allow any maskable interrupt to happen)."
EX,"EXchange. Exchanges the contents of two sources."
EXX,"EXchange all. Exchanges BC, DE, and HL with their shadow registers. AF and AF' are not exchanged."
HALT,"Suspends the CPU until an interrupt is received (maskable interrupts must be enabled to break the wait). While CPU is waiting for interrupt, the fake NOP instruction is being executed, to keep memory refresh going on."
IM,"Interrupt Mode. Sets interrupt handling mode."
IN,"Inputs a byte value from the 16-bit port number given in BC."
INC,"INCrement. ncrements the target by one. The argument can be any 8-bit register, any 16-bit register pair, or the address pointed to by HL or indexed via IX or IY. P/V is set if the target held $7F. N is reset."
IND,"INput and Decrement. Inputs a value from port BC into memory at the address stored in HL, then decrements HL and decrements B. Because B is decremented and is part of the port number, the port number for future INI instructions will change unless it is reset. Z is set if B reached 0; C, S, H, and P/V are destroyed."
INDR,"INput and Decrement Repeated. Loops INIR until B reaches 0, so that if INIR starts with B=0 it loops 256 times. Because B is decremented during this process and is part of the port number, this is unlikely to be useful except when the upper byte of the port number is not relevant. Interrupts are recognized during execution."
INI,"INput and Incremenent. Inputs a value from port BC into memory at the address stored in HL, then increments HL and decrements B. Because B is decremented and is part of the port number, the port number for future INI instructions will change unless it is reset. Z is set if B reached 0; C, S, H, and P/V are destroyed."
INIR,"INput and Increment Repeated. Loops INI until B reaches 0, so that if INIR starts with B=0 it loops 256 times. Because B is decremented during this process and is part of the port number, this is unlikely to be useful except when the upper byte of the port number is not relevant. Interrupts are recognized during execution."
JumP,"Jumps (sets the PC) to the given address. The two argument variant conditionally jumps (sets the PC) to the given address."
JR,"Jump Relative. Jumps to an alternate address by adding the parameter to the PC - in other words the parameter is an adjustment, not an absolute address."
LD,"LoaD. The basic data load/transfer instruction. Transfers data from the location specified by the second argument, to the location specified by the first."
LDD,"LoaD and Decrement. Copies the byte pointed to by HL to the address pointed to by DE, then substracts 1 from DE, HL, and BC. P/V is set to (BC!=0), i.e. set when non zero."
LDDR,"LoaD and Decrement Repeated. Automatically loops LDD until BC reaches zero. Note the last iteration starts when BC=1 and ends with BC=0 (starting the LDDR with BC=0 will start 64kiB transfer, most likely overwriting vital parts of system memory and/or code itself)."
LDI,"LoaD and Increment. Copies the byte pointed to by HL to the address pointed to by DE, then adds 1 to DE and HL and subtracts 1 from BC. P/V is set to (BC!=0), i.e. set when non zero."
LDIR,"LoaD and Increment Repeated. Automatically loops LDI until BC reaches zero. Note the last iteration starts when BC=1 and ends with BC=0 (starting the LDIR with BC=0 will start 64kiB transfer, most likely overwriting vital parts of system memory and/or code itself). Flag effects are the same as LDI except that P/V will always be reset."
MULUB,"Perform 8-bit multiplication. Introduced as a new instruction with the R800."
MULUW,"Perform 16-bit multiplication. Introduced as a new instruction with the R800."
NEG,"NEGate. Subtracts the contents of the accumulator from zero, making it negative for the purpose of two's complement. P/V is set if A previously held $80. C is set if accumulator did not previously hold $00."
NOP,"No OPeration. Does 'nothing' (just usual housekeeping like refreshing memory and advancing program counter to next instruction)."
OR,"Performs the bitwise OR operator."
OTDR,"Out and Decrement Repeated. except that it outputs instead of inputs and B is decremented before the output instead of after. Condition check on B is performed after, so that if OTIR starts with B=0 it loops 256 times."
OTIR,"Out and Increment Repeated. Behaves like INIR except that it outputs instead of inputs and B is decremented before the output instead of after. Condition check on B is performed after, so that if OTIR starts with B=0 it loops 256 times."
OUT,"Outputs a byte value from the 16-bit port number given in BC."
OUTD,"Out and Decrement. Behaves like IND, except that it outputs instead of inputs and B is decremented before the output instead of after. Condition check on B is performed after, so that if OTIR starts with B=0 it loops 256 times."
OUTI,"Out and Increment. Behaves like INI, except it outputs instead of inputs and B is decremented before the output instead of after. Condition check on B is performed after, so that if OTIR starts with B=0 it loops 256 times."
POP,"Pops the given argument from the stack. This can be any 16-bit register pair except SP. The current value at SP is copied to the register pair and then SP is raised by 2. Popping into AF does set value of flag register F directly to low 8 bits of value from stack."
PUSH,"Pushes the given argument on the stack. This can be any 16-bit register pair except SP. SP is reduced by 2 and then the argument is written to the new location SP points to."
RES,"Resets the numbered bit on target value."
RET,"RETurn. POPs the PC from the stack, returning from a previous CALL. This can also accept the same conditions as JP."
RETI,"RETurn from Interrupt. Returns from an interrupt service routine (same as RET instruction, but also does signal to I/O device that the interrupt routine is completed)."
RETN,"RETurn from Non-maskable interrupt. Returns from a non-maskable interrupt service routine."
RL,"Rotate Left. Rotates the target bitwise left by one position. The MSB is copied to Carry. The previous contents of Carry are copied to bit 0. Can be applied to any 8-bit register or to a location in memory pointed to by HL or indexed via IX or IY. The final alternative is undocumented, and stores the result in a register as well as performing the operation."
RLA,"Same as RL except it only works on A, is faster, and does not alter S, Z or P/V."
RLC,"Rotate Left Circular. Rotates the target bitwise left by one position. The MSB is copied to bit 0, and also to Carry. Can be applied to any 8-bit register or to a location in memory pointed to by HL or indexed via IX or IY. The final alternative is undocumented, and stores the result in a register as well as performing the operation."
RLCA,"Same as RLC except it only works on A, is faster, and does not alter S, Z or P/V."
RLD,"Rotate Left bcd Digit. Rotates the lower nibble of the byte pointed to by HL, the upper nibble of that byte, and the lower nibble of A, in that order."
RR,"Rotate Right. Rotates the target bitwise right by one position. The LSB is copied to Carry."
RRA,"Same as RR except it only works on A, is faster, and does not alter S, Z or P/V."
RRC,"Rotate Right Circular. Rotates the target bitwise right by one position. The LSB is copied to the MSB, and also to Carry. Can be applied to any 8-bit register or to a location in memory pointed to by HL or indexed via IX or IY. The final alternative is undocumented, and stores the result in a register as well as performing the operation."
RRCA,"Same as RRC except it only works on A, is faster, and does not alter S, Z or P/V."
RRD,"Rotate Right bcd Digit. Same as RLD, but the order is: the lower nibble pointed to by HL, the lower nibble of the A, and the upper nibble of the byte."
RST,"ReSTart. Performs a CALL to a routine located at one of eight fixed locations ($00, $08, ..., $38) in the zero page. This is located in ROM, and on the Spectrum only a limited number of values are useful to call built-in ROM routines."
SBC,"SuBtract with Carry, er, borrow. Subtracts values, subtracting an additional 1 if Carry is set. Legal combinations are the same as for ADD, although there are no extended opcode versions of SBC and in 16-bit values the first parameter can only be HL. For 16-bit values the H flag is set if borrow from bit 12; otherwise, it is reset."
SCF,"Set Carry Flag. Sets the carry flag."
SET,"SET bit. Sets the numbered bit on target value."
SLA,"Shift Left Arithmetic. Shifts the target bitwise left by one position. The MSB is copied to Carry. 0 is copied to bit 0."
SRA,"Shift Right Arithmetic. Shifts the target bitwise right by one position. The MSB is copied to itself. Bit 0 is copied to Carry."
SRL,"Shift Right Logical. Shifts the target bitwise right by one position. The LSB is copied to Carry. 0 is copied into the MSB."
SUB,"Subtracts a value from A."
XOR,"Performs the bitwise XOR operator."
