[
  {
    "mnemonics": [
      {
        "name": "Branch",
        "form": "I",
        "mnemonic": "b",
        "operands": [
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "0"
          },
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "18",
            "size": "6"
          },
          {
            "name": "LI",
            "size": "24"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch",
        "form": "I",
        "mnemonic": "ba",
        "operands": [
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "1"
          },
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "18",
            "size": "6"
          },
          {
            "name": "LI",
            "size": "24"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch",
        "form": "I",
        "mnemonic": "bl",
        "operands": [
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "0"
          },
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "18",
            "size": "6"
          },
          {
            "name": "LI",
            "size": "24"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch",
        "form": "I",
        "mnemonic": "bla",
        "operands": [
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "1"
          },
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "18",
            "size": "6"
          },
          {
            "name": "LI",
            "size": "24"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "target_addr specifies the branch target address.",
      "",
      "If AA=0 then the branch target address is the sum of LI||0b00",
      "sign-extended and the address of this instruction, with the",
      "high-order 32 bits of the branch target address set to 0 in 32-bit",
      "mode.",
      "",
      "If AA=1 then the branch target address is the value LI||0b00",
      "sign-extended, with the high-order 32 bits of the branch target",
      "address set to 0 in 32-bit mode.",
      "",
      "If LK=1 then the effective address of the instruction following the",
      "Branch instruction is placed into the Link Register.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Branch Conditional",
        "form": "B",
        "mnemonic": "bc",
        "operands": [
          "BO",
          "BI",
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "0"
          },
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "16",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "BD",
            "size": "14"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch Conditional",
        "form": "B",
        "mnemonic": "bca",
        "operands": [
          "BO",
          "BI",
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "1"
          },
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "16",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "BD",
            "size": "14"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch Conditional",
        "form": "B",
        "mnemonic": "bcl",
        "operands": [
          "BO",
          "BI",
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "0"
          },
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "16",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "BD",
            "size": "14"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch Conditional",
        "form": "B",
        "mnemonic": "bcla",
        "operands": [
          "BO",
          "BI",
          "target_addr"
        ],
        "conditions": [
          {
            "field": "AA",
            "value": "1"
          },
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "16",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "BD",
            "size": "14"
          },
          {
            "name": "AA",
            "size": "1"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "BI+32 specifies the Condition Register bit to be tested.",
      "The BO field is used to resolve the branch as described in",
      "Figure.",
      "target_addr specifies the branch target address.",
      "",
      "If AA=0 then the branch target address is the sum of BD||0b00",
      "sign-extended and the address of this instruction, with the",
      "high-order 32 bits of the branch target address set to 0 in 32-bit",
      "mode.",
      "",
      "If AA=1 then the branch target address is the value BD||0b00",
      "sign-extended, with the high-order 32 bits of the branch target",
      "address set to 0 in 32-bit mode.",
      "",
      "If LK=1 then the effective address of the instruction following the",
      "Branch instruction is placed into the Link Register.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Branch Conditional to Link Register",
        "form": "XL",
        "mnemonic": "bclr",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "16",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch Conditional to Link Register",
        "form": "XL",
        "mnemonic": "bclrl",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "16",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "BI+32 specifies the Condition Register bit to be tested.",
      "The BO field is used to resolve the branch as described in",
      "Figure.",
      "The BH field is used as described in",
      "Figure.",
      "The branch target address is LR0:61||0b00, with the",
      "high-order 32 bits of the branch target address set to 0 in 32-bit",
      "mode.",
      "",
      "If LK=1 then the effective address of the instruction following the",
      "Branch instruction is placed into the Link Register.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Branch Conditional to Count Register",
        "form": "XL",
        "mnemonic": "bcctr",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "528",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Branch Conditional to Count Register",
        "form": "XL",
        "mnemonic": "bcctrl",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "528",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "BI+32 specifies the Condition Register bit to be tested.",
      "The BO field is used to resolve the branch as described in",
      "Figure.",
      "The BH field is used as described in",
      "Figure.",
      "The branch target address is CTR0:61||0b00, with",
      "the high-order 32 bits of the branch target address set to 0 in",
      "32-bit mode.",
      "",
      "If LK=1 then the effective address of the instruction following the",
      "Branch instruction is placed into the Link Register.",
      "",
      "If the decrement and test CTR option is specified",
      "(BO2=0), the instruction form is invalid.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Branch Conditional to Branch Target Address Register",
        "form": "XL",
        "mnemonic": "bctar",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "560",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "Branch Conditional to Branch Target Address Register",
        "form": "XL",
        "mnemonic": "bctarl",
        "operands": [
          "BO",
          "BI",
          "BH"
        ],
        "conditions": [
          {
            "field": "LK",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BO",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "BH",
            "size": "2"
          },
          {
            "name": "560",
            "size": "10"
          },
          {
            "name": "LK",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "BI+32 specifies the Condition Register bit to be tested.",
      "The BO field is used to resolve the branch as described in",
      "Figure.",
      "The BH field is used as described in",
      "Figure.",
      "The branch target address is TAR0:61||0b00, with",
      "the high-order 32 bits of the branch target address set to 0 in",
      "32-bit mode.",
      "",
      "If LK=1 then the effective address of the instruction following the",
      "Branch instruction is placed into the Link Register.",
      "",
      "Special Registers Altered:",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register AND",
        "form": "XL",
        "mnemonic": "crand",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "257",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ANDed with",
      "the bit in the Condition Register specified by BB+32, and the result",
      "is placed into the bit in the Condition Register specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register OR",
        "form": "XL",
        "mnemonic": "cror",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "449",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ORed with the",
      "bit in the Condition Register specified by BB+32, and the result is",
      "placed into the bit in the Condition Register specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register NAND",
        "form": "XL",
        "mnemonic": "crnand",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "225",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ANDed with",
      "the bit in the Condition Register specified by BB+32, and the",
      "complemented result is placed into the bit in the Condition Register",
      "specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register XOR",
        "form": "XL",
        "mnemonic": "crxor",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "193",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is XORed with",
      "the bit in the Condition Register specified by BB+32, and the result",
      "is placed into the bit in the Condition Register specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register NOR",
        "form": "XL",
        "mnemonic": "crnor",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "33",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ORed with the",
      "bit in the Condition Register specified by BB+32, and the",
      "complemented result is placed into the bit in the Condition Register",
      "specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register AND with Complement",
        "form": "XL",
        "mnemonic": "crandc",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "129",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ANDed with",
      "the complement of the bit in the Condition Register specified by",
      "BB+32, and the result is placed into the bit in the Condition",
      "Register specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register Equivalent",
        "form": "XL",
        "mnemonic": "creqv",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "289",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is XORed with",
      "the bit in the Condition Register specified by BB+32, and the",
      "complemented result is placed into the bit in the Condition Register",
      "specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Condition Register OR with Complement",
        "form": "XL",
        "mnemonic": "crorc",
        "operands": [
          "BT",
          "BA",
          "BB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "BA",
            "size": "5"
          },
          {
            "name": "BB",
            "size": "5"
          },
          {
            "name": "417",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The bit in the Condition Register specified by BA+32 is ORed with the",
      "complement of the bit in the Condition Register specified by BB+32,",
      "and the result is placed into the bit in the Condition Register",
      "specified by BT+32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move Condition Register Field",
        "form": "XL",
        "mnemonic": "mcrf",
        "operands": [
          "BF",
          "BFA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "BFA",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "0",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of Condition Register field BFA are copied to Condition",
      "Register field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "System Call",
        "form": "SC",
        "mnemonic": "sc",
        "operands": [
          "LEV"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "17",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "14"
          },
          {
            "name": "LEV",
            "size": "7"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "System Call Vectored",
        "form": "SC",
        "mnemonic": "scv",
        "operands": [
          "LEV"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "17",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "14"
          },
          {
            "name": "LEV",
            "size": "7"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "1",
            "size": "2"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "These instructions call the system to perform a service.",
      "A complete description of these instructions can be found in",
      "Section of Book",
      "III.",
      "",
      "The first form of the instruction (sc) provides a",
      "single system call.",
      "The second form of the instruction (scv) provides",
      "the capability for 128 unique system calls.",
      "",
      "The use of the LEV field is described in Book III.",
      "In the first form of the instruction the LEV values greater than 1",
      "are reserved, and bits 0:5 of the LEV field (instruction bits 20:25)",
      "are treated as a reserved field.",
      "",
      "When control is returned to the program that executed the System Call or System Call Vectored instruction, the",
      "contents of the registers will depend on the register conventions",
      "used by the program providing the system service.",
      "",
      "These instructions are context synchronizing (see Book III).",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte and Zero",
        "form": "D",
        "mnemonic": "lbz",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "34",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Byte and Zero",
        "form": "MLS:D",
        "mnemonic": "plbz",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "34",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lbz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For plbz with R=0, let EA",
      "be the sum of the contents of register RA, or the value 0",
      "if RA=0, and the value d0||d1,",
      "sign-extended to 64 bits.",
      "",
      "For plbz with R=1, let EA",
      "be the sum of the address of the instruction and the value d0||d1, sign-extended to 64 bits.",
      "",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63.",
      "RT0:55 are set to 0.",
      "",
      "For plbz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte and Zero Indexed",
        "form": "X",
        "mnemonic": "lbzx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "87",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63.",
      "RT0:55 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte and Zero with Update",
        "form": "D",
        "mnemonic": "lbzu",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "35",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum",
      "(RA)+D.",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63.",
      "RT0:55 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte and Zero with Update Indexed",
        "form": "X",
        "mnemonic": "lbzux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "119",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63.",
      "RT0:55 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword and Zero",
        "form": "D",
        "mnemonic": "lhz",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "40",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Halfword and Zero",
        "form": "MLS:D",
        "mnemonic": "plhz",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "40",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lhz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For plhz with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plhz with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are set to 0.",
      "",
      "For plhz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword and Zero Indexed",
        "form": "X",
        "mnemonic": "lhzx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "279",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword and Zero with Update",
        "form": "D",
        "mnemonic": "lhzu",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "41",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "The halfword in storage addressed by EA is loaded into RT48:63.",
      "RT0:47 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword and Zero with Update Indexed",
        "form": "X",
        "mnemonic": "lhzux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "311",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword Algebraic",
        "form": "D",
        "mnemonic": "lha",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "42",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Halfword Algebraic",
        "form": "MLS:D",
        "mnemonic": "plha",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "42",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lha, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For plha with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plha with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are filled with",
      "a copy of bit 0 of the loaded halfword.",
      "",
      "For plha, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword Algebraic Indexed",
        "form": "X",
        "mnemonic": "lhax",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "343",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are filled with",
      "a copy of bit 0 of the loaded halfword.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword Algebraic with Update",
        "form": "D",
        "mnemonic": "lhau",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "43",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)",
      "+D.",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are filled with",
      "a copy of bit 0 of the loaded halfword.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword Algebraic with Update Indexed",
        "form": "X",
        "mnemonic": "lhaux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "375",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63.",
      "RT0:47 are filled with",
      "a copy of bit 0 of the loaded halfword.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word and Zero",
        "form": "D",
        "mnemonic": "lwz",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "32",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Word and Zero",
        "form": "MLS:D",
        "mnemonic": "plwz",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "32",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lwz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For plwz with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plwz with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are set to 0.",
      "",
      "For plwz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word and Zero Indexed",
        "form": "X",
        "mnemonic": "lwzx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "23",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word and Zero with Update",
        "form": "D",
        "mnemonic": "lwzu",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "33",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)",
      "+D.",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word and Zero with Update Indexed",
        "form": "X",
        "mnemonic": "lwzux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "55",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are set to 0.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word Algebraic",
        "form": "DS",
        "mnemonic": "lwa",
        "operands": [
          "RT",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "58",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "2",
            "size": "2"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Prefixed Load Word Algebraic",
        "form": "8LS:D",
        "mnemonic": "plwa",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "41",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lwa, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
      "",
      "For plwa with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plwa with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are filled with",
      "a copy of bit 0 of the loaded word.",
      "",
      "For plwa, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word Algebraic Indexed",
        "form": "X",
        "mnemonic": "lwax",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "341",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The word in storage addressed by EA is loaded into",
      "RT32:63.",
      "RT0:31 are filled with",
      "a copy of bit 0 of the loaded word.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word Algebraic with Update Indexed",
        "form": "X",
        "mnemonic": "lwaux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "373",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The word in storage addressed by EA is loaded into RT32:63.",
      "RT0:31 are filled with",
      "a copy of bit 0 of the loaded word.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword",
        "form": "DS",
        "mnemonic": "ld",
        "operands": [
          "RT",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "58",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "0",
            "size": "2"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Prefixed Load Doubleword",
        "form": "8LS:D",
        "mnemonic": "pld",
        "operands": [
          "RT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "57",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For ld, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
      "",
      "For pld with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pld with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The doubleword in storage addressed by EA is loaded into",
      "RT.",
      "",
      "For pld, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword Indexed",
        "form": "X",
        "mnemonic": "ldx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "21",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The doubleword in storage addressed by EA is loaded into",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword with Update",
        "form": "DS",
        "mnemonic": "ldu",
        "operands": [
          "RT",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "58",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "1",
            "size": "2"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(DS||0b00).",
      "The doubleword in storage addressed by EA is loaded into",
      "RT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword with Update Indexed",
        "form": "X",
        "mnemonic": "ldux",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "53",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "The doubleword in storage addressed by EA is loaded into",
      "RT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0 or RA=RT, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte",
        "form": "D",
        "mnemonic": "stb",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "38",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Store Byte",
        "form": "MLS:D",
        "mnemonic": "pstb",
        "operands": [
          "RS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "38",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For stb, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For pstb with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstb with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "(RS)56:63 are stored",
      "into the byte in storage addressed by EA.",
      "",
      "For pstb, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte Indexed",
        "form": "X",
        "mnemonic": "stbx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "215",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)56:63 are stored",
      "into the byte in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte with Update",
        "form": "D",
        "mnemonic": "stbu",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "39",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "(RS)56:63 are stored",
      "into the byte in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte with Update Indexed",
        "form": "X",
        "mnemonic": "stbux",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "247",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "(RS)56:63 are stored",
      "into the byte in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword",
        "form": "D",
        "mnemonic": "sth",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "44",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Store Halfword",
        "form": "MLS:D",
        "mnemonic": "psth",
        "operands": [
          "RS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "44",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For sth, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For psth with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For psth with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "(RS)48:63 are stored",
      "into the halfword in storage addressed by EA.",
      "",
      "For psth, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword Indexed",
        "form": "X",
        "mnemonic": "sthx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "407",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)48:63 are stored",
      "into the halfword in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword with Update",
        "form": "D",
        "mnemonic": "sthu",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "45",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "(RS)48:63 are stored",
      "into the halfword in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword with Update Indexed",
        "form": "X",
        "mnemonic": "sthux",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "439",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "(RS)48:63 are stored",
      "into the halfword in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word",
        "form": "D",
        "mnemonic": "stw",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "36",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Store Word",
        "form": "MLS:D",
        "mnemonic": "pstw",
        "operands": [
          "RS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "36",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For stw, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
      "",
      "For pstw with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstw with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "(RS)32:63 are stored",
      "into the word in storage addressed by EA.",
      "",
      "For pstw, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word Indexed",
        "form": "X",
        "mnemonic": "stwx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "151",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)32:63 are stored",
      "into the word in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word with Update",
        "form": "D",
        "mnemonic": "stwu",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "37",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "(RS)32:63 are stored",
      "into the word in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word with Update Indexed",
        "form": "X",
        "mnemonic": "stwux",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "183",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "(RS)32:63 are stored",
      "into the word in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword",
        "form": "DS",
        "mnemonic": "std",
        "operands": [
          "RS",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "62",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "0",
            "size": "2"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Prefixed Store Doubleword",
        "form": "8LS:D",
        "mnemonic": "pstd",
        "operands": [
          "RS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For std, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
      "",
      "For pstd with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstd with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "(RS) is stored into the doubleword in storage addressed",
      "by EA.",
      "",
      "For pstd, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword Indexed",
        "form": "X",
        "mnemonic": "stdx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "149",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "(RS) is stored into the doubleword in storage addressed",
      "by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword with Update",
        "form": "DS",
        "mnemonic": "stdu",
        "operands": [
          "RS",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "62",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "1",
            "size": "2"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(DS||0b00).",
      "",
      "(RS) is stored into the doubleword in storage addressed",
      "by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword with Update Indexed",
        "form": "X",
        "mnemonic": "stdux",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "181",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "",
      "(RS) is stored into the doubleword in storage addressed",
      "by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Quadword",
        "form": "DQ",
        "mnemonic": "lq",
        "operands": [
          "RTp",
          "DQ(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "56",
            "size": "6"
          },
          {
            "name": "RTp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DQ",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Prefixed Load Quadword",
        "form": "8LS:D",
        "mnemonic": "plq",
        "operands": [
          "RTp",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "56",
            "size": "6"
          },
          {
            "name": "RTp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lq, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
      "",
      "For plq with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plq with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "For Big-Endian byte ordering, the quadword in storage addressed by",
      "EA is loaded into RTp||RTp+1.",
      "",
      "For lq and Little-Endian byte ordering, the",
      "quadword in storage addressed by EA is byte-reversed and",
      "loaded into RTp||RTp+1.",
      "",
      "For plq and Little-Endian byte ordering, the",
      "quadword in storage addressed by EA is byte-reversed and",
      "loaded into RTp+1||RTp.",
      "",
      "If RTp is odd or RTp=RA, the instruction form",
      "is invalid.",
      "If RTp=RA, an attempt to execute this instruction will",
      "invoke the system illegal instruction error handler.",
      "(The RTp=RA case includes the case of RTp=RA=0.)",
      "",
      "The quadword in storage addressed by EA is loaded into an",
      "even-odd pair of GPRs as follows.",
      "In Big-Endian mode, the even-numbered GPR is loaded with the",
      "doubleword from storage addressed by EA and the",
      "odd-numbered GPR is loaded with the doubleword addressed by",
      "EA+8.",
      "In Little-Endian mode, the even-numbered GPR is loaded with the",
      "byte-reversed  doubleword from storage addressed by EA+8",
      "and the odd-numbered GPR is loaded with the byte-reversed doubleword",
      "addressed by EA.",
      "",
      "For plq, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "Programming NoteIn versions of the architecture prior to v2.07, this instruction was",
      "privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Quadword",
        "form": "DS",
        "mnemonic": "stq",
        "operands": [
          "RSp",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "62",
            "size": "6"
          },
          {
            "name": "RSp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "2",
            "size": "2"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Prefixed Store Quadword",
        "form": "8LS:D",
        "mnemonic": "pstq",
        "operands": [
          "RSp",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "RSp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For stq, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
      "",
      "For pstq with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstq with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "For Big-Endian byte ordering, the content of register pair RSp||RSp+1 is stored into the quadword in storage addressed by EA.",
      "",
      "For stq and Little-Endian byte ordering, the",
      "content of register pair RSp||RSp+1 is byte-reversed and",
      "stored into the quadword in storage addressed by EA.",
      "",
      "For pstq and Little-Endian byte ordering, the",
      "content of register pair RSp+1||RSp is byte-reversed and",
      "stored into the quadword in storage addressed by EA.",
      "",
      "If RSp is odd, the instruction form is invalid.",
      "",
      "The contents of an even-odd pair of GPRs is stored into the quadword",
      "in storage addressed by EA as follows.",
      "In Big-Endian mode, the even-numbered GPR is stored into the",
      "doubleword in storage addressed by EA and the",
      "odd-numbered GPR is stored into the doubleword addressed by",
      "EA+8.",
      "In Little-Endian mode, the even-numbered GPR is stored byte-reversed",
      "into the doubleword in storage addressed by EA+8 and the",
      "odd-numbered GPR is stored byte-reversed into the doubleword",
      "addressed by EA.",
      "",
      "For pstq, if R is equal to 1",
      "and RA is not equal to 0, the instruction form is invalid.",
      "",
      "Programming NoteIn versions of the architecture prior to V.",
      "2.07, this instruction was privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "lhbrx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "790",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "Bits 0:7 of the halfword in storage addressed by EA are",
      "loaded into RT56:63.",
      "",
      "Bits 8:15 of the halfword in storage addressed by EA are",
      "loaded into RT48:55.",
      "",
      "RT0:47 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "sthbrx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "918",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "(RS)56:63 are stored",
      "into bits 0:7 of the halfword in storage addressed by EA.",
      "",
      "(RS)48:55 are stored",
      "into bits 8:15 of the halfword in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "lwbrx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "534",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "Bits 0:7 of the word in storage addressed by EA are",
      "loaded into RT56:63.",
      "",
      "Bits 8:15 of the word in storage addressed by EA are",
      "loaded into RT48:55.",
      "",
      "Bits 16:23 of the word in storage addressed by EA are",
      "loaded into RT40:47.",
      "",
      "Bits 24:31 of the word in storage addressed by EA are",
      "loaded into RT32:39.",
      "",
      "RT0:31 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "stwbrx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "662",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "(RS)56:63 are stored",
      "into bits 0:7 of the word in storage addressed by EA.",
      "",
      "(RS)48:55 are stored",
      "into bits 8:15 of the word in storage addressed by EA.",
      "",
      "(RS)40:47 are stored",
      "into bits 16:23 of the word in storage addressed by EA.",
      "",
      "(RS)32:39 are stored",
      "into bits 24:31 of the word in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "ldbrx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "532",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "Bits 0:7 of the doubleword in storage addressed by EA are",
      "loaded into RT56:63.",
      "",
      "Bits 8:15 of the doubleword in storage addressed by EA",
      "are loaded into RT48:55.",
      "",
      "Bits 16:23 of the doubleword in storage addressed by EA",
      "are loaded into RT40:47.",
      "",
      "Bits 24:31 of the doubleword in storage addressed by EA",
      "are loaded into RT32:39.",
      "",
      "Bits 32:39 of the doubleword in storage addressed by EA",
      "are loaded into RT24:31.",
      "",
      "Bits 40:47 of the doubleword in storage addressed by EA",
      "are loaded into RT16:23.",
      "",
      "Bits 48:55 of the doubleword in storage addressed by EA",
      "are loaded into RT8:15.",
      "",
      "Bits 56:63 of the doubleword in storage addressed by EA",
      "are loaded into RT0:7.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword Byte-Reverse Indexed",
        "form": "X",
        "mnemonic": "stdbrx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "660",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "(RS)56:63 are stored",
      "into bits 0:7 of the doubleword in storage addressed by EA.",
      "",
      "(RS)48:55 are stored",
      "into bits 8:15 of the doubleword in storage addressed by EA.",
      "",
      "(RS)40:47 are stored",
      "into bits 16:23 of the doubleword in storage addressed by EA.",
      "",
      "(RS)32:39 are stored",
      "into bits 23:31 of the doubleword in storage addressed by EA.",
      "",
      "(RS)24:31 are stored",
      "into bits 32:39 of the doubleword in storage addressed by EA.",
      "",
      "(RS)16:23 are stored",
      "into bits 40:47 of the doubleword in storage addressed by EA.",
      "",
      "(RS)8:15 are stored",
      "into bits 48:55 of the doubleword in storage addressed by EA.",
      "",
      "(RS)0:7 are stored into",
      "bits 56:63 of the doubleword in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Multiple Word",
        "form": "D",
        "mnemonic": "lmw",
        "operands": [
          "RT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "46",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let n = (32-RT).",
      "Let the effective address (EA) be the sum (RA|0)+D.",
      "",
      "n consecutive words starting at EA are loaded into the",
      "low-order 32 bits of GPRs RT through 31.",
      "The high-order 32 bits of these GPRs are set to zero.",
      "",
      "If RA is in the range of registers to be loaded,",
      "including the case in which RA=0, the instruction form is",
      "invalid.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode, the system alignment error",
      "handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Multiple Word",
        "form": "D",
        "mnemonic": "stmw",
        "operands": [
          "RS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "47",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let n = (32-RS).",
      "Let the effective address (EA) be the sum (RA|0)+D.",
      "",
      "n consecutive words starting at EA are stored from the",
      "low-order 32 bits of GPRs RS through 31.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode, the system alignment error",
      "handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load String Word Immediate",
        "form": "X",
        "mnemonic": "lswi",
        "operands": [
          "RT",
          "RA",
          "NB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "NB",
            "size": "5"
          },
          {
            "name": "597",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be (RA|0).",
      "Let n = NB if NB0,",
      "n = 32 if NB=0; n is the number",
      "of bytes to load.",
      "Let nr=CEIL(n/4); nr is the number of",
      "registers to receive data.",
      "",
      "n consecutive bytes starting at EA are loaded",
      "into GPRs RT through RT+nr-1.",
      "Data are loaded into the low-order four bytes of each GPR; the",
      "high-order four bytes are set to 0.",
      "",
      "Bytes are loaded left to right in each register.",
      "The sequence of registers wraps around to GPR 0 if required.",
      "If the low-order four bytes of register RT+nr-1 are only",
      "partially filled, the unfilled low-order byte(s) of that register are",
      "set to 0.",
      "",
      "If RA is in the range of registers to be loaded,",
      "including the case in which RA=0, the instruction form is",
      "invalid.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode, the system alignment error",
      "handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load String Word Indexed",
        "form": "X",
        "mnemonic": "lswx",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "533",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "Let n=XER57:63; n is",
      "the number of bytes to load.",
      "Let nr=CEIL(n/4); nr is the number of registers to",
      "receive data.",
      "",
      "If n0, n consecutive bytes starting at EA are loaded",
      "into GPRs RT through RT+nr-1.",
      "Data are loaded into the low-order four bytes of each GPR; the",
      "high-order four bytes are set to 0.",
      "",
      "Bytes are loaded left to right in each register.",
      "The sequence of registers wraps around to GPR 0 if required.",
      "If the low-order four bytes of register RT+nr-1 are only",
      "partially filled, the unfilled low-order byte(s) of that register are",
      "set to 0.",
      "",
      "If n=0, the contents of register RT are undefined.",
      "",
      "If RA or RB is in the range of registers to",
      "be loaded, including the case in which RA=0, the",
      "instruction is treated as if the instruction form were invalid.",
      "If RT=RA or RT=RB, the instruction form is",
      "invalid.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode and n0, the system",
      "alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store String Word Immediate",
        "form": "X",
        "mnemonic": "stswi",
        "operands": [
          "RS",
          "RA",
          "NB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "NB",
            "size": "5"
          },
          {
            "name": "725",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be (RA|0).",
      "Let n = NB if NB0,",
      "n=32 if NB=0; n is the number of bytes to",
      "store.",
      "Let nr=CEIL(n/4); nr is the number of registers to",
      "supply data.",
      "",
      "n consecutive bytes starting at EA are stored from GPRs",
      "RS through RS+nr-1.",
      "Data are stored from the low-order four bytes of each GPR.",
      "",
      "Bytes are stored left to right from each register.",
      "The sequence of registers wraps around to GPR 0 if required.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode, the system alignment error",
      "handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store String Word Indexed",
        "form": "X",
        "mnemonic": "stswx",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "661",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "Let n = XER57:63;",
      "n is the number of bytes to store.",
      "Let nr = CEIL(n/4); nr is the number of registers to",
      "supply data.",
      "",
      "If n0, n consecutive bytes starting at",
      "EA are stored from GPRs RS through RS+nr-1. Data are stored from the low-order four bytes of each GPR.",
      "",
      "Bytes are stored left to right from each register.",
      "The sequence of registers wraps around to GPR 0 if required.",
      "",
      "If n=0, no bytes are stored.",
      "",
      "This instruction is not supported in Little-Endian mode.",
      "If it is executed in Little-Endian mode and n0, the",
      "system alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Immediate",
        "form": "D",
        "mnemonic": "addi",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "14",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Add Immediate",
        "form": "MLS:D",
        "mnemonic": "paddi",
        "operands": [
          "RT",
          "RA",
          "SI",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "si0",
            "size": "18"
          },
          {
            "name": "14",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "si1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For addi, let the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "SI, sign-extended to 64 bits, is placed into register",
      "RT.",
      "",
      "For paddi with R=0, the sum of the",
      "contents of register RA, or the value 0 if RA=0, and the value si0||si1, sign-extended",
      "to 64 bits, is placed into register RT.",
      "",
      "For paddi with R=1, the sum of the",
      "address of the instruction and the value si0||si1, sign-extended to 64 bits, is placed into register RT.",
      "",
      "For paddi, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Immediate Shifted",
        "form": "D",
        "mnemonic": "addis",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "15",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA|0) + (SI||0x0000) is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add PC Immediate Shifted",
        "form": "DX",
        "mnemonic": "addpcis",
        "operands": [
          "RT",
          "D"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "5"
          },
          {
            "name": "d0",
            "size": "10"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "d2",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The sum of NIA + (D||0x0000) is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add",
        "form": "XO",
        "mnemonic": "add",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "266",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add",
        "form": "XO",
        "mnemonic": "add.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "266",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add",
        "form": "XO",
        "mnemonic": "addo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "266",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add",
        "form": "XO",
        "mnemonic": "addo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "266",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Immediate Carrying",
        "form": "D",
        "mnemonic": "addic",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + SI is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Immediate Carrying and Record",
        "form": "D",
        "mnemonic": "addic.",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "13",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + SI is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From",
        "form": "XO",
        "mnemonic": "subf",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "40",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Subtract From",
        "form": "XO",
        "mnemonic": "subf.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "40",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Subtract From",
        "form": "XO",
        "mnemonic": "subfo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "40",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Subtract From",
        "form": "XO",
        "mnemonic": "subfo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "40",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) + 1 is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From Immediate Carrying",
        "form": "D",
        "mnemonic": "subfic",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + SI + 1 is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Carrying",
        "form": "XO",
        "mnemonic": "addc",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "10",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Carrying",
        "form": "XO",
        "mnemonic": "addc.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "10",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Carrying",
        "form": "XO",
        "mnemonic": "addco",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "10",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Carrying",
        "form": "XO",
        "mnemonic": "addco.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "10",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From Carrying",
        "form": "XO",
        "mnemonic": "subfc",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Carrying",
        "form": "XO",
        "mnemonic": "subfc.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Carrying",
        "form": "XO",
        "mnemonic": "subfco",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Carrying",
        "form": "XO",
        "mnemonic": "subfco.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) + 1 is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Extended",
        "form": "XO",
        "mnemonic": "adde",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "138",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Extended",
        "form": "XO",
        "mnemonic": "adde.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "138",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Extended",
        "form": "XO",
        "mnemonic": "addeo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "138",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add Extended",
        "form": "XO",
        "mnemonic": "addeo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "138",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) + CA is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From Extended",
        "form": "XO",
        "mnemonic": "subfe",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "136",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Extended",
        "form": "XO",
        "mnemonic": "subfe.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "136",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Extended",
        "form": "XO",
        "mnemonic": "subfeo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "136",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Extended",
        "form": "XO",
        "mnemonic": "subfeo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "136",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + (RB) + CA is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add to Minus One Extended",
        "form": "XO",
        "mnemonic": "addme",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "234",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Minus One Extended",
        "form": "XO",
        "mnemonic": "addme.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "234",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Minus One Extended",
        "form": "XO",
        "mnemonic": "addmeo",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "234",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Minus One Extended",
        "form": "XO",
        "mnemonic": "addmeo.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "234",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + CA + 641 is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add to Zero Extended",
        "form": "XO",
        "mnemonic": "addze",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "202",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Zero Extended",
        "form": "XO",
        "mnemonic": "addze.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "202",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Zero Extended",
        "form": "XO",
        "mnemonic": "addzeo",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "202",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Add to Zero Extended",
        "form": "XO",
        "mnemonic": "addzeo.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "202",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + CA is placed into register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From Minus One Extended",
        "form": "XO",
        "mnemonic": "subfme",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "232",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Minus One Extended",
        "form": "XO",
        "mnemonic": "subfme.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "232",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Minus One Extended",
        "form": "XO",
        "mnemonic": "subfmeo",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "232",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Minus One Extended",
        "form": "XO",
        "mnemonic": "subfmeo.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "232",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + CA +",
      "641 is placed into",
      "register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Subtract From Zero Extended",
        "form": "XO",
        "mnemonic": "subfze",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "200",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Zero Extended",
        "form": "XO",
        "mnemonic": "subfze.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "200",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Zero Extended",
        "form": "XO",
        "mnemonic": "subfzeo",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "200",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Subtract From Zero Extended",
        "form": "XO",
        "mnemonic": "subfzeo.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "200",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + CA is placed into register",
      "RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add Extended using alternate carry bit",
        "form": "Z23",
        "mnemonic": "addex",
        "operands": [
          "RT",
          "RA",
          "RB",
          "CY"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "CY",
            "size": "2"
          },
          {
            "name": "170",
            "size": "8"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "",
      "For CY=0, the sum (RA) + (RB) + OV is placed",
      "into register RT.",
      "",
      "For CY=0, OV is set to 1 if there is a carry",
      "out of bit 0 of the sum in 64-bit mode or there is a carry out of bit",
      "32 of the sum in 32-bit mode, and set to 0 otherwise.",
      "OV32 is set to 1 if there is a carry out of bit 32 bit of",
      "the sum.",
      "",
      "CY=1, CY=2, and CY=3 are reserved.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Negate",
        "form": "XO",
        "mnemonic": "neg",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "104",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Negate",
        "form": "XO",
        "mnemonic": "neg.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "104",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Negate",
        "form": "XO",
        "mnemonic": "nego",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "104",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Negate",
        "form": "XO",
        "mnemonic": "nego.",
        "operands": [
          "RT",
          "RA"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "104",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The sum (RA) + 1 is placed into register",
      "RT.",
      "",
      "If the processor is in 64-bit mode and register RA",
      "contains the most negative 64-bit number (0x8000_0000_0000_0000),",
      "the result is the most negative number",
      "and, if OE=1, OV is set to 1.",
      "If (RA)32:63 contain",
      "the most negative 32-bit number (0x8000_0000) and",
      "OE=1, OV32 is set to 1.",
      "",
      "Similarly, if the processor is in 32-bit mode and (RA)32:63 contain the most",
      "negative 32-bit number (0x8000_0000),",
      "the low-order 32",
      "bits of the result contain the most negative 32-bit number and, if",
      "OE=1, OV and OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply Low Immediate",
        "form": "D",
        "mnemonic": "mulli",
        "operands": [
          "RT",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "7",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit first operand is (RA).",
      "The 64-bit second operand is the sign-extended value of the",
      "SI field.",
      "The low-order 64 bits of the 128-bit product of the operands are",
      "placed into register RT.",
      "",
      "Both operands and the product are interpreted as signed integers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply Low Word",
        "form": "XO",
        "mnemonic": "mullw",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "235",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Multiply Low Word",
        "form": "XO",
        "mnemonic": "mullw.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "235",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Multiply Low Word",
        "form": "XO",
        "mnemonic": "mullwo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "235",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Multiply Low Word",
        "form": "XO",
        "mnemonic": "mullwo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "235",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit operands are the low-order 32 bits of RA and",
      "of RB.",
      "The 64-bit product of the operands is placed into register RT.",
      "",
      "If OE=1 then OV and OV32 are set",
      "to 1 if the product cannot be represented in 32 bits.",
      "",
      "Both operands and the product are interpreted as signed integers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply High Word",
        "form": "XO",
        "mnemonic": "mulhw",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "75",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply High Word",
        "form": "XO",
        "mnemonic": "mulhw.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "75",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit operands are the low-order 32 bits of RA and",
      "of RB.",
      "The high-order 32 bits of the 64-bit product of the operands are",
      "placed into RT32:63.",
      "The contents of RT0:31",
      "are undefined.",
      "",
      "Both operands and the product are interpreted as signed integers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply High Word Unsigned",
        "form": "XO",
        "mnemonic": "mulhwu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "11",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply High Word Unsigned",
        "form": "XO",
        "mnemonic": "mulhwu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "11",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit operands are the low-order 32 bits of RA and",
      "of RB.",
      "The high-order 32 bits of the 64-bit product of the operands are",
      "placed into RT32:63.",
      "The contents of RT0:31",
      "are undefined.",
      "",
      "Both operands and the product are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0",
      "are set by signed comparison of the result to zero.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Word",
        "form": "XO",
        "mnemonic": "divw",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "491",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word",
        "form": "XO",
        "mnemonic": "divw.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "491",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word",
        "form": "XO",
        "mnemonic": "divwo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "491",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word",
        "form": "XO",
        "mnemonic": "divwo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "491",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit dividend is (RA)32:63.",
      "The 32-bit divisor is (RB)32:63.",
      "The 32-bit quotient is placed into RT32:63.",
      "The contents of RT0:31",
      "are undefined. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as signed integers.",
      "The quotient is the unique signed integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r ",
      "|divisor| if the dividend is nonnegative, and -|divisor|",
      " r  0 if the dividend is",
      "negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are",
      "(ifRc=1) the contents of the LT, GT, and",
      "EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and OV32 are",
      "set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Word Unsigned",
        "form": "XO",
        "mnemonic": "divwu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "459",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word Unsigned",
        "form": "XO",
        "mnemonic": "divwu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "459",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word Unsigned",
        "form": "XO",
        "mnemonic": "divwuo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "459",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Word Unsigned",
        "form": "XO",
        "mnemonic": "divwuo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "459",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 32 bit dividend is (RA)32:63.",
      "The 32-bit divisor is (RB)32:63.",
      "The 32-bit quotient is placed into RT32:63.",
      "The contents of RT0:31",
      "are undefined. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0",
      "are set by signed comparison of the result to zero.",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r  divisor.",
      "",
      "If an attempt is made to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT,",
      "and EQ bits of CR Field 0.",
      "In this case, if OE=1 then OV and OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Word Extended",
        "form": "XO",
        "mnemonic": "divwe",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "427",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended",
        "form": "XO",
        "mnemonic": "divwe.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "427",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended",
        "form": "XO",
        "mnemonic": "divweo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "427",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended",
        "form": "XO",
        "mnemonic": "divweo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "427",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit dividend is (RA)32:63 ||",
      "320.",
      "The 32-bit divisor is (RB)32:63.",
      "If the quotient can be represented in 32 bits, it is placed into",
      "RT32:63.",
      "The contents of RT0:31",
      "are undefined. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as signed integers.",
      "The quotient is the unique signed integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r ",
      "|divisor| if the dividend is nonnegative, and -|divisor|",
      " r  0 if the dividend is",
      "negative.",
      "",
      "If the quotient cannot be represented in 32 bits, or if an attempt is",
      "made to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT, and",
      "EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and",
      "OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Word Extended Unsigned",
        "form": "XO",
        "mnemonic": "divweu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "395",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended Unsigned",
        "form": "XO",
        "mnemonic": "divweu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "395",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended Unsigned",
        "form": "XO",
        "mnemonic": "divweuo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "395",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Word Extended Unsigned",
        "form": "XO",
        "mnemonic": "divweuo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "395",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit dividend is (RA)32:63 ||",
      "320.",
      "The 32-bit divisor is (RB)32:63.",
      "If the quotient can be represented in 32 bits, it is placed into",
      "RT32:63.",
      "The contents of RT0:31",
      "are undefined. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0 are set by",
      "signed comparison of the result to zero.",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r  divisor.",
      "",
      "If (RA)  (RB), or if an attempt is made",
      "to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT,",
      "and EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and",
      "OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Modulo Signed Word",
        "form": "X",
        "mnemonic": "modsw",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "779",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit dividend is (RA)32:63.",
      "The 32-bit divisor is (RB)32:63.",
      "The 32-bit remainder of the dividend divided by the divisor is placed",
      "into RT32:63.",
      "The contents of RT0:31",
      "are undefined. The quotient is not supplied as a result.",
      "",
      "Both operands and the remainder are interpreted as signed integers.",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "",
      "where 0  remainder  |divisor| if",
      "the dividend is nonnegative, and -|divisor| ",
      "remainder  0 if the dividend is negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Modulo Unsigned Word",
        "form": "X",
        "mnemonic": "moduw",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "267",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The 32-bit dividend is (RA)32:63.",
      "The 32-bit divisor is (RB)32:63.",
      "The 32-bit remainder of the dividend divided by the divisor is placed",
      "into RT32:63.",
      "The contents of RT0:31 are undefined.",
      "The quotient is not supplied as a result.",
      "",
      "Both operands and the remainder are interpreted as unsigned integers.",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "",
      "where 0  remainder  divisor.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Deliver A Random Number",
        "form": "X",
        "mnemonic": "darn",
        "operands": [
          "RT",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "L",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "755",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "A random number is placed into register RT in a format",
      "selected by L as shown in the following table.",
      "The value 0xFFFFFFFF_FFFFFFFF indicates an error",
      "condition.",
      "For L=0, the random number range is 0:0xFFFFFFFF.",
      "For L=1 and L=2, the random number range is",
      "0:0xFFFFFFFF_FFFFFFFE.",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply Low Doubleword",
        "form": "XO",
        "mnemonic": "mulld",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "233",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply Low Doubleword",
        "form": "XO",
        "mnemonic": "mulld.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "233",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply Low Doubleword",
        "form": "XO",
        "mnemonic": "mulldo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "233",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply Low Doubleword",
        "form": "XO",
        "mnemonic": "mulldo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "233",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA) and (RB).",
      "The low-order 64 bits of the 128-bit product of the operands are",
      "placed into register RT.",
      "",
      "If OE=1 then OV and OV32 are set",
      "to 1 if the product cannot be represented in 64 bits.",
      "",
      "Both operands and the product are interpreted as signed integers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply High Doubleword",
        "form": "XO",
        "mnemonic": "mulhd",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "73",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply High Doubleword",
        "form": "XO",
        "mnemonic": "mulhd.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "73",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA) and (RB).",
      "The high-order 64 bits of the 128-bit product of the operands are",
      "placed into register RT.",
      "",
      "Both operands and the product are interpreted as signed integers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply High Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "mulhdu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "9",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Multiply High Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "mulhdu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "9",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA) and (RB).",
      "The high-order 64 bits of the 128-bit product of the operands are",
      "placed into register RT.",
      "",
      "Both operands and the product are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0",
      "are set by signed comparison of the result to zero.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply-Add High Doubleword",
        "form": "VA",
        "mnemonic": "maddhd",
        "operands": [
          "RT",
          "RA",
          "RB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "48",
            "size": "6"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA), (RB), and",
      "(RC).",
      "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
      "The high-order 64 bits of the 128-bit sum are placed into register",
      "RT.",
      "",
      "All three operands and the result are interpreted as signed integers.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply-Add High Doubleword Unsigned",
        "form": "VA",
        "mnemonic": "maddhdu",
        "operands": [
          "RT",
          "RA",
          "RB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "49",
            "size": "6"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA), (RB), and",
      "(RC).",
      "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
      "The high-order 64 bits of the 128-bit sum are placed into register",
      "RT.",
      "",
      "All three operands and the result are interpreted as unsigned",
      "integers.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Multiply-Add Low Doubleword",
        "form": "VA",
        "mnemonic": "maddld",
        "operands": [
          "RT",
          "RA",
          "RB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "51",
            "size": "6"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit operands are (RA), (RB), and",
      "(RC).",
      "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
      "The low-order 64 bits of the 128-bit sum are placed into register",
      "RT.",
      "",
      "All three operands and the result are interpreted as signed integers.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Doubleword",
        "form": "XO",
        "mnemonic": "divd",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "489",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword",
        "form": "XO",
        "mnemonic": "divd.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "489",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword",
        "form": "XO",
        "mnemonic": "divdo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "489",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword",
        "form": "XO",
        "mnemonic": "divdo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "489",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit dividend is (RA).",
      "The 64-bit divisor is (RB).",
      "The 64-bit quotient is placed into register RT.",
      "The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as signed integers.",
      "The quotient is the unique signed integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r  |divisor| if the",
      "dividend is nonnegative, and -|divisor| ",
      "r  0 if the dividend is negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if Rc=1) the",
      "contents of the LT, GT, and EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "divdu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "457",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "divdu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "457",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "divduo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "457",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Divide Doubleword Unsigned",
        "form": "XO",
        "mnemonic": "divduo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "457",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The 64-bit dividend is (RA).",
      "The 64-bit divisor is (RB).",
      "The 64-bit quotient is placed into register RT.",
      "The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0",
      "are set by signed comparison of the result to zero.",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r  divisor.",
      "",
      "If an attempt is made to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT,",
      "and EQ bits of CR Field 0.",
      "In this case, if OE=1 then OV and OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Doubleword Extended",
        "form": "XO",
        "mnemonic": "divde",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "425",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended",
        "form": "XO",
        "mnemonic": "divde.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "425",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended",
        "form": "XO",
        "mnemonic": "divdeo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "425",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended",
        "form": "XO",
        "mnemonic": "divdeo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "425",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The 128-bit dividend is (RA) ||",
      "640.",
      "The 64-bit divisor is (RB).",
      "If the quotient can be represented in 64 bits, it is placed into",
      "register RT. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as signed integers.",
      "The quotient is the unique signed integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r ",
      "|divisor| if the dividend is nonnegative, and -|divisor|",
      " r  0 if the dividend is",
      "negative.",
      "",
      "If the quotient cannot be represented in 64 bits, or if an attempt is",
      "made to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT, and",
      "EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and",
      "OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Divide Doubleword Extended Unsigned",
        "form": "XO",
        "mnemonic": "divdeu",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "393",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended Unsigned",
        "form": "XO",
        "mnemonic": "divdeu.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "0"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=0",
            "size": "1"
          },
          {
            "name": "393",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended Unsigned",
        "form": "XO",
        "mnemonic": "divdeuo",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "393",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Divide Doubleword Extended Unsigned",
        "form": "XO",
        "mnemonic": "divdeuo.",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [
          {
            "field": "OE",
            "value": "1"
          },
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "OE=1",
            "size": "1"
          },
          {
            "name": "393",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The 128-bit dividend is (RA) ||",
      "640.",
      "The 64-bit divisor is (RB).",
      "If the quotient can be represented in 64 bits, it is placed into",
      "register RT. The remainder is not supplied as a result.",
      "",
      "Both operands and the quotient are interpreted as unsigned integers,",
      "except that if Rc=1 the first three bits of CR Field 0",
      "are set by signed comparison of the result to zero.",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "where 0  r  divisor.",
      "",
      "If (RA)  (RB), or if an attempt is made",
      "to perform the division",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined as are (if",
      "Rc=1) the contents of the LT, GT,",
      "and EQ bits of CR Field 0.",
      "In these cases, if OE=1 then OV and",
      "OV32 are set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Modulo Signed Doubleword",
        "form": "X",
        "mnemonic": "modsd",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "777",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The 64-bit dividend is (RA).",
      "The 64-bit divisor is (RB).",
      "The 64-bit remainder of the dividend divided by the divisor is placed",
      "into register RT.",
      "The quotient is not supplied as a result.",
      "",
      "Both operands and the remainder are interpreted as signed integers.",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "",
      "where 0  remainder  |divisor| if",
      "the dividend is nonnegative, and -|divisor| ",
      "remainder  0 if the dividend is negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Modulo Unsigned Doubleword",
        "form": "X",
        "mnemonic": "modud",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "265",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The 64-bit dividend is (RA).",
      "The 64-bit divisor is (RB).",
      "The 64-bit remainder of the dividend divided by the divisor is placed",
      "into register RT.",
      "The quotient is not supplied as a result.",
      "",
      "Both operands and the remainder are interpreted as unsigned integers.",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "",
      "where 0  remainder  divisor.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "",
      "then the contents of register RT are undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Immediate",
        "form": "D",
        "mnemonic": "cmpi",
        "operands": [
          "BF",
          "L",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "11",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA ((RA)32:63 sign-extended to 64 bits",
      "if L=0) are compared with the sign-extended value of the",
      "SI field, treating the operands as signed integers.",
      "The result of the comparison is placed into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare",
        "form": "X",
        "mnemonic": "cmp",
        "operands": [
          "BF",
          "L",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "0",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA ((RA)32:63 if L=0) are",
      "compared with the contents of register RB ((RB)32:63 if L=0),",
      "treating the operands as signed integers.",
      "The result of the comparison is placed into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Logical Immediate",
        "form": "D",
        "mnemonic": "cmpli",
        "operands": [
          "BF",
          "L",
          "RA",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "10",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA ((RA)32:63 zero-extended to 64 bits",
      "if L=0) are compared with",
      "480||UI, treating",
      "the operands as unsigned integers.",
      "The result of the comparison is placed into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Logical",
        "form": "X",
        "mnemonic": "cmpl",
        "operands": [
          "BF",
          "L",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "32",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA ((RA)32:63 if L=0) are",
      "compared with the contents of register RB ((RB)32:63 if L=0),",
      "treating the operands as unsigned integers.",
      "The result of the comparison is placed into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Ranged Byte",
        "form": "X",
        "mnemonic": "cmprb",
        "operands": [
          "BF",
          "L",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "192",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in bits 56:63 of",
      "register RA.",
      "",
      "Let src21hi be the unsigned integer value in bits 32:39",
      "of register RB.",
      "",
      "Let src21lo be the unsigned integer value in bits 40:47",
      "of register RB.",
      "",
      "Let src22hi be the unsigned integer value in bits 48:55",
      "of register RB.",
      "",
      "Let src22lo be the unsigned integer value in bits 56:63",
      "of register RB.",
      "",
      "Let x be considered in range of y:z if",
      "the value x is greater than or equal to the value",
      "y and the value x is less than or equal to",
      "the value z.",
      "",
      "When L=0, the value in_range is set to 1 if",
      "src1 is in range of src22lo:src22hi.",
      "Otherwise, the value in_range is set to 0.",
      "",
      "When L=1, the value in_range is set to 1 if",
      "either src1 is in range of src21lo:src21hi,",
      "or src1 is in range of src22lo:src22hi.",
      "Otherwise, the value in_range is set to 0.",
      "",
      "CR field BF is set to the value 0b0 concatenated with in_range concatenated with",
      "0b00.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Equal Byte",
        "form": "X",
        "mnemonic": "cmpeqb",
        "operands": [
          "BF",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "224",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "CR field BF is set to indicate if the",
      "contents of bits 56:63 of register RA are equal to the",
      "contents of any of the 8 bytes in register RB.",
      "",
      "Results are undefined in 32-bit mode.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Trap Word Immediate",
        "form": "D",
        "mnemonic": "twi",
        "operands": [
          "TO",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "3",
            "size": "6"
          },
          {
            "name": "TO",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of RA32:63",
      "are compared with the sign-extended value of the SI",
      "field.",
      "If any bit in the TO field is set to 1 and its",
      "corresponding condition is met by the result of the comparison, the",
      "system trap handler is invoked.",
      "",
      "If the trap conditions are met, this instruction is",
      "context synchronizing (see Book III).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Trap Word",
        "form": "X",
        "mnemonic": "tw",
        "operands": [
          "TO",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "TO",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "4",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of RA32:63",
      "are compared with the contents of RB32:63.",
      "If any bit in the TO field is set to 1 and its",
      "corresponding condition is met by the result of the comparison, the",
      "system trap handler is invoked.",
      "",
      "If the trap conditions are met, this instruction is",
      "context synchronizing (see Book III).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Trap Doubleword Immediate",
        "form": "D",
        "mnemonic": "tdi",
        "operands": [
          "TO",
          "RA",
          "SI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "2",
            "size": "6"
          },
          {
            "name": "TO",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SI",
            "size": "16"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA are compared with the",
      "sign-extended value of the SI field.",
      "If any bit in the TO field is set to 1 and its",
      "corresponding condition is met by the result of the comparison, the",
      "system trap handler is invoked.",
      "",
      "If the trap conditions are met, this instruction is context",
      "synchronizing (see Book III).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Trap Doubleword",
        "form": "X",
        "mnemonic": "td",
        "operands": [
          "TO",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "TO",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "68",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA are compared with the",
      "contents of register RB.",
      "If any bit in the TO field is set to 1 and its",
      "corresponding condition is met by the result of the comparison, the",
      "system trap handler is invoked.",
      "",
      "If the trap conditions are met, this instruction is context",
      "synchronizing (see Book III).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Integer Select",
        "form": "A",
        "mnemonic": "isel",
        "operands": [
          "RT",
          "RA",
          "RB",
          "BC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "BC",
            "size": "5"
          },
          {
            "name": "15",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "If the contents of bit BC+32 of the Condition Register",
      "are equal to 1, then the contents of register RA (or 0)",
      "are placed into register RT.",
      "Otherwise, the contents of register RB are placed into",
      "register RT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "AND Immediate",
        "form": "D",
        "mnemonic": "andi.",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "28",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ANDed with",
      "480||UI and the",
      "result is placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "AND Immediate Shifted",
        "form": "D",
        "mnemonic": "andis.",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "29",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ANDed with",
      "320||UI||160 and",
      "the result is placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "OR Immediate",
        "form": "D",
        "mnemonic": "ori",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "24",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ORed with",
      "480||UI and the",
      "result is placed into register RA.",
      "",
      "The preferred no-op (an instruction that does nothing) is:",
      "",
      "",
      "",
      "",
      "Some other forms of ori Rx,Rx,0 provide special functions;",
      "see",
      "Section",
      "of Book III.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "OR Immediate Shifted",
        "form": "D",
        "mnemonic": "oris",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "25",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ORed with",
      "320||UI||160 and",
      "the result is placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "XOR Immediate",
        "form": "D",
        "mnemonic": "xori",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "26",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are XORed with",
      "480||UI and the",
      "result is placed into register RA.",
      "",
      "The executed form of a no-op (an instruction that does nothing,",
      "but consumes execution resources nevertheless) is:",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "XOR Immediate Shifted",
        "form": "D",
        "mnemonic": "xoris",
        "operands": [
          "RA",
          "RS",
          "UI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "27",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "UI",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are XORed with",
      "320||UI||160 and",
      "the result is placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "AND",
        "form": "X",
        "mnemonic": "and",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "28",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "AND",
        "form": "X",
        "mnemonic": "and.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "28",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ANDed with the contents",
      "of register RB and the result is placed into register RA.",
      "",
      "Some forms of and Rx, Rx, Rx provide special",
      "functions; see",
      "Section",
      "of Book III.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "XOR",
        "form": "X",
        "mnemonic": "xor",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "316",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "XOR",
        "form": "X",
        "mnemonic": "xor.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "316",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are XORed with the contents",
      "of register RB and the result is placed into register",
      "RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "NAND",
        "form": "X",
        "mnemonic": "nand",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "476",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "NAND",
        "form": "X",
        "mnemonic": "nand.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "476",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ANDed with the contents",
      "of register RB and the complemented result is placed into",
      "register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "OR",
        "form": "X",
        "mnemonic": "or",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "444",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "OR",
        "form": "X",
        "mnemonic": "or.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "444",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ORed with the contents of",
      "register RB and the result is placed into register RA.",
      "",
      "Some forms of or Rx,Rx,Rx provide special functions; see",
      "Section of Book II and",
      "Section of Book II.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "OR with Complement",
        "form": "X",
        "mnemonic": "orc",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "412",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "OR with Complement",
        "form": "X",
        "mnemonic": "orc.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "412",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ORed with the complement",
      "of the contents of register RB and the result is placed",
      "into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "NOR",
        "form": "X",
        "mnemonic": "nor",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "124",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "NOR",
        "form": "X",
        "mnemonic": "nor.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "124",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ORed with the contents of",
      "register RB and the complemented result is placed into",
      "register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Equivalent",
        "form": "X",
        "mnemonic": "eqv",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "284",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Equivalent",
        "form": "X",
        "mnemonic": "eqv.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "284",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are XORed with the contents",
      "of register RB and the complemented result is placed into",
      "register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "AND with Complement",
        "form": "X",
        "mnemonic": "andc",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "60",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "AND with Complement",
        "form": "X",
        "mnemonic": "andc.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "60",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are ANDed with the complement",
      "of the contents of register RB and the result is placed",
      "into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Extend Sign Byte",
        "form": "X",
        "mnemonic": "extsb",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "954",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Extend Sign Byte",
        "form": "X",
        "mnemonic": "extsb.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "954",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "(RS)56:63 are placed",
      "into RA56:63.",
      "RA0:55 are filled with",
      "a copy of (RS)56.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Extend Sign Halfword",
        "form": "X",
        "mnemonic": "extsh",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "922",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Extend Sign Halfword",
        "form": "X",
        "mnemonic": "extsh.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "922",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "(RS)48:63 are placed",
      "into RA48:63.",
      "RA0:47 are filled with",
      "a copy of (RS)48.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Compare Bytes",
        "form": "X",
        "mnemonic": "cmpb",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "508",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Each byte of the contents of register RS is compared to",
      "each corresponding byte of the contents in register RB.",
      "If they are equal, the corresponding byte in RA is set to",
      "0xFF.",
      "Otherwise the corresponding byte in RA is set to",
      "0x00.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Leading Zeros Word",
        "form": "X",
        "mnemonic": "cntlzw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Count Leading Zeros Word",
        "form": "X",
        "mnemonic": "cntlzw.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 32 of",
      "register RS is placed into register RA.",
      "This number ranges from 0 to 32, inclusive.",
      "",
      "If Rc is equal to 1, CR field 0 is set to",
      "reflect the result.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Trailing Zeros Word",
        "form": "X",
        "mnemonic": "cnttzw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "538",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Count Trailing Zeros Word",
        "form": "X",
        "mnemonic": "cnttzw.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "538",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 63 of",
      "the rightmost word of register RS is placed into register",
      "RA. This number ranges from 0 to 32, inclusive.",
      "",
      "If Rc is equal to 1, CR field 0 is set to",
      "reflect the result.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Population Count Bytes",
        "form": "X",
        "mnemonic": "popcntb",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "122",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of one bits in each byte of register RS is placed into the corresponding byte of register RA.",
      "This number ranges from 0 to 8, inclusive.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Population Count Words",
        "form": "X",
        "mnemonic": "popcntw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "378",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of one bits in each word of register RS is placed into the corresponding word of register RA.",
      "This number ranges from 0 to 32, inclusive.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Parity Word",
        "form": "X",
        "mnemonic": "prtyw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "154",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "The least significant bit in each byte of (RS)0:31 is examined.",
      "If there is an odd number of one bits the value 1 is placed into",
      "RA0:31; otherwise the",
      "value 0 is placed into RA0:31.",
      "The least significant bit in each byte of (RS)32:63 is examined.",
      "If there is an odd number of one bits the value 1 is placed into",
      "RA32:63; otherwise the",
      "value 0 is placed into RA32:63.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Extend Sign Word",
        "form": "X",
        "mnemonic": "extsw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "986",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Extend Sign Word",
        "form": "X",
        "mnemonic": "extsw.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "986",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "(RS)32:63 are placed",
      "into RA32:63.",
      "RA0:31 are filled with",
      "a copy of (RS)32.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Population Count Doubleword",
        "form": "X",
        "mnemonic": "popcntd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "506",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of one bits in register RS is",
      "placed into register RA.",
      "This number ranges from 0 to 64, inclusive.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Parity Doubleword",
        "form": "X",
        "mnemonic": "prtyd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "186",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "The least significant bit in each byte of the contents of register",
      "RS is examined.",
      "If there is an odd number of one bits the value 1 is placed into",
      "register RA; otherwise the value 0 is placed into",
      "register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Leading Zeros Doubleword",
        "form": "X",
        "mnemonic": "cntlzd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "58",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Count Leading Zeros Doubleword",
        "form": "X",
        "mnemonic": "cntlzd.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "58",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 0 of",
      "register RS is placed into register RA.",
      "This number ranges from 0 to 64, inclusive.",
      "",
      "If Rc=1, CR Field 0 is set to reflect the result.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Trailing Zeros Doubleword",
        "form": "X",
        "mnemonic": "cnttzd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "570",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Count Trailing Zeros Doubleword",
        "form": "X",
        "mnemonic": "cnttzd.",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "570",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 63 of",
      "register RS is placed into register RA.",
      "This number ranges from 0 to 64, inclusive.",
      "",
      "If Rc is equal to 1, CR field 0 is set to",
      "reflect the result.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Leading Zeros Doubleword under bit Mask",
        "form": "X",
        "mnemonic": "cntlzdm",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "59",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the number of bits in register RB",
      "having the value 1.",
      "",
      "Extract and pack together the contents of the bits in register",
      "RS corresponding to a mask specified in register",
      "RB, creating an n-bit value.",
      "",
      "Count the number of contiguous leftmost 0 bits in the n-bit extracted value and place the result into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Count Trailing Zeros Doubleword under bit Mask",
        "form": "X",
        "mnemonic": "cnttzdm",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "571",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the number of bits in register RB",
      "having the value 1.",
      "",
      "Extract and pack together the contents of bits in register RS corresponding to a mask specified in register RB,",
      "creating an n-bit value.",
      "",
      "Count the number of contiguous rightmost 0 bits in the n-bit extracted value and place the result into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Bit Permute Doubleword",
        "form": "X",
        "mnemonic": "bpermd",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "252",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Eight permuted bits are produced.",
      "For each permuted bit i where i ranges from 0 to 7 and",
      "for each byte i of RS, do the following.",
      "",
      "",
      "",
      "If byte i of RS is less than 64, permuted bit",
      "i is set to the bit of RB specified by byte i",
      "of RS; otherwise permuted bit i is set to 0.",
      "",
      "",
      "The permuted bits are placed in the least-significant byte of",
      "RA, and the remaining bits are filled with 0s.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Centrifuge Doubleword",
        "form": "X",
        "mnemonic": "cfuged",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "220",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The bits in GPR[RS] whose corresponding bits in the mask",
      "in GPR[RB] equal 1 are placed in the rightmost bits in",
      "GPR[RA] maintaining their relative original order.",
      "The other bits in GPR[RS] are placed in the leftmost bits",
      "in GPR[RA] maintaining their relative original order.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Parallel Bits Extract Doubleword",
        "form": "X",
        "mnemonic": "pextd",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "188",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let mask be the contents of register RB.",
      "",
      "The contents of the bits in register RS corresponding to",
      "bits in mask containing a 1 are packed into an n-bit value.",
      "The extracted value is placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Parallel Bits Deposit Doubleword",
        "form": "X",
        "mnemonic": "pdepd",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "156",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let mask be the contents of register RB.",
      "",
      "Let n be the number of bits in mask having",
      "the value 1.",
      "",
      "The contents of the rightmost n bits of register RS are",
      "placed into register RA under control of mask",
      "as follows.",
      "",
      "",
      "",
      "The contents of bits in register RA corresponding to bits",
      "in mask that contain a 0 are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Word Immediate then AND with Mask",
        "form": "M",
        "mnemonic": "rlwinm",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "21",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Rotate Left Word Immediate then AND with Mask",
        "form": "M",
        "mnemonic": "rlwinm.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "21",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated32",
      "left SH bits.",
      "A mask is generated having 1-bits from bit MB+32 through",
      "bit ME+32 and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Word then AND with Mask",
        "form": "M",
        "mnemonic": "rlwnm",
        "operands": [
          "RA",
          "RS",
          "RB",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "23",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Rotate Left Word then AND with Mask",
        "form": "M",
        "mnemonic": "rlwnm.",
        "operands": [
          "RA",
          "RS",
          "RB",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "23",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated32",
      "left the number of bits specified by (RB)59:63.",
      "A mask is generated having 1-bits from bit MB+32 through",
      "bit ME+32 and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Word Immediate then Mask Insert",
        "form": "M",
        "mnemonic": "rlwimi",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "20",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Rotate Left Word Immediate then Mask Insert",
        "form": "M",
        "mnemonic": "rlwimi.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "20",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "MB",
            "size": "5"
          },
          {
            "name": "ME",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated32",
      "left SH bits.",
      "A mask is generated having 1-bits from bit MB+32 through",
      "bit ME+32 and 0-bits elsewhere.",
      "The rotated data are inserted into register RA under",
      "control of the generated mask.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword Immediate then Clear Left",
        "form": "MD",
        "mnemonic": "rldicl",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "0",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword Immediate then Clear Left",
        "form": "MD",
        "mnemonic": "rldicl.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "0",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left SH bits.",
      "A mask is generated having 1-bits from bit MB through bit",
      "63 and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword Immediate then Clear Right",
        "form": "MD",
        "mnemonic": "rldicr",
        "operands": [
          "RA",
          "RS",
          "SH",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "me1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "1",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword Immediate then Clear Right",
        "form": "MD",
        "mnemonic": "rldicr.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "me1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "1",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left SH bits.",
      "A mask is generated having 1-bits from bit 0 through bit ME and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword Immediate then Clear",
        "form": "MD",
        "mnemonic": "rldic",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "2",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword Immediate then Clear",
        "form": "MD",
        "mnemonic": "rldic.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "2",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left SH bits.",
      "A mask is generated having 1-bits from bit MB through bit",
      "63-SH and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword then Clear Left",
        "form": "MDS",
        "mnemonic": "rldcl",
        "operands": [
          "RA",
          "RS",
          "RB",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "8",
            "size": "4"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword then Clear Left",
        "form": "MDS",
        "mnemonic": "rldcl.",
        "operands": [
          "RA",
          "RS",
          "RB",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "8",
            "size": "4"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left the number of bits specified by (RB)58:63.",
      "A mask is generated having 1-bits from bit MB through bit",
      "63 and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword then Clear Right",
        "form": "MDS",
        "mnemonic": "rldcr",
        "operands": [
          "RA",
          "RS",
          "RB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "me1",
            "size": "5"
          },
          {
            "name": "me0",
            "size": "1"
          },
          {
            "name": "9",
            "size": "4"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword then Clear Right",
        "form": "MDS",
        "mnemonic": "rldcr.",
        "operands": [
          "RA",
          "RS",
          "RB",
          "ME"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "me1",
            "size": "5"
          },
          {
            "name": "me0",
            "size": "1"
          },
          {
            "name": "9",
            "size": "4"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left the number of bits specified by (RB)58:63.",
      "A mask is generated having 1-bits from bit 0 through bit ME and 0-bits elsewhere.",
      "The rotated data are ANDed with the generated mask and the result is",
      "placed into register RA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Rotate Left Doubleword Immediate then Mask Insert",
        "form": "MD",
        "mnemonic": "rldimi",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "3",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Rotate Left Doubleword Immediate then Mask Insert",
        "form": "MD",
        "mnemonic": "rldimi.",
        "operands": [
          "RA",
          "RS",
          "SH",
          "MB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "30",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "mb1",
            "size": "5"
          },
          {
            "name": "mb0",
            "size": "1"
          },
          {
            "name": "3",
            "size": "3"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are rotated64",
      "left SH bits.",
      "A mask is generated having 1-bits from bit MB through bit",
      "63-SH and 0-bits elsewhere.",
      "The rotated data are inserted into register RA under",
      "control of the generated mask.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Left Word",
        "form": "X",
        "mnemonic": "slw",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "24",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Shift Left Word",
        "form": "X",
        "mnemonic": "slw.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "24",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the low-order 32 bits of register RS are",
      "shifted left the number of bits specified by (RB)58:63.",
      "Bits shifted out of position 32 are lost.",
      "Zeros are supplied to the vacated positions on the right.",
      "The 32-bit result is placed into RA32:63.",
      "RA0:31 are set to zero.",
      "Shift amounts from 32 to 63 give a zero result.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Word",
        "form": "X",
        "mnemonic": "srw",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "536",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Shift Right Word",
        "form": "X",
        "mnemonic": "srw.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "536",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the low-order 32 bits of register RS are",
      "shifted right the number of bits specified by (RB)58:63.",
      "Bits shifted out of position 63 are lost.",
      "Zeros are supplied to the vacated positions on the left.",
      "The 32-bit result is placed into RA32:63.",
      "RA0:31 are set to zero.",
      "Shift amounts from 32 to 63 give a zero result.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Algebraic Word Immediate",
        "form": "X",
        "mnemonic": "srawi",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "824",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Shift Right Algebraic Word Immediate",
        "form": "X",
        "mnemonic": "srawi.",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "5"
          },
          {
            "name": "824",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the low-order 32 bits of register RS are",
      "shifted right SH bits.",
      "Bits shifted out of position 63 are lost.",
      "Bit 32 of RS is replicated to fill the vacated positions",
      "on the left.",
      "The 32-bit result is placed into RA32:63.",
      "Bit 32 of RS is replicated to fill RA0:31.",
      "CA and CA32 are set to 1 if the low-order 32",
      "bits of (RS) contain a negative number and any 1-bits are",
      "shifted out of position 63; otherwise CA and CA32 are set to 0.",
      "A shift amount of zero causes RA to receive EXTS((RS)32:63), and",
      "CA and CA32 to be set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Algebraic Word",
        "form": "X",
        "mnemonic": "sraw",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "792",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Shift Right Algebraic Word",
        "form": "X",
        "mnemonic": "sraw.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "792",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the low-order 32 bits of register RS are",
      "shifted right the number of bits specified by (RB)58:63.",
      "Bits shifted out of position 63 are lost.",
      "Bit 32 of RS is replicated to fill the vacated positions",
      "on the left.",
      "The 32-bit result is placed into RA32:63.",
      "Bit 32 of RS is replicated to fill RA0:31.",
      "CA and CA32 are set to 1 if the low-order 32",
      "bits of (RS) contain a negative number and any 1-bits are",
      "shifted out of position 63; otherwise CA and CA32 are set to 0.",
      "A shift amount of zero causes RA to receive EXTS((RS)32:63), and",
      "CA and CA32 to be set to 0.",
      "Shift amounts from 32 to 63 give a result of 64 sign bits, and cause",
      "CA and CA32 to receive the sign bit of",
      "(RS)32:63.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Left Doubleword",
        "form": "X",
        "mnemonic": "sld",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "27",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Shift Left Doubleword",
        "form": "X",
        "mnemonic": "sld.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "27",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are shifted left the number",
      "of bits specified by (RB)57:63. Bits shifted out of position 0 are lost.",
      "Zeros are supplied to the vacated positions on the right.",
      "The result is placed into register RA.",
      "Shift amounts from 64 to 127 give a zero result.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Algebraic Doubleword Immediate",
        "form": "XS",
        "mnemonic": "sradi",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "413",
            "size": "9"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Shift Right Algebraic Doubleword Immediate",
        "form": "XS",
        "mnemonic": "sradi.",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "413",
            "size": "9"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are shifted right SH bits. Bits shifted out of position 63 are lost.",
      "Bit 0 of RS is replicated to fill the vacated positions",
      "on the left. The result is placed into register RA.",
      "CA and CA32 are set to 1 if (RS)",
      "is negative and any 1-bits are shifted out of position 63; otherwise",
      "CA and CA32 are set to 0.",
      "A shift amount of zero causes RA to be set equal to",
      "(RS), and CA and CA32 to be set",
      "to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Doubleword",
        "form": "X",
        "mnemonic": "srd",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "539",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Shift Right Doubleword",
        "form": "X",
        "mnemonic": "srd.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "539",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are shifted right the number",
      "of bits specified by (RB)57:63. Bits shifted out of position 63 are lost.",
      "Zeros are supplied to the vacated positions on the left.",
      "The result is placed into register RA.",
      "Shift amounts from 64 to 127 give a zero result.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Shift Right Algebraic Doubleword",
        "form": "X",
        "mnemonic": "srad",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "794",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Shift Right Algebraic Doubleword",
        "form": "X",
        "mnemonic": "srad.",
        "operands": [
          "RA",
          "RS",
          "RB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "794",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are shifted right the number",
      "of bits specified by (RB)57:63. Bits shifted out of position 63 are lost.",
      "Bit 0 of RS is replicated to fill the vacated positions",
      "on the left. The result is placed into register RA.",
      "CA and CA32 are set to 1 if (RS)",
      "is negative and any 1-bits are shifted out of position 63; otherwise",
      "CA and CA32 are set to 0.",
      "A shift amount of zero causes RA to be set equal to",
      "(RS), and CA and CA32 to be set",
      "to 0.",
      "Shift amounts from 64 to 127 give a result of 64 sign bits in",
      "RA, and cause CA and CA32 to",
      "receive the sign bit of (RS).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Extend Sign Word and Shift Left Immediate",
        "form": "XS",
        "mnemonic": "extswsli",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "445",
            "size": "9"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Extend Sign Word and Shift Left Immediate",
        "form": "XS",
        "mnemonic": "extswsli.",
        "operands": [
          "RA",
          "RS",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "sh1",
            "size": "5"
          },
          {
            "name": "445",
            "size": "9"
          },
          {
            "name": "sh0",
            "size": "1"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the low order 32 bits of RS are",
      "sign-extended to 64 bits and then shifted left SH bits.",
      "Bits shifted out of bit 0 are lost.",
      "Zeros are supplied to vacated bits on the right.",
      "The result is placed in register RA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Convert Declets To Binary Coded Decimal",
        "form": "X",
        "mnemonic": "cdtbcd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "282",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The low-order 20 bits of each word of register RS contain",
      "two declets which are converted to six, 4-bit BCD fields; each set of",
      "six, 4-bit BCD fields is placed into the low-order 24 bits of the",
      "corresponding word in RA.",
      "The high-order 8 bits in each word of RA are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Convert Binary Coded Decimal To Declets",
        "form": "X",
        "mnemonic": "cbcdtd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "314",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The low-order 24 bits of each word of register RS contain",
      "six, 4-bit BCD fields which are converted to two declets; each set of",
      "two declets is placed into the low-order 20 bits of the corresponding",
      "word in RA.",
      "The high-order 12 bits in each word of RA are set to 0.",
      "",
      "If a 4-bit BCD field has a value greater than 9 the results are",
      "undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Add and Generate Sixes",
        "form": "XO",
        "mnemonic": "addg6s",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "74",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RA are added to the contents of",
      "register RB.",
      "Sixteen carry bits are produced, one for each carry out of decimal",
      "position n (bit position 4n).",
      "",
      "A doubleword is composed from the 16 carry bits, and placed into",
      "RT.",
      "The doubleword consists of a decimal six (0b0110) in",
      "every decimal digit position for which the corresponding carry bit is",
      "0, and a zero (0b0000) in every position for which the",
      "corresponding carry bit is 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Byte-Reverse Halfword",
        "form": "X",
        "mnemonic": "brh",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "219",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bits 0:15 of register RS are placed into",
      "bits 0:15 of register RA in byte-reversed order.",
      "",
      "The contents of bits 16:31 of register RS are placed into",
      "bits 16:31 of register RA in byte-reversed order.",
      "",
      "The contents of bits 32:47 of register RS are placed into",
      "bits 32:47 of register RA in byte-reversed order.",
      "",
      "The contents of bits 48:63 of register RS are placed into",
      "bits 48:63 of register RA in byte-reversed order.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Byte-Reverse Word",
        "form": "X",
        "mnemonic": "brw",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "155",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bits 0:31 of register RS are placed into",
      "bits 0:31 of register RA in byte-reversed order.",
      "",
      "The contents of bits 32:63 of register RS are placed into",
      "bits 32:63 of register RA in byte-reversed order.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Byte-Reverse Doubleword",
        "form": "X",
        "mnemonic": "brd",
        "operands": [
          "RA",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "187",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of register RS are placed into register",
      "RA in byte-reversed order.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Hash Store",
        "form": "X",
        "mnemonic": "hashst",
        "operands": [
          "RB",
          "offset(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "D",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "722",
            "size": "10"
          },
          {
            "name": "DX",
            "size": "1"
          }
        ],
        "release": "v3.1B"
      }
    ],
    "body": [
      "",
      "Let DW be the value 32DX + D.",
      "The offset is  (0b1111111 || DW || 0b000) sign extended to 64 bits.",
      "Let the effective address (EA) be the sum (RA) + offset.",
      "The doubleword hash value computed from the contents of RA, RB, and",
      "the privileged SPR HASHKEYR, as specified by the HashDigest function",
      "described in",
      "Section of Book I,",
      "is stored into the doubleword in storage addressed by EA.",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Hash Check",
        "form": "X",
        "mnemonic": "hashchk",
        "operands": [
          "RB",
          "offset(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "D",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "754",
            "size": "10"
          },
          {
            "name": "DX",
            "size": "1"
          }
        ],
        "release": "v3.1B"
      }
    ],
    "body": [
      "",
      "Let DW be the value 32DX + D.",
      "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
      "Let the effective address (EA) be the sum (RA) + offset.",
      "The doubleword in storage addressed by EA is read and compared with",
      "the doubleword hash value computed from the contents of RA, RB, and",
      "the privileged SPR HASHKEYR, as specified by the HashDigest function",
      "described in",
      "Section of Book I.",
      "If the values are unequal, the system trap handler is invoked.",
      "",
      "This instruction is treated as a Load; see",
      "Section",
      "of Book II.",
      "",
      "If the values are unequal, this instruction is context synchronizing",
      "(see Book III).",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From VSR Doubleword",
        "form": "X",
        "mnemonic": "mfvsrd",
        "operands": [
          "RA",
          "XS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "51",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "The contents of doubleword element 0 of VSR[XS] are",
      "placed into GPR[RA].",
      "",
      "For SX=0, mfvsrd is treated as a",
      "Floating-Point instruction in terms of resource",
      "availability.",
      "",
      "For SX=1, mfvsrd is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "Extended Mnemonics:",
      "",
      "Extended mnemonics for Move From VSR Doubleword:",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From VSR Lower Doubleword",
        "form": "X",
        "mnemonic": "mfvsrld",
        "operands": [
          "RA",
          "XS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "307",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "The contents of doubleword 1 of VSR[XS] are placed into",
      "GPR[RA].",
      "",
      "For SX=0, mfvsrld is treated as a",
      "VSX instruction in terms of resource availability.",
      "",
      "For SX=1, mfvsrld is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From VSR Word and Zero",
        "form": "X",
        "mnemonic": "mfvsrwz",
        "operands": [
          "RA",
          "XS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "115",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "The contents of word element 1 of VSR[XS] are placed into",
      "bits 32:63 of GPR[RA].",
      "The contents of bits 0:31 of GPR[RA] are set to 0.",
      "",
      "For SX=0, mfvsrwz is treated as a",
      "Floating-Point instruction in terms of resource",
      "availability.",
      "",
      "For SX=1, mfvsrwz is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "Extended Mnemonics:",
      "",
      "Extended mnemonics for Move To VSR Word and Zero:",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Doubleword",
        "form": "X",
        "mnemonic": "mtvsrd",
        "operands": [
          "XT",
          "RA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "179",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "The contents of GPR[RA] are placed into doubleword",
      "element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are",
      "undefined.",
      "",
      "For TX=0, mtvsrd is treated as a",
      "Floating-Point instruction in terms of resource",
      "availability.",
      "",
      "For TX=1, mtvsrd is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "Extended Mnemonics:",
      "",
      "Extended mnemonics for Move To VSR Doubleword:",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Word Algebraic",
        "form": "X",
        "mnemonic": "mtvsrwa",
        "operands": [
          "XT",
          "RA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "211",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "The twos-complement integer in bits 32:63 of GPR[RA] is",
      "sign-extended to 64 bits and placed into doubleword element 0 of",
      "VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are",
      "undefined.",
      "",
      "For TX=0, mtvsrwa is treated as a",
      "Floating-Point instruction in terms of resource",
      "availability.",
      "",
      "For TX=1, mtvsrwa is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "Extended Mnemonics:",
      "",
      "Extended mnemonics for Move To VSR Word Algebraic:",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Word and Zero",
        "form": "X",
        "mnemonic": "mtvsrwz",
        "operands": [
          "XT",
          "RA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "243",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "The contents of bits 32:63 of GPR[RA] are placed into",
      "word element 1 of VSR[XT].",
      "The contents of word element 0 of VSR[XT] are set to 0.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are",
      "undefined.",
      "",
      "For TX=0, mtvsrwz is treated as a",
      "Floating-Point instruction in terms of resource",
      "availability.",
      "",
      "For TX=1, mtvsrwz is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "Extended Mnemonics:",
      "",
      "Extended mnemonics for Move To VSR Word and Zero:",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Double Doubleword",
        "form": "X",
        "mnemonic": "mtvsrdd",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "435",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "The contents of GPR[RA], or the value 0 if RA=0, are placed into doubleword 0 of  VSR[XT].",
      "",
      "The contents of GPR[RB] are placed into doubleword 1 of",
      "VSR[XT].",
      "",
      "For TX=0, mtvsrdd is treated as a",
      "VSX instruction in terms of resource availability.",
      "",
      "For TX=1, mtvsrdd is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Word  Splat",
        "form": "X",
        "mnemonic": "mtvsrws",
        "operands": [
          "XT",
          "RA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "403",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "The contents of bits 32:63 of GPR[RA] are placed into",
      "each word element of  VSR[XT].",
      "",
      "For TX=0, mtvsrws is treated as a",
      "VSX instruction in terms of resource availability.",
      "",
      "For TX=1, mtvsrws is treated as a",
      "Vector instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Special Purpose Register",
        "form": "XFX",
        "mnemonic": "mtspr",
        "operands": [
          "SPR",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "spr1",
            "size": "5"
          },
          {
            "name": "spr0",
            "size": "5"
          },
          {
            "name": "467",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The SPR field denotes a Special Purpose Register, encoded as shown in",
      "the table below.",
      "If the SPR field contains a value from 808 through 811, the",
      "instruction specifies a reserved SPR, and is treated as a no-op;  see",
      "Section, Reserved",
      "Fields, Reserved Values, and Reserved SPRs.",
      "Otherwise, unless the SPR field contains 13 (denoting the AMR), the contents of register RS are placed into the",
      "designated Special Purpose Register.",
      "For Special Purpose Registers that are 32 bits long, the low-order 32",
      "bits of RS are placed into the SPR.",
      "",
      "The AMR (Authority Mask Register) is used for storage protection.",
      "This use, and operation of mtspr for the AMR, are",
      "described in Book III.",
      "",
      "",
      "",
      "",
      "If execution of this instruction is attempted specifying an SPR",
      "number that is not shown above, one of the following occurs.",
      "",
      "",
      "",
      "A complete description of this instruction can be found in Book III.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Special Purpose Register",
        "form": "XFX",
        "mnemonic": "mfspr",
        "operands": [
          "RT",
          "SPR"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "spr1",
            "size": "5"
          },
          {
            "name": "spr0",
            "size": "5"
          },
          {
            "name": "339",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The SPR field denotes a Special Purpose Register, encoded as shown in",
      "the table below.",
      "If the SPR field contains a value from 808 through 811, the",
      "instruction specifies a reserved SPR, and is treated as a no-op; see",
      "Section, Reserved",
      "Fields, Reserved Values, and Reserved SPRs.",
      "Otherwise, the contents of the designated Special Purpose Register",
      "are placed into register RT.",
      "For Special Purpose Registers that are 32 bits long, the low-order 32",
      "bits of RT receive the contents of the Special Purpose",
      "Register and the high-order 32 bits of RT are set to zero.",
      "",
      "",
      "",
      "",
      "If execution of this instruction is attempted specifying an SPR",
      "number that is not shown above, one of the following occurs.",
      "",
      "",
      "",
      "A complete description of this instruction can be found in Book III.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to CR from XER Extended",
        "form": "X",
        "mnemonic": "mcrxrx",
        "operands": [
          "BF"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "576",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the OV, OV32, CA,",
      "and CA32 are copied to Condition Register field",
      "BF.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To One Condition Register Field",
        "form": "XFX",
        "mnemonic": "mtocrf",
        "operands": [
          "FXM",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "FXM",
            "size": "8"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "144",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.01"
      }
    ],
    "body": [
      "",
      "",
      "If exactly one bit of the FXM field is set to 1, let",
      "n be the position of that bit in the field (0 ",
      "n  7).",
      "The contents of bits 4n+32:4n+35 of register RS are",
      "placed into CR field n (CR bits 4n+32:4n+35).",
      "Otherwise, the contents of the Condition Register are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Condition Register Fields",
        "form": "XFX",
        "mnemonic": "mtcrf",
        "operands": [
          "FXM",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "0",
            "size": "1"
          },
          {
            "name": "FXM",
            "size": "8"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "144",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bits 32:63 of register RS are placed into",
      "the Condition Register under control of the field mask specified by",
      "FXM. The field mask identifies the 4-bit fields affected.",
      "Let i be an integer in the range 0-7.",
      "If FXMi=1",
      "then CR field i (CR bits 4i+32:4i+35) is set to",
      "the contents of the corresponding field of the low-order 32 bits of",
      "RS.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From One Condition Register Field",
        "form": "XFX",
        "mnemonic": "mfocrf",
        "operands": [
          "RT",
          "FXM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "FXM",
            "size": "8"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "19",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.01"
      }
    ],
    "body": [
      "",
      "",
      "If exactly one bit of the FXM field is set to 1, let n be",
      "the position of that bit in the field (0  n  7).",
      "The contents of CR field n (CR bits 4*n+32:4*n+35) are placed into bits 4n+32:4n+35",
      "of register RT, and the contents of the remaining bits of",
      "register RT are undefined.",
      "Otherwise, the contents of register RT are undefined.",
      "",
      "If exactly one bit of the FXM field is set to 1, the",
      "contents of the remaining bits of register RT are set to",
      "0's instead of being undefined as specified above.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Condition Register",
        "form": "XFX",
        "mnemonic": "mfcr",
        "operands": [
          "RT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "9"
          },
          {
            "name": "19",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the Condition Register are placed into RT32:63.",
      "RT0:31 are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Set Boolean",
        "form": "X",
        "mnemonic": "setb",
        "operands": [
          "RT",
          "BFA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "BFA",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "128",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "If the contents of bit 0 of CR field BFA are",
      "equal to 0b1, the contents of register RT are",
      "set to 0xFFFF_FFFF_FFFF_FFFF.",
      "",
      "Otherwise, if the contents of bit 1 of CR field",
      "BFA are equal to 0b1, the contents of",
      "register RT are set to 0x0000_0000_0000_0001.",
      "",
      "Otherwise, the contents of register RT are set to",
      "0x0000_0000_0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Set Boolean Condition",
        "form": "X",
        "mnemonic": "setbc",
        "operands": [
          "RT",
          "BI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "384",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "If bit BI of the CR contains a 1, register RT",
      "is set to 1. Otherwise, register RT is set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Set Boolean Condition Reverse",
        "form": "X",
        "mnemonic": "setbcr",
        "operands": [
          "RT",
          "BI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "416",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "If bit BI of the CR contains a 1, register RT",
      "is set to 0. Otherwise, register RT is set to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Set Negative Boolean Condition",
        "form": "X",
        "mnemonic": "setnbc",
        "operands": [
          "RT",
          "BI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "448",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "If bit BI of the CR contains a 1, register RT",
      "is set to -1. Otherwise, register RT is set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Set Negative Boolean Condition Reverse",
        "form": "X",
        "mnemonic": "setnbcr",
        "operands": [
          "RT",
          "BI"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "BI",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "480",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "If bit BI of the CR contains a 1, register RT",
      "is set to 0. Otherwise, register RT is set to -1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Prefixed Nop",
        "form": "MRR:*",
        "mnemonic": "pnop",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "112",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "0",
            "size": "18"
          },
          {
            "name": "?",
            "size": "32"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "No operation is performed.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Single",
        "form": "D",
        "mnemonic": "lfs",
        "operands": [
          "FRT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "48",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Floating-Point Single",
        "form": "MLS:D",
        "mnemonic": "plfs",
        "operands": [
          "FRT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "48",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lfs, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value D,",
      "sign-extended to 64 bits.",
      "",
      "For plfs with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plfs with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The word in storage addressed by EA is interpreted as a",
      "floating-point single-precision operand.",
      "This word is converted to floating-point double format (see",
      "pagePPC1ChFloatPt-ldsgl) and placed into register",
      "FRT.",
      "",
      "For plfs, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Single Indexed",
        "form": "X",
        "mnemonic": "lfsx",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "535",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The word in storage addressed by EA is interpreted as a",
      "floating-point single-precision operand.",
      "This word is converted to floating-point double format (see",
      "pagePPC1ChFloatPt-ldsgl) and placed into register",
      "FRT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Single with Update",
        "form": "D",
        "mnemonic": "lfsu",
        "operands": [
          "FRT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "49",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "",
      "The word in storage addressed by EA is interpreted as a",
      "floating-point single-precision operand.",
      "This word is converted to floating-point double format (see",
      "pagePPC1ChFloatPt-ldsgl) and placed into register",
      "FRT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Single with Update Indexed",
        "form": "X",
        "mnemonic": "lfsux",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "567",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "",
      "The word in storage addressed by EA is interpreted as a",
      "floating-point single-precision operand.",
      "This word is converted to floating-point double format (see",
      "pagePPC1ChFloatPt-ldsgl) and placed into register",
      "FRT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double",
        "form": "D",
        "mnemonic": "lfd",
        "operands": [
          "FRT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "50",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Load Floating-Point Double",
        "form": "MLS:D",
        "mnemonic": "plfd",
        "operands": [
          "FRT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "50",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For lfd, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value D,",
      "sign-extended to 64 bits.",
      "",
      "For plfd with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plfd with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The doubleword in storage addressed by EA is",
      "loaded into register FRT.",
      "",
      "For plfd, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double Indexed",
        "form": "X",
        "mnemonic": "lfdx",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "599",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The doubleword in storage addressed by EA is loaded into register",
      "FRT.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double with Update",
        "form": "D",
        "mnemonic": "lfdu",
        "operands": [
          "FRT",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "51",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "",
      "The doubleword in storage addressed by EA is loaded into",
      "register FRT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double with Update Indexed",
        "form": "X",
        "mnemonic": "lfdux",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "631",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "",
      "The doubleword in storage addressed by EA is loaded into",
      "register FRT.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point as Integer Word Algebraic Indexed",
        "form": "X",
        "mnemonic": "lfiwax",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "855",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The word in storage addressed by EA is loaded into",
      "FRT.",
      "FRT are filled with",
      "a copy of bit 0 of the loaded word.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point as Integer Word  Zero Indexed",
        "form": "X",
        "mnemonic": "lfiwzx",
        "operands": [
          "FRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "887",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The word in storage addressed by EA is loaded into",
      "FRT.",
      "FRT are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Single",
        "form": "D",
        "mnemonic": "stfs",
        "operands": [
          "FRS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "52",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Store Floating-Point Single",
        "form": "MLS:D",
        "mnemonic": "pstfs",
        "operands": [
          "FRS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "52",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For stfs, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value D,",
      "sign-extended to 64 bits.",
      "",
      "For pstfs with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstfs with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The contents of register FRS are converted to single",
      "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
      "word in storage addressed by EA.",
      "",
      "For pstfs, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Single Indexed",
        "form": "X",
        "mnemonic": "stfsx",
        "operands": [
          "FRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "663",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The contents of register FRS are converted to single",
      "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
      "word in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Single with Update",
        "form": "D",
        "mnemonic": "stfsu",
        "operands": [
          "FRS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "53",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "",
      "The contents of register FRS are converted to single",
      "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
      "word in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Single with Update Indexed",
        "form": "X",
        "mnemonic": "stfsux",
        "operands": [
          "FRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "695",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "",
      "The contents of register FRS are converted to single",
      "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
      "word in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double",
        "form": "D",
        "mnemonic": "stfd",
        "operands": [
          "FRS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "54",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Prefixed Store Floating-Point Double",
        "form": "MLS:D",
        "mnemonic": "pstfd",
        "operands": [
          "FRS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "12",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "54",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For stfd, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value D,",
      "sign-extended to 64 bits.",
      "",
      "For pstfd with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstfd with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "The contents of register FRS are stored into the",
      "doubleword in storage addressed by EA.",
      "",
      "For pstfd, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double Indexed",
        "form": "X",
        "mnemonic": "stfdx",
        "operands": [
          "FRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "727",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The contents of register FRS are stored into the",
      "doubleword in storage addressed by EA.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double with Update",
        "form": "D",
        "mnemonic": "stfdu",
        "operands": [
          "FRS",
          "D(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "55",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "D",
            "size": "16"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+D.",
      "",
      "The contents of register FRS are stored into the",
      "doubleword in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double with Update Indexed",
        "form": "X",
        "mnemonic": "stfdux",
        "operands": [
          "FRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "759",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA)+(RB).",
      "",
      "The contents of register FRS are stored into the",
      "doubleword in storage addressed by EA.",
      "",
      "EA is placed into register RA.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point as Integer Word Indexed",
        "form": "X",
        "mnemonic": "stfiwx",
        "operands": [
          "FRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "983",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "(FRS) are stored,",
      "without conversion, into the word in storage addressed by EA.",
      "",
      "If the contents of register FRS were produced, either",
      "directly or indirectly, by a Load Floating-Point Single",
      "instruction, a single-precision Arithmetic instruction, or",
      "frsp, then the value stored is undefined.",
      "(The contents of register FRS are produced directly by",
      "such an instruction if FRS is the target register for the",
      "instruction.",
      "The contents of register FRS are produced indirectly by",
      "such an instruction if FRS is the final target register",
      "of a sequence of one or more Floating-Point Move",
      "instructions, with the input to the sequence having been produced",
      "directly by such an instruction.)",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double Pair",
        "form": "DS",
        "mnemonic": "lfdp",
        "operands": [
          "FRTp",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "57",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "0",
            "size": "2"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
      "",
      "The doubleword in storage addressed by EA is placed into",
      "the even-numbered register of FRTp.",
      "",
      "The doubleword in storage addressed by EA+8 is placed",
      "into the odd-numbered register of FRTp.",
      "",
      "If FRTp is odd, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Floating-Point Double Pair Indexed",
        "form": "X",
        "mnemonic": "lfdpx",
        "operands": [
          "FRTp",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "791",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The doubleword in storage addressed by EA is placed into",
      "the even-numbered register of FRTp.",
      "",
      "The doubleword in storage addressed by EA+8 is placed",
      "into the odd-numbered register of FRTp.",
      "",
      "If FRTp is odd, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double Pair",
        "form": "DS",
        "mnemonic": "stfdp",
        "operands": [
          "FRSp",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "FRSp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "0",
            "size": "2"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
      "",
      "The contents of the even-numbered register of FRSp are",
      "stored into the doubleword in storage addressed by EA.",
      "",
      "The contents of the odd-numbered register of FRSp are",
      "stored into the doubleword in storage addressed by EA+8.",
      "",
      "If FRSp is odd, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Floating-Point Double Pair Indexed",
        "form": "X",
        "mnemonic": "stfdpx",
        "operands": [
          "FRSp",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "FRSp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "919",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
      "",
      "The contents of the even-numbered register of FRSp are",
      "stored into the doubleword in storage addressed by EA.",
      "",
      "The contents of the odd-numbered register of FRSp are",
      "stored into the doubleword in storage addressed by EA+8.",
      "",
      "If FRSp is odd, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Move Register",
        "form": "X",
        "mnemonic": "fmr",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "72",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Move Register",
        "form": "X",
        "mnemonic": "fmr.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "72",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of register FRB are placed into register",
      "FRT.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Negate",
        "form": "X",
        "mnemonic": "fneg",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "40",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negate",
        "form": "X",
        "mnemonic": "fneg.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "40",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of register FRB with bit 0 inverted are",
      "placed into register FRT.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Absolute Value",
        "form": "X",
        "mnemonic": "fabs",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "264",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Absolute Value",
        "form": "X",
        "mnemonic": "fabs.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "264",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of register FRB with bit 0 set to zero are",
      "placed into register FRT.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Negative Absolute Value",
        "form": "X",
        "mnemonic": "fnabs",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "136",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negative Absolute Value",
        "form": "X",
        "mnemonic": "fnabs.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "136",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of register FRB with bit 0 set to one are",
      "placed into register FRT.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Copy Sign",
        "form": "X",
        "mnemonic": "fcpsgn",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "8",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "Floating Copy Sign",
        "form": "X",
        "mnemonic": "fcpsgn.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "8",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The contents of register FRB with bit 0 set to the value",
      "of bit 0 of register FRA are placed into register",
      "FRT.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Merge Even Word",
        "form": "X",
        "mnemonic": "fmrgew",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "966",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 0 of FPR[FRA] are placed",
      "into word element 0 of FPR[FRT].",
      "",
      "The contents of word element 0 of FPR[FRB] are placed",
      "into word element 1 of FPR[FRT].",
      "",
      "fmrgew is treated as a Floating-Point",
      "instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Merge Odd Word",
        "form": "X",
        "mnemonic": "fmrgow",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "838",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 1 of FPR[FRA] are placed",
      "into word element 0 of FPR[FRT].",
      "",
      "The contents of word element 1 of FPR[FRB] are placed",
      "into word element 1 of FPR[FRT].",
      "",
      "fmrgow is treated as a Floating-Point",
      "instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Add",
        "form": "A",
        "mnemonic": "fadd",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "21",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Add",
        "form": "A",
        "mnemonic": "fadd.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "21",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Add Single",
        "form": "A",
        "mnemonic": "fadds",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "21",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Add Single",
        "form": "A",
        "mnemonic": "fadds.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "21",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRA is added to",
      "the floating-point operand in register FRB.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "Floating-point addition is based on exponent comparison and addition",
      "of the two significands.",
      "The exponents of the two operands are compared, and the significand",
      "accompanying the smaller exponent is shifted right, with its exponent",
      "increased by one for each bit shifted, until the two exponents are",
      "equal.",
      "The two significands are then added or subtracted as appropriate,",
      "depending on the signs of the operands, to form an intermediate sum.",
      "All 53 bits of the significand as well as all three guard bits",
      "(G, R, and X) enter into the",
      "computation.",
      "",
      "If a carry occurs, the sums significand is shifted right one bit",
      "position and the exponent is increased by one.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Subtract",
        "form": "A",
        "mnemonic": "fsub",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Subtract",
        "form": "A",
        "mnemonic": "fsub.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Subtract Single",
        "form": "A",
        "mnemonic": "fsubs",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Subtract Single",
        "form": "A",
        "mnemonic": "fsubs.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is subtracted",
      "from the floating-point operand in register FRA.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "The execution of the Floating Subtract instruction is identical to",
      "that of Floating Add, except that the contents of FRB",
      "participate in the operation with the sign bit (bit 0) inverted.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Multiply",
        "form": "A",
        "mnemonic": "fmul",
        "operands": [
          "FRT",
          "FRA",
          "FRC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply",
        "form": "A",
        "mnemonic": "fmul.",
        "operands": [
          "FRT",
          "FRA",
          "FRC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply Single",
        "form": "A",
        "mnemonic": "fmuls",
        "operands": [
          "FRT",
          "FRA",
          "FRC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Multiply Single",
        "form": "A",
        "mnemonic": "fmuls.",
        "operands": [
          "FRT",
          "FRA",
          "FRC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRA is multiplied",
      "by the floating-point operand in register FRC.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "Floating-point multiplication is based on exponent addition and",
      "multiplication of the significands.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Divide",
        "form": "A",
        "mnemonic": "fdiv",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Divide",
        "form": "A",
        "mnemonic": "fdiv.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Divide Single",
        "form": "A",
        "mnemonic": "fdivs",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Divide Single",
        "form": "A",
        "mnemonic": "fdivs.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRA is divided by",
      "the floating-point operand in register FRB.",
      "The remainder is not supplied as a result.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "Floating-point division is based on exponent subtraction and division",
      "of the significands.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1 and Zero",
      "Divide Exceptions when ZE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Square Root",
        "form": "A",
        "mnemonic": "fsqrt",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      },
      {
        "name": "Floating Square Root",
        "form": "A",
        "mnemonic": "fsqrt.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      },
      {
        "name": "Floating Square Root Single",
        "form": "A",
        "mnemonic": "fsqrts",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Square Root Single",
        "form": "A",
        "mnemonic": "fsqrts.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The square root of the floating-point operand in register FRB is placed into register FRT.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "FPSCR is set to the",
      "class and sign of the result, except for Invalid Operation Exceptions",
      "when FPSCR=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Reciprocal Estimate",
        "form": "A",
        "mnemonic": "fre",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Reciprocal Estimate",
        "form": "A",
        "mnemonic": "fre.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Reciprocal Estimate Single",
        "form": "A",
        "mnemonic": "fres",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Reciprocal Estimate Single",
        "form": "A",
        "mnemonic": "fres.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "An estimate of the reciprocal of the floating-point operand in",
      "register FRB is placed into register FRT.",
      "Unless the reciprocal would be a zero, an infinity, the result of a",
      "trap-disabled Overflow exception, or a QNaN, the estimate is correct",
      "to a precision of one part in 256 of the reciprocal of (FRB), i.e.,",
      "",
      "where x is the initial value in FRB.",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1 and Zero",
      "Divide Exceptions when ZE=1.",
      "",
      "The results of executing this instruction may vary between",
      "implementations, and between different executions on the same",
      "implementation.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Reciprocal Square Root Estimate",
        "form": "A",
        "mnemonic": "frsqrte",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Reciprocal Square Root Estimate",
        "form": "A",
        "mnemonic": "frsqrte.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Reciprocal Square Root Estimate Single",
        "form": "A",
        "mnemonic": "frsqrtes",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Reciprocal Square Root Estimate Single",
        "form": "A",
        "mnemonic": "frsqrtes.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "26",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "A estimate of the reciprocal of the square root of the floating-point",
      "operand in register FRB is placed into register",
      "FRT.",
      "The estimate placed into register FRT is correct to a",
      "precision of one part in 32 of the reciprocal of the square root of",
      "(FRB), i.e.,",
      "",
      "where x is the initial value in FRB.",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1 and Zero",
      "Divide Exceptions when ZE=1.",
      "",
      "The results of executing this instruction may vary between",
      "implementations, and between different executions on the same",
      "implementation.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Test for software Divide",
        "form": "X",
        "mnemonic": "ftdiv",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "128",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let e_a be the unbiased exponent of the double-precision",
      "floating-point operand in register FRA.",
      "",
      "Let e_b be the unbiased exponent of the double-precision",
      "floating-point operand in register FRB.",
      "",
      "fe_flag is set to 1 if any of the following conditions",
      "occurs.",
      "",
      "",
      "",
      "Otherwise fe_flag is set to 0.",
      "",
      "fg_flag is set to 1 if either of the following",
      "conditions occurs.",
      "",
      "",
      "",
      "Otherwise fg_flag is set to 0.",
      "",
      "If the implementation guarantees a relative error of",
      "fre[s][.] of less",
      "than or equal to 2, then",
      "fl_flag is set to 1.",
      "Otherwise fl_flag is set to 0.",
      "",
      "CR field BF is set to the value fl_flag||fg_flag||fe_flag||0b0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Test for software Square Root",
        "form": "X",
        "mnemonic": "ftsqrt",
        "operands": [
          "BF",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "160",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let e_b be the unbiased exponent of the double-precision",
      "floating-point operand in register FRB.",
      "",
      "fe_flag is set to 1 if either of the following",
      "conditions occurs.",
      "",
      "",
      "",
      "Otherwise fe_flag is set to 0.",
      "",
      "fg_flag is set to 1 if the following condition occurs.",
      "",
      "",
      "",
      "Otherwise fg_flag is set to 0.",
      "",
      "If the implementation guarantees a relative error of",
      "frsqrte[s][.] of",
      "less than or equal to 2,",
      "then fl_flag is set to 1.",
      "Otherwise fl_flag is set to 0.",
      "",
      "CR field BF is set to the value fl_flag||fg_flag||fe_flag||0b0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Multiply-Add",
        "form": "A",
        "mnemonic": "fmadd",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "29",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply-Add",
        "form": "A",
        "mnemonic": "fmadd.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "29",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply-Add Single",
        "form": "A",
        "mnemonic": "fmadds",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "29",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Multiply-Add Single",
        "form": "A",
        "mnemonic": "fmadds.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "29",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The operation",
      "",
      "",
      "",
      "FRT  [(FRA)(FRC)] + (FRB)",
      "",
      "",
      "",
      "is performed.",
      "",
      "The floating-point operand in register FRA is multiplied",
      "by the floating-point operand in register FRC.",
      "The floating-point operand in register FRB is added to",
      "this intermediate result.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Multiply-Subtract",
        "form": "A",
        "mnemonic": "fmsub",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "28",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply-Subtract",
        "form": "A",
        "mnemonic": "fmsub.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "28",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Multiply-Subtract Single",
        "form": "A",
        "mnemonic": "fmsubs",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "28",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Multiply-Subtract Single",
        "form": "A",
        "mnemonic": "fmsubs.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "28",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The operation",
      "",
      "",
      "",
      "FRT  [(FRA)(FRC)] - (FRB)",
      "",
      "",
      "",
      "is performed.",
      "",
      "The floating-point operand in register FRA is multiplied",
      "by the floating-point operand in register FRC.",
      "The floating-point operand in register FRB is subtracted",
      "from this intermediate result.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN and placed into register FRT.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Negative Multiply-Add",
        "form": "A",
        "mnemonic": "fnmadd",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negative Multiply-Add",
        "form": "A",
        "mnemonic": "fnmadd.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negative Multiply-Add Single",
        "form": "A",
        "mnemonic": "fnmadds",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Negative Multiply-Add Single",
        "form": "A",
        "mnemonic": "fnmadds.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The operation",
      "",
      "",
      "",
      "FRT  - ( [(FRA)(FRC)] + (FRB) )",
      "",
      "",
      "",
      "is performed.",
      "",
      "The floating-point operand in register FRA is multiplied",
      "by the floating-point operand in register FRC.",
      "The floating-point operand in register FRB is added to",
      "this intermediate result.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN, then negated and placed into register FRT.",
      "",
      "This instruction produces the same result as would be obtained by",
      "using the Floating Multiply-Add instruction and then",
      "negating the result, with the following exceptions.",
      "",
      "",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Negative Multiply-Subtract",
        "form": "A",
        "mnemonic": "fnmsub",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "30",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negative Multiply-Subtract",
        "form": "A",
        "mnemonic": "fnmsub.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "30",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Negative Multiply-Subtract Single",
        "form": "A",
        "mnemonic": "fnmsubs",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "30",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Negative Multiply-Subtract Single",
        "form": "A",
        "mnemonic": "fnmsubs.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "30",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The operation",
      "",
      "",
      "",
      "FRT  - ( [(FRA)(FRC)] - (FRB) )",
      "",
      "",
      "",
      "is performed.",
      "",
      "The floating-point operand in register FRA is multiplied",
      "by the floating-point operand in register FRC.",
      "The floating-point operand in register FRB is subtracted",
      "from this intermediate result.",
      "",
      "If the most significant bit of the resultant significand is not 1,",
      "the result is normalized.",
      "The result is rounded to the target precision under control of",
      "RN, then negated and placed into register FRT.",
      "",
      "This instruction produces the same result as would be obtained by",
      "using the Floating Multiply-Subtract instruction and then",
      "negating the result, with the following exceptions.",
      "",
      "",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Round to Single-Precision",
        "form": "X",
        "mnemonic": "frsp",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "12",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Floating Round to Single-Precision",
        "form": "X",
        "mnemonic": "frsp.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "12",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is rounded to",
      "single-precision, using the rounding mode specified by RN, and placed into register FRT.",
      "",
      "The rounding is described fully in",
      "Section,",
      "Floating-Point Round to Single-Precision Model on",
      "pagesec:PPC1ApFPmodel-A-1-Floating-Point-Round-to-Single-Precision-Model.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Double-Precision To Signed Doubleword format",
        "form": "X",
        "mnemonic": "fctid",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "814",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Convert with round Double-Precision To Signed Doubleword format",
        "form": "X",
        "mnemonic": "fctid.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "814",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x8000_0000_0000_0000, VXCVI is set to 1, and, if",
      "src is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode specified by RN.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "signed-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
        "form": "X",
        "mnemonic": "fctidz",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "815",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
        "form": "X",
        "mnemonic": "fctidz.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "815",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x8000_0000_0000_0000, VXCVI is set to 1, and, if",
      "src is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round toward Zero.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "signed-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
        "form": "X",
        "mnemonic": "fctidu",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "942",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
        "form": "X",
        "mnemonic": "fctidu.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "942",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x0000_0000_0000_0000, VXCVI is set to 1, and, if",
      "src is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode specified by RN.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than 0, then the result is",
      "0x0000_0000_0000_0000, and VXCVI is set to",
      "1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "unsigned-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
        "form": "X",
        "mnemonic": "fctiduz",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "943",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
        "form": "X",
        "mnemonic": "fctiduz.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "943",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x0000_0000_0000_0000, VXCVI is set to 1, and, if",
      "src is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round toward Zero.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than 0, then the result is",
      "0x0000_0000_0000_0000, and VXCVI is set to",
      "1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "unsigned-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Double-Precision To Signed Word format",
        "form": "X",
        "mnemonic": "fctiw",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "14",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      },
      {
        "name": "Floating Convert with round Double-Precision To Signed Word format",
        "form": "X",
        "mnemonic": "fctiw.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "14",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x8000_0000, VXCVI is set to 1, and, if src",
      "is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode specified by RN.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0x7FFF_FFFF, and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000, and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "signed-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT32:63 and",
      "FRT0:31 is undefined,",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with truncate Double-Precision To Signed Word fomat",
        "form": "X",
        "mnemonic": "fctiwz",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "15",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      },
      {
        "name": "Floating Convert with truncate Double-Precision To Signed Word fomat",
        "form": "X",
        "mnemonic": "fctiwz.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "15",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P2"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x8000_0000, VXCVI is set to 1, and, if src",
      "is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round toward Zero.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0x7FFF_FFFF, and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000, and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "signed-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT and FRT is",
      "undefined,",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Double-Precision To Unsigned Word format",
        "form": "X",
        "mnemonic": "fctiwu",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "142",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with round Double-Precision To Unsigned Word format",
        "form": "X",
        "mnemonic": "fctiwu.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "142",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x0000_0000, VXCVI is set to 1, and, if src",
      "is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode specified by RN.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0xFFFF_FFFF and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than 0,  then the",
      "result is 0x0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "unsigned-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT and FRT is",
      "undefined,",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with truncate Double-Precision To Unsigned Word format",
        "form": "X",
        "mnemonic": "fctiwuz",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "143",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with truncate Double-Precision To Unsigned Word format",
        "form": "X",
        "mnemonic": "fctiwuz.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "143",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let src be the double-precision floating-point value in",
      "FRB.",
      "",
      "If src is a NaN, then the result is 0x0000_0000, VXCVI is set to 1, and, if src",
      "is an SNaN, VXSNAN is set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round toward Zero.",
      "",
      "If the rounded value is greater than 2-1, then the result is",
      "0xFFFF_FFFF and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than 0.0,  then the result is",
      "0x0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "unsigned-integer format, and XX is set to 1 if the result",
      "is inexact.",
      "",
      "If an enabled Invalid Operation Exception does not occur, then the",
      "result is placed into FRT and FRT is",
      "undefined,",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert to Integer Model on",
      "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
      "",
      "Except for enabled Invalid Operation Exceptions, FPRF is",
      "undefined.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Signed Doubleword to Double-Precision format",
        "form": "X",
        "mnemonic": "fcfid",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "846",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Convert with round Signed Doubleword to Double-Precision format",
        "form": "X",
        "mnemonic": "fcfid.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "846",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The 64-bit signed fixed-point operand in register FRB is",
      "converted to an infinitely precise floating-point integer.",
      "The result of the conversion is rounded to double-precision, using",
      "the rounding mode specified by RN, and placed into",
      "register FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert from Integer Model.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
        "form": "X",
        "mnemonic": "fcfidu",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "974",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
        "form": "X",
        "mnemonic": "fcfidu.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "974",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "The 64-bit unsigned fixed-point operand in register FRB",
      "is converted to an infinitely precise floating-point integer.",
      "The result of the conversion is rounded to double-precision, using",
      "the rounding mode specified by RN, and placed into",
      "register FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert from Integer Model.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Signed Doubleword to Single-Precision format",
        "form": "X",
        "mnemonic": "fcfids",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "846",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with round Signed Doubleword to Single-Precision format",
        "form": "X",
        "mnemonic": "fcfids.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "846",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "The 64-bit signed fixed-point operand in register FRB is",
      "converted to an infinitely precise floating-point integer.",
      "The result of the conversion is rounded to single-precision, using",
      "the rounding mode specified by RN, and placed into",
      "register FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert from Integer Model.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
        "form": "X",
        "mnemonic": "fcfidus",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "974",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
        "form": "X",
        "mnemonic": "fcfidus.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "974",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "The 64-bit unsigned fixed-point operand in register FRB",
      "is converted to an infinitely precise floating-point integer.",
      "The result of the conversion is rounded to single-precision, using",
      "the rounding mode specified by RN, and placed into",
      "register FRT.",
      "",
      "The conversion is described fully in",
      "Section,",
      "Floating-Point Convert from Integer Model.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set if the result is incremented when rounded.",
      "FI is set if the result is inexact.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Round to Integer Nearest",
        "form": "X",
        "mnemonic": "frin",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "392",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Round to Integer Nearest",
        "form": "X",
        "mnemonic": "frin.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "392",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is rounded to",
      "an integral value as follows, with the result placed into register",
      "FRT.",
      "If the sign of the operand is positive, (FRB)+0.5 is",
      "truncated to an integral value, otherwise (FRB)-0.5 is",
      "truncated to an integral value.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Round to Integer Toward Zero",
        "form": "X",
        "mnemonic": "friz",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "424",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Round to Integer Toward Zero",
        "form": "X",
        "mnemonic": "friz.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "424",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is rounded to",
      "an integral value using the rounding mode round toward zero, and the",
      "result is placed into register FRT.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE = 1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Round to Integer Plus",
        "form": "X",
        "mnemonic": "frip",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "456",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Round to Integer Plus",
        "form": "X",
        "mnemonic": "frip.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "456",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is rounded to",
      "an integral value using the rounding mode round toward +infinity, and",
      "the result is placed into register FRT.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Round to Integer Minus",
        "form": "X",
        "mnemonic": "frim",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "488",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      },
      {
        "name": "Floating Round to Integer Minus",
        "form": "X",
        "mnemonic": "frim.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "488",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "The floating-point operand in register FRB is rounded to",
      "an integral value using the rounding mode round toward -infinity, and",
      "the result is placed into register FRT.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exceptions when VE=1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Compare Unordered",
        "form": "X",
        "mnemonic": "fcmpu",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "0",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The floating-point operand in register FRA is compared to",
      "the floating-point operand in register FRB.",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "If either of the operands is a NaN, either quiet or signaling, then",
      "CR field BF and the FPCC are set to reflect",
      "unordered.",
      "If either of the operands is a Signaling NaN, then VXSNAN",
      "is set.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Compare Ordered",
        "form": "X",
        "mnemonic": "fcmpo",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "32",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "The floating-point operand in register FRA is compared to",
      "the floating-point operand in register FRB.",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "If either of the operands is a NaN, either quiet or signaling, then",
      "CR field BF and the FPCC are set to reflect",
      "unordered.",
      "If either of the operands is a Signaling NaN, then VXSNAN",
      "is set and, if Invalid Operation is disabled (VE=0),",
      "VXVC is set.",
      "If neither operand is a Signaling NaN but at least one operand is a",
      "Quiet NaN, then VXVC is set.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Floating Select",
        "form": "A",
        "mnemonic": "fsel",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "23",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      },
      {
        "name": "Floating Select",
        "form": "A",
        "mnemonic": "fsel.",
        "operands": [
          "FRT",
          "FRA",
          "FRC",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "FRC",
            "size": "5"
          },
          {
            "name": "23",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "",
      "The floating-point operand in register FRA is compared to",
      "the value zero.",
      "If the operand is greater than or equal to zero, register FRT is set to the contents of register FRC.",
      "If the operand is less than zero or is a NaN, register FRT is set to the contents of register FRB.",
      "The comparison ignores the sign of zero (i.e., regards +0",
      "as equal to -0).",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR",
        "form": "X",
        "mnemonic": "mffs",
        "operands": [
          "FRT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Move From FPSCR",
        "form": "X",
        "mnemonic": "mffs.",
        "operands": [
          "FRT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of the FPSCR are placed into register FRT.",
      "",
      "If Rc=1, CR field 1 is set to the value FX||FEX||VX||OX.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR  Clear Enables",
        "form": "X",
        "mnemonic": "mffsce",
        "operands": [
          "FRT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "The contents of the FPSCR are placed into register FRT.",
      "",
      "The contents of bits 56:60 (VE, OE,",
      "UE, ZE, XE) of the FPSCR are set",
      "to 0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR Control  Set DRN",
        "form": "X",
        "mnemonic": "mffscdrn",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "Let new_DRN be the contents of bits 29:31 of register",
      "FRB.",
      "",
      "The contents of the control bits in the FPSCR, that is, bits 29:31",
      "(DRN) and bits 56:63 (VE, OE,",
      "UE, ZE, XE, NI,",
      "RN), are placed into the corresponding bits in register",
      "FRT.",
      "All other bits in register FRT are set to 0.",
      "",
      "new_DRN is placed into bits 62:64 of the FPSCR",
      "(DRN).",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR Control  Set DRN Immediate",
        "form": "X",
        "mnemonic": "mffscdrni",
        "operands": [
          "FRT",
          "DRM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "21",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "DRM",
            "size": "3"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "The contents of the control bits in the FPSCR, that is, bits 29:31",
      "(DRN) and bits 56:63 (VE, OE,",
      "UE, ZE, XE, NI,",
      "RN), are placed into the corresponding bits in register",
      "FRT.",
      "All other bits in register FRT are set to 0.",
      "",
      "The contents of bits 29:31 of the FPSCR (DRN) are set to",
      "the value of DRM.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR Control  Set RN",
        "form": "X",
        "mnemonic": "mffscrn",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "Let new_RN be the contents of bits 62:63 of register FRB.",
      "",
      "The contents of the control bits in the FPSCR, that is, bits 29:31",
      "(DRN) and bits 56:63 (VE, OE, UE,",
      "ZE, XE, NI, RN), are",
      "placed into the corresponding bits in register FRT.",
      "All other bits in register FRT are set to 0.",
      "",
      "new_RN is placed into bits 62:63 of the FPSCR (RN).",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR Control  Set RN Immediate",
        "form": "X",
        "mnemonic": "mffscrni",
        "operands": [
          "FRT",
          "RM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "23",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "RM",
            "size": "2"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "The contents of the control bits in the FPSCR, that is, bits 29:31",
      "(DRN) and bits 56:63 (VE, OE,",
      "UE, ZE, XE, NI,",
      "RN), are placed into the corresponding bits in register",
      "FRT.",
      "All other bits in register FRT are set to 0.",
      "",
      "The contents of bits 62:63 of the FPSCR (RN) are set to",
      "the value of RM.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From FPSCR Lightweight",
        "form": "X",
        "mnemonic": "mffsl",
        "operands": [
          "FRT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "583",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "The contents of the control bits in the FPSCR, that is, bits 29:31",
      "(DRN) and bits 56:63 (VE, OE,",
      "UE, ZE, XE, NI,",
      "RN), and the non-sticky status bits in the FPSCR, that",
      "is, bits 45:51 (FR, FI, C,",
      "FL, FG, FE, FU), are placed into",
      "the corresponding bits in register FRT.",
      "All other bits in register FRT are set to 0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to Condition Register from FPSCR",
        "form": "X",
        "mnemonic": "mcrfs",
        "operands": [
          "BF",
          "BFA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "BFA",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "64",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of FPSCR field BFA are copied to Condition Register field",
      "BF. All exception bits copied are set to 0 in the FPSCR.",
      "If the FX bit is copied, it is set to 0 in the FPSCR.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To FPSCR Field Immediate",
        "form": "X",
        "mnemonic": "mtfsfi",
        "operands": [
          "BF",
          "U",
          "W"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "W",
            "size": "1"
          },
          {
            "name": "U",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "134",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Move To FPSCR Field Immediate",
        "form": "X",
        "mnemonic": "mtfsfi.",
        "operands": [
          "BF",
          "U",
          "W"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "W",
            "size": "1"
          },
          {
            "name": "U",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "134",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The value of the U field is placed into FPSCR field",
      "BF+8*(1-W).",
      "",
      "FX is altered only if BF=0 and W=0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To FPSCR Fields",
        "form": "XFL",
        "mnemonic": "mtfsf",
        "operands": [
          "FLM",
          "FRB",
          "L",
          "W"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "FLM",
            "size": "8"
          },
          {
            "name": "W",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "711",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Move To FPSCR Fields",
        "form": "XFL",
        "mnemonic": "mtfsf.",
        "operands": [
          "FLM",
          "FRB",
          "L",
          "W"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "FLM",
            "size": "8"
          },
          {
            "name": "W",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "711",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The FPSCR is modified as specified by the FLM, L, and W fields.",
      "",
      "L=0",
      "",
      "",
      "",
      "The contents of register FRB are placed into the FPSCR",
      "under control of the W field and the field mask specified",
      "by FLM.",
      "W and the field mask identify the 4-bit fields affected.",
      "Let i be an integer in the range 0-7.",
      "If FLM=1",
      "then FPSCR field k is set to the contents of the",
      "corresponding field of register FRB, where k=i+8*(1-W).",
      "",
      "",
      "L=1",
      "",
      "",
      "",
      "The contents of register FRB are placed into the FPSCR.",
      "",
      "",
      "FX is not altered implicitly by this instruction.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To FPSCR Bit 0",
        "form": "X",
        "mnemonic": "mtfsb0",
        "operands": [
          "BT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "70",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Move To FPSCR Bit 0",
        "form": "X",
        "mnemonic": "mtfsb0.",
        "operands": [
          "BT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "70",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "Bit BT+32 of the FPSCR is set to 0.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To FPSCR Bit 1",
        "form": "X",
        "mnemonic": "mtfsb1",
        "operands": [
          "BT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "38",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      },
      {
        "name": "Move To FPSCR Bit 1",
        "form": "X",
        "mnemonic": "mtfsb1.",
        "operands": [
          "BT"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "38",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "Bit BT+32 of the FPSCR is set to 1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Add",
        "form": "X",
        "mnemonic": "dadd",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "2",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Add",
        "form": "X",
        "mnemonic": "dadd.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "2",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Add Quad",
        "form": "X",
        "mnemonic": "daddq",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "2",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Add Quad",
        "form": "X",
        "mnemonic": "daddq.",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "2",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRA[p] is added to the DFP operand in",
      "FRB[p].",
      "",
      "The result is rounded to the target-format precision under control of",
      "DRN (bits 29:31 of the FPSCR).",
      "An appropriate form of the rounded result is selected based on the",
      "ideal exponent and is placed in FRT[p].",
      "The ideal exponent is the smaller exponent of the two source operands.",
      "",
      "Figure summarizes the actions for Add.",
      "Figure does not include the setting of",
      "FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "dadd[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Subtract",
        "form": "X",
        "mnemonic": "dsub",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "514",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Subtract",
        "form": "X",
        "mnemonic": "dsub.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "514",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Subtract Quad",
        "form": "X",
        "mnemonic": "dsubq",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "514",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Subtract Quad",
        "form": "X",
        "mnemonic": "dsubq.",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "514",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRB[p] is subtracted from the DFP",
      "operand in FRA[p].",
      "",
      "The result is rounded to the target-format precision under control of",
      "DRN (bits 29:31 of the FPSCR).",
      "An appropriate form of the rounded result is selected based on the",
      "ideal exponent and is placed in FRT[p].",
      "The ideal exponent is the smaller exponent of the two source operands.",
      "",
      "The execution of Subtract is identical to that of Add, except that",
      "the operand in FRB participates in the operation with its",
      "sign bit inverted.  See Figure.",
      "The table does not include the setting of FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "dsub[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Multiply",
        "form": "X",
        "mnemonic": "dmul",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "34",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Multiply",
        "form": "X",
        "mnemonic": "dmul.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "34",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Multiply Quad",
        "form": "X",
        "mnemonic": "dmulq",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "34",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Multiply Quad",
        "form": "X",
        "mnemonic": "dmulq.",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "34",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRA[p] is multiplied by the DFP",
      "operand in FRB[p].",
      "",
      "The result is rounded to the target-format precision under control of",
      "DRN (bits 29:31 of the FPSCR).",
      "An appropriate form of the rounded result is selected based on the",
      "ideal exponent and is placed in FRT[p].",
      "The ideal exponent is the sum of the two exponents of the source",
      "operands.",
      "",
      "Figure summarizes the actions for",
      "Multiply.",
      "Figure does not include the setting of",
      "FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "dmul[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Divide",
        "form": "X",
        "mnemonic": "ddiv",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "546",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Divide",
        "form": "X",
        "mnemonic": "ddiv.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "546",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Divide Quad",
        "form": "X",
        "mnemonic": "ddivq",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "546",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Divide Quad",
        "form": "X",
        "mnemonic": "ddivq.",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "546",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRA[p] is divided by the DFP operand",
      "in FRB[p].",
      "",
      "The result is rounded to the target-format precision under control of",
      "the DRN (bits 29:31 of the FPSCR).",
      "An appropriate form of the rounded result is selected based on the",
      "ideal exponent and is placed in FRT[p].",
      "The ideal exponent is the difference of subtracting the exponent of",
      "the divisor from the exponent of the dividend.",
      "",
      "Figure summarizes the actions for Divide.",
      "Figure does not include the setting of",
      "FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation and enabled zero-divide",
      "exceptions, in which cases the field remains unchanged.",
      "",
      "ddiv[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Compare Unordered",
        "form": "X",
        "mnemonic": "dcmpu",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "642",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Compare Unordered Quad",
        "form": "X",
        "mnemonic": "dcmpuq",
        "operands": [
          "BF",
          "FRAp",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "642",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRA[p] is compared to the DFP operand",
      "in FRB[p].",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "dcmpu[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Compare Ordered",
        "form": "X",
        "mnemonic": "dcmpo",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "130",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Compare Ordered Quad",
        "form": "X",
        "mnemonic": "dcmpoq",
        "operands": [
          "BF",
          "FRAp",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "130",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRA[p] is compared to the DFP operand",
      "in FRB[p].",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "dcmpo[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Test Data Class",
        "form": "Z22",
        "mnemonic": "dtstdc",
        "operands": [
          "BF",
          "FRA",
          "DCM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "DCM",
            "size": "6"
          },
          {
            "name": "194",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Test Data Class Quad",
        "form": "Z22",
        "mnemonic": "dtstdcq",
        "operands": [
          "BF",
          "FRAp",
          "DCM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "DCM",
            "size": "6"
          },
          {
            "name": "194",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the DCM (Data Class Mask) field specify one or more",
      "of the 6 possible data classes, where each bit corresponds to a",
      "specific data class.",
      "",
      "",
      "",
      "",
      "CR field BF and FPCC are set to indicate the",
      "sign of the DFP operand in FRA[p] and whether the data",
      "class of the DFP operand in FRA[p] matches any of the",
      "data classes specified by DCM.",
      "",
      "",
      "",
      "",
      "dtstdc[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Test Data Group",
        "form": "Z22",
        "mnemonic": "dtstdg",
        "operands": [
          "BF",
          "FRA",
          "DGM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "DGM",
            "size": "6"
          },
          {
            "name": "226",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Test Data Group Quad",
        "form": "Z22",
        "mnemonic": "dtstdgq",
        "operands": [
          "BF",
          "FRAp",
          "DGM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "DGM",
            "size": "6"
          },
          {
            "name": "226",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the DGM (Data Group Mask) field specify one or more",
      "of the 6 possible data groups, where each bit corresponds to a",
      "specific data group.",
      "",
      "The term extreme exponent means either the maximum exponent,",
      "X, or the minimum",
      "exponent, X.",
      "",
      "",
      "",
      "",
      "CR field BF and FPCC are set to indicate the",
      "sign of the DFP operand in FRA[p] and whether the data",
      "group of the DFP operand in FRA[p] matches any of the",
      "data groups specified by DGM.",
      "",
      "",
      "",
      "",
      "dtstdg[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Test Exponent",
        "form": "X",
        "mnemonic": "dtstex",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "162",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Test Exponent Quad",
        "form": "X",
        "mnemonic": "dtstexq",
        "operands": [
          "BF",
          "FRAp",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "162",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The exponent value (Ea) of the DFP operand in FRA[p] is compared to the exponent value (Eb) of the DFP",
      "operand in FRB[p].",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "The codes in the CR field BF and FPCC are",
      "defined for the DFP Test Exponent operations as follows.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Test Significance",
        "form": "X",
        "mnemonic": "dtstsf",
        "operands": [
          "BF",
          "FRA",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "674",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Test Significance Quad",
        "form": "X",
        "mnemonic": "dtstsfq",
        "operands": [
          "BF",
          "FRA",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "674",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let k be the contents of bits 58:63 of FPR[FRA] that specifies the reference significance.",
      "",
      "For dtstsf, let the value NSDb be the number",
      "of significant digits of the DFP value in FPR[FRB].",
      "",
      "For dtstsfq, let the value NSDb be the number",
      "of significant digits of the DFP value in FPR[FRBp:FRBp+1].",
      "",
      "For this instruction, the number of significant digits of the value 0",
      "is considered to be zero.",
      "",
      "NSDb is compared to k.",
      "The result of the compare is placed into CR field BF and",
      "the FPCC as follows.",
      "",
      "",
      "",
      "",
      "dtstsf[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Test Significance Immediate",
        "form": "X",
        "mnemonic": "dtstsfi",
        "operands": [
          "BF",
          "UIM",
          "FRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "675",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "DFP Test Significance Immediate Quad",
        "form": "X",
        "mnemonic": "dtstsfiq",
        "operands": [
          "BF",
          "UIM",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "675",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the value UIM specify the reference significance.",
      "",
      "For dtstsfi, let the value NSDb be the number",
      "of significant digits of the DFP value in FPR[FRB].",
      "",
      "For dtstsfiq, let the value NSDb be the number",
      "of significant digits of the DFP value in FPR[FRBp:FRBp+1].",
      "",
      "For this instruction, the number of significant digits of the value",
      "0 is considered to be zero.",
      "",
      "NSDb is compared to UIM.",
      "The result of the compare is placed into CR field BF and",
      "the FPCC as follows.",
      "",
      "",
      "",
      "",
      "dtstsfi[q] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Quantize Immediate",
        "form": "Z23",
        "mnemonic": "dquai",
        "operands": [
          "TE",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "TE",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "67",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize Immediate",
        "form": "Z23",
        "mnemonic": "dquai.",
        "operands": [
          "TE",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "TE",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "67",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize Immediate Quad",
        "form": "Z23",
        "mnemonic": "dquaiq",
        "operands": [
          "TE",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "TE",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "67",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize Immediate Quad",
        "form": "Z23",
        "mnemonic": "dquaiq.",
        "operands": [
          "TE",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "TE",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "67",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRB[p] is converted and rounded to the",
      "form with the exponent specified by TE based on the",
      "rounding mode specified in the RMC field.",
      "TE is a 5-bit signed binary integer.",
      "The result of that form is placed in FRT[p].",
      "The sign of the result is the same as the sign of the operand in",
      "FRB[p].",
      "The ideal exponent is the exponent specified by TE.",
      "",
      "When the value of the operand in FRB[p] is greater than",
      "(10-1) ",
      "10, where p is the",
      "format precision, an invalid operation exception is recognized.",
      "",
      "When the delivered result differs in value from the operand in",
      "FRB[p], an inexact exception is recognized.",
      "No underflow exception is recognized by this operation, regardless of",
      "the value of the operand in FRB[p].",
      "",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "dquai[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Quantize",
        "form": "Z23",
        "mnemonic": "dqua",
        "operands": [
          "FRT",
          "FRA",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize",
        "form": "Z23",
        "mnemonic": "dqua.",
        "operands": [
          "FRT",
          "FRA",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize Quad",
        "form": "Z23",
        "mnemonic": "dquaq",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Quantize Quad",
        "form": "Z23",
        "mnemonic": "dquaq.",
        "operands": [
          "FRTp",
          "FRAp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in register FRB[p] is converted and",
      "rounded to the form with the same exponent as that of the DFP operand",
      "in FRA[p] based on the rounding mode specified by",
      "RMC.",
      "The result of that form is placed in FRT[p].",
      "The sign of the result is the same as the sign of the operand in",
      "FRB[p].",
      "The ideal exponent is the exponent specified in FRA[p].",
      "",
      "When the value of the operand in FRB[p] is greater than",
      "(10-1) x",
      "10, where p is the format precision",
      "and Ea is the exponent of the operand in FRA[p], an invalid operation exception is recognized.",
      "",
      "When the delivered result differs in value from the operand in",
      "FRB[p], an inexact exception is recognized.",
      "No underflow exception is recognized by this operation, regardless of",
      "the value of the operand in FRB[p].",
      "",
      "Figure and",
      "Figure summarize the",
      "actions.  The tables do not include the setting of FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "dqua[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Reround",
        "form": "Z23",
        "mnemonic": "drrnd",
        "operands": [
          "FRT",
          "FRA",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Reround",
        "form": "Z23",
        "mnemonic": "drrnd.",
        "operands": [
          "FRT",
          "FRA",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Reround Quad",
        "form": "Z23",
        "mnemonic": "drrndq",
        "operands": [
          "FRTp",
          "FRA",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Reround Quad",
        "form": "Z23",
        "mnemonic": "drrndq.",
        "operands": [
          "FRTp",
          "FRA",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let k be the contents of bits 58:63 of FRA",
      "that specifies the reference significance.",
      "",
      "When the DFP operand in FRB[p] is a finite number, and if",
      "the reference significance is zero, or if the reference significance",
      "is nonzero and the number of significant digits of the source operand",
      "is less than or equal to the reference significance, then the value",
      "and the form of the source operand is placed in FRT[p].",
      "If the reference significance is nonzero and the number of",
      "significant digits of the source operand is greater than the",
      "reference significance, then the source operand is converted and",
      "rounded to the number of significant digits specified in the",
      "reference significance based on the rounding mode specified in the",
      "RMC field.",
      "The result of the form with the specified number of significant",
      "digits is placed in FRT[p].",
      "The sign of the result is the same as the sign of the operand in",
      "FRB[p].",
      "",
      "For this instruction, the number of significant digits of the value 0",
      "is considered to be zero.",
      "The ideal exponent is the greater value of the exponent of the",
      "operand in FRB[p] and the referenced exponent.",
      "The referenced exponent is the resultant exponent if the operand in",
      "FRB[p] would have been converted and rounded to the",
      "number of significant digits specified in the reference significance",
      "based on the rounding mode specified by RMC.",
      "",
      "If the exponent of the rounded result of the form that has the",
      "specified number of significant digits would be greater than",
      "X, an",
      "invalid operation exception (VXCVI) occurs.",
      "When the invalid-operation exception occurs, and if the exception is",
      "disabled, a default QNaN is returned.",
      "When an invalid-operation exception occurs, no inexact exception is",
      "recognized.",
      "",
      "In the absence of an invalid-operation exception, if the result",
      "differs in value from the operand in FRB[p], an inexact",
      "exception is recognized.",
      "",
      "This operation causes neither an overflow nor an underflow exception.",
      "",
      "Figure summarizes the actions for",
      "Reround.",
      "The table does not include the setting of FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation exception, in which case the",
      "field remains unchanged.",
      "",
      "drrnd[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Round To FP Integer With Inexact",
        "form": "Z23",
        "mnemonic": "drintx",
        "operands": [
          "R",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "99",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer With Inexact",
        "form": "Z23",
        "mnemonic": "drintx.",
        "operands": [
          "R",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "99",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer With Inexact Quad",
        "form": "Z23",
        "mnemonic": "drintxq",
        "operands": [
          "R",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "99",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer With Inexact Quad",
        "form": "Z23",
        "mnemonic": "drintxq.",
        "operands": [
          "R",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "99",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRB[p] is rounded to a floating-point",
      "integer and placed into FRT[p].",
      "The sign of the result is the same as the sign of the operand in",
      "FRB[p].",
      "The ideal exponent is the larger value of zero and the exponent of",
      "the operand in FRB[p].",
      "",
      "The rounding mode used is specified by RMC.",
      "When the RMC-encoding-selection (R) bit is",
      "zero, RMC field contains the primary encoding; when the",
      "bit is one, the field contains the secondary encoding.",
      "",
      "In addition to coercion of the converted value to fit the target",
      "format, the special rounding used by Round To FP Integer",
      "also coerces the target exponent to the ideal exponent.",
      "",
      "When the operand in FRB[p] is a finite number and the",
      "exponent is less than zero, the operand is rounded to the result with",
      "an exponent of zero.",
      "When the exponent is greater than or equal to zero, the result is set",
      "to the numerical value and the form of the operand in FRB[p].",
      "",
      "When the result differs in value from the operand in FRB[p], an inexact exception is recognized.",
      "No underflow exception is recognized by this operation, regardless of",
      "the value of the operand in FRB[p].",
      "",
      "Figure",
      "summarizes the actions for Round To FP Integer With",
      "Inexact.",
      "The table does not include the setting of FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation, in which case the field",
      "remains unchanged.",
      "",
      "drintx[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Round To FP Integer Without Inexact",
        "form": "Z23",
        "mnemonic": "drintn",
        "operands": [
          "R",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "227",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer Without Inexact",
        "form": "Z23",
        "mnemonic": "drintn.",
        "operands": [
          "R",
          "FRT",
          "FRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "227",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer Without Inexact Quad",
        "form": "Z23",
        "mnemonic": "drintnq",
        "operands": [
          "R",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "227",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To FP Integer Without Inexact Quad",
        "form": "Z23",
        "mnemonic": "drintnq.",
        "operands": [
          "R",
          "FRTp",
          "FRBp",
          "RMC"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "227",
            "size": "8"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "This operation is the same as the Round To FP Integer With",
      "Inexact operation, except that this operation does not recognize an",
      "inexact exception.",
      "",
      "Figure",
      "summarizes the actions for Round To FP Integer Without",
      "Inexact.",
      "The table does not include the setting of FPRF.",
      "FPRF is always set to the class and sign of the result,",
      "except for an enabled invalid-operation, in which case the field",
      "remains unchanged.",
      "",
      "drintn[q][.] are treated as Floating-Point instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert To DFP Long",
        "form": "X",
        "mnemonic": "dctdp",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "258",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert To DFP Long",
        "form": "X",
        "mnemonic": "dctdp.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "258",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP short operand in bits 32:63 of FRB is converted",
      "to DFP long format and the converted result is placed into FRT.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is the exponent of the source operand.",
      "",
      "If the operand in FRB is an SNaN, it is converted to an",
      "SNaN in DFP long format and does not cause an invalid-operation",
      "exception.",
      "",
      "dctdp[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert To DFP Extended",
        "form": "X",
        "mnemonic": "dctqpq",
        "operands": [
          "FRTp",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "258",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert To DFP Extended",
        "form": "X",
        "mnemonic": "dctqpq.",
        "operands": [
          "FRTp",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "258",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP long operand in the FRB is converted to DFP",
      "extended format and placed into FRTp.",
      "The sign of the result is the same as the sign of the operand in FRB.",
      "The ideal exponent is the exponent of the operand in FRB.",
      "",
      "If the operand in FRB is an SNaN, an invalid-operation",
      "exception is recognized.",
      "If the exception is disabled, the SNaN is converted to the",
      "corresponding QNaN in DFP extended format.",
      "",
      "dctqpq[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Round To DFP Short",
        "form": "X",
        "mnemonic": "drsp",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "770",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To DFP Short",
        "form": "X",
        "mnemonic": "drsp.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "770",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP long operand in FRB is converted and rounded to",
      "DFP short format.",
      "The DFP short value is extended on the left with zeros to form a",
      "64-bit entity and placed into FRT.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is the exponent of the source operand.",
      "",
      "If the operand in FRB is an SNaN, it is converted to an",
      "SNaN in DFP short format and does not cause an invalid-operation",
      "exception.",
      "",
      "Normally, the result is in the format and length of the target.",
      "However, when an overflow or underflow exception occurs and if the",
      "exception is enabled, the operation is completed by producing a",
      "wrapped rounded result in the same format and length as the source",
      "but rounded to the target-format precision.",
      "",
      "drsp[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Round To DFP Long",
        "form": "X",
        "mnemonic": "drdpq",
        "operands": [
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "770",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Round To DFP Long",
        "form": "X",
        "mnemonic": "drdpq.",
        "operands": [
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "770",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP extended operand in FRBp is converted and rounded",
      "to DFP long format.",
      "The result concatenated with 64 0s is placed in FRTp.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is the exponent of the operand in FRBp.",
      "",
      "If the operand in FRBp is an SNaN, an invalid-operation",
      "exception is recognized.",
      "If the exception is disabled, the SNaN is converted to the",
      "corresponding QNaN in DFP long format.",
      "",
      "Normally, the result is in the format and length of the target.",
      "However, when an overflow or underflow exception occurs and if the",
      "exception is enabled, the operation is completed by producing a",
      "wrapped rounded result in the same format and length as the source",
      "but rounded to the target-format precision.",
      "",
      "drdpq[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert From Fixed",
        "form": "X",
        "mnemonic": "dcffix",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "802",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "DFP Convert From Fixed",
        "form": "X",
        "mnemonic": "dcffix.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "802",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "The 64-bit signed binary integer in FRB is converted and",
      "rounded to a DFP Long value and placed into FRT.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is zero.",
      "",
      "If the source operand is a zero, then a plus zero with a zero",
      "exponent is returned.",
      "",
      "FPRF is set to the class and sign of the result.",
      "",
      "dcffix[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert From Fixed Quad",
        "form": "X",
        "mnemonic": "dcffixq",
        "operands": [
          "FRTp",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "802",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert From Fixed Quad",
        "form": "X",
        "mnemonic": "dcffixq.",
        "operands": [
          "FRTp",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "802",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The 64-bit signed binary integer in FRB is converted and",
      "rounded to a DFP Extended value and placed into FRTp.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is zero.",
      "",
      "If the source operand is a zero, then a plus zero with a zero",
      "exponent is returned.",
      "",
      "FPRF is set to the class and sign of the result.",
      "",
      "dcffixq[.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert From Fixed Quadword Quad",
        "form": "X",
        "mnemonic": "dcffixqq",
        "operands": [
          "FRTp",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "994",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "The 128-bit signed binary integer in VRB is converted and",
      "rounded to a DFP Extended value and placed into FRTp.",
      "The sign of the result is the same as the sign of the source operand.",
      "The ideal exponent is zero.",
      "",
      "If the source operand is a zero, then a plus zero with a zero",
      "exponent is returned.",
      "",
      "FPRF is set to the class and sign of the result.",
      "",
      "dcffixqq is treated as a Floating-Point and a",
      "Vector instruction in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert To Fixed",
        "form": "X",
        "mnemonic": "dctfix",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "290",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert To Fixed",
        "form": "X",
        "mnemonic": "dctfix.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "290",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert To Fixed Quad",
        "form": "X",
        "mnemonic": "dctfixq",
        "operands": [
          "FRT",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "290",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Convert To Fixed Quad",
        "form": "X",
        "mnemonic": "dctfixq.",
        "operands": [
          "FRT",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "290",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRB[p] is rounded to an integer value",
      "and is placed into FRT in the 64-bit signed binary",
      "integer format.",
      "The sign of the result is the same as the sign of the source operand,",
      "except when the source operand is a NaN or a zero.",
      "",
      "Figure summarizes the actions",
      "for Convert To Fixed.",
      "",
      "dctfix[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Convert To Fixed Quadword Quad",
        "form": "X",
        "mnemonic": "dctfixqq",
        "operands": [
          "VRT",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "994",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "The DFP operand in FRBp is rounded to an integer value",
      "and is placed into VRT in the 128-bit signed binary",
      "integer format.",
      "The sign of the result is the same as the sign of the source operand,",
      "except when the source operand is a NaN or a zero.",
      "",
      "Figure 96 summarizes the actions for Convert To Fixed.",
      "",
      "dctfixqq is treated as a Floating-Point and a Vector",
      "instruction in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Decode DPD To BCD",
        "form": "X",
        "mnemonic": "ddedpd",
        "operands": [
          "SP",
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "SP",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "322",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Decode DPD To BCD",
        "form": "X",
        "mnemonic": "ddedpd.",
        "operands": [
          "SP",
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "SP",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "322",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Decode DPD To BCD Quad",
        "form": "X",
        "mnemonic": "ddedpdq",
        "operands": [
          "SP",
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "SP",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "322",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Decode DPD To BCD Quad",
        "form": "X",
        "mnemonic": "ddedpdq.",
        "operands": [
          "SP",
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "SP",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "322",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "A portion of the significand of the DFP operand in FRB[p]",
      "is converted to a signed or unsigned BCD number depending on the",
      "SP field.",
      "For infinity and NaN, the significand is considered to be the",
      "contents in the trailing significand field padded on the left by a",
      "zero digit.",
      "",
      "SP0 = 0 (unsigned conversion)",
      "",
      "",
      "",
      "The rightmost 16 digits of the significand (32 digits for",
      "ddedpdq) is converted to an unsigned BCD number",
      "and the result is placed into FRT[p].",
      "",
      "",
      "SP0 = 1 (signed conversion)",
      "",
      "",
      "",
      "The rightmost 15 digits of the significand (31 digits for",
      "ddedpdq) is converted to a signed BCD number with",
      "the same sign as the DFP operand, and the result is placed into",
      "FRT[p].",
      "If the DFP operand is negative, the sign is encoded as 0b1101.",
      "If the DFP operand is positive, SP indicates which preferred plus sign",
      "encoding is used.",
      "If SP = 0, the",
      "plus sign is encoded as 0b1100 (the option-1 preferred",
      "sign code), otherwise the plus sign is encoded as 0b1111",
      "(the option-2 preferred sign code).",
      "",
      "",
      "ddedpd[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Encode BCD To DPD",
        "form": "X",
        "mnemonic": "denbcd",
        "operands": [
          "S",
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "S",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "834",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Encode BCD To DPD",
        "form": "X",
        "mnemonic": "denbcd.",
        "operands": [
          "S",
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "S",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "834",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Encode BCD To DPD Quad",
        "form": "X",
        "mnemonic": "denbcdq",
        "operands": [
          "S",
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "S",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "834",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Encode BCD To DPD Quad",
        "form": "X",
        "mnemonic": "denbcdq.",
        "operands": [
          "S",
          "FRTp",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "S",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "834",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The signed or unsigned BCD operand, depending on the S field, in",
      "FRB[p] is converted to a DFP number.",
      "The ideal exponent is zero.",
      "",
      "S = 0 (unsigned BCD operand)",
      "",
      "",
      "",
      "The unsigned BCD operand in FRB[p] is converted to a",
      "positive DFP number of the same magnitude and the result is placed",
      "into FRT[p].",
      "",
      "",
      "S = 1 (signed BCD operand)",
      "",
      "",
      "",
      "The signed BCD operand in FRB[p] is converted to the",
      "corresponding DFP number and the result is placed into FRT[p].",
      "",
      "",
      "If an invalid BCD digit or sign code is detected in the source",
      "operand, an invalid-operation exception (VXCVI) occurs.",
      "",
      "FPRF is set to the class and sign of the result, except",
      "for Invalid Operation Exception when VE=1.",
      "",
      "denbcd[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Extract Biased Exponent",
        "form": "X",
        "mnemonic": "dxex",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "354",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Extract Biased Exponent",
        "form": "X",
        "mnemonic": "dxex.",
        "operands": [
          "FRT",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "354",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Extract Biased Exponent Quad",
        "form": "X",
        "mnemonic": "dxexq",
        "operands": [
          "FRT",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "354",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Extract Biased Exponent Quad",
        "form": "X",
        "mnemonic": "dxexq.",
        "operands": [
          "FRT",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "354",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The biased exponent of the operand in FRB[p] is extracted",
      "and placed into FRT in the 64-bit signed binary integer",
      "format.",
      "When the operand in FRB is an infinity, QNaN, or SNaN, a",
      "special code is returned.",
      "",
      "",
      "",
      "",
      "dxex[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Insert Biased Exponent",
        "form": "X",
        "mnemonic": "diex",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "866",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Insert Biased Exponent",
        "form": "X",
        "mnemonic": "diex.",
        "operands": [
          "FRT",
          "FRA",
          "FRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRB",
            "size": "5"
          },
          {
            "name": "866",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Insert Biased Exponent Quad",
        "form": "X",
        "mnemonic": "diexq",
        "operands": [
          "FRTp",
          "FRA",
          "FRBp"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "866",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Insert Biased Exponent Quad",
        "form": "X",
        "mnemonic": "diexq.",
        "operands": [
          "FRTp",
          "FRA",
          "FRBp"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "FRBp",
            "size": "5"
          },
          {
            "name": "866",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let a be the value of the 64-bit signed binary integer in",
      "FRA.",
      "",
      "",
      "",
      "",
      "When 0  a  MBE,",
      "a is the biased target exponent that is combined with the",
      "sign bit and the significand value of the DFP operand in FRB[p] to form the DFP result in FRT[p].",
      "The ideal exponent is the specified target exponent.",
      "",
      "When a specifies a special code (a  0 or",
      "a  MBE), an infinity, QNaN, or SNaN is formed in",
      "FRT[p] with the trailing significand field containing the",
      "value from the trailing significand field of the source operand in",
      "FRB[p], and with an N-bit combination field set as",
      "follows.",
      "",
      "",
      "",
      "diex[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Shift Significand Left Immediate",
        "form": "Z22",
        "mnemonic": "dscli",
        "operands": [
          "FRT",
          "FRA",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "66",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Left Immediate",
        "form": "Z22",
        "mnemonic": "dscli.",
        "operands": [
          "FRT",
          "FRA",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "66",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Left Immediate Quad",
        "form": "Z22",
        "mnemonic": "dscliq",
        "operands": [
          "FRTp",
          "FRAp",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "66",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Left Immediate Quad",
        "form": "Z22",
        "mnemonic": "dscliq.",
        "operands": [
          "FRTp",
          "FRAp",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "66",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The significand of the DFP operand in FRA[p] is shifted",
      "left SH digits.",
      "For a NaN or infinity, all significand digits are in the trailing",
      "significand field. SH is a 6-bit unsigned binary integer.",
      "Digits shifted out of the leftmost digit are lost.",
      "Zeros are supplied to the vacated positions on the right.",
      "The result is placed into FRT[p].",
      "The sign of the result is the same as the sign of the source operand",
      "in FRA[p].",
      "",
      "If the source operand in FRA[p] is a finite number, the",
      "exponent of the result is the same as the exponent of the source",
      "operand.",
      "",
      "For an Infinity, QNaN or SNaN result, the target formats N-bit",
      "combination field is set as follows.",
      "",
      "",
      "",
      "dscli[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "DFP Shift Significand Right Immediate",
        "form": "Z22",
        "mnemonic": "dscri",
        "operands": [
          "FRT",
          "FRA",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "98",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Right Immediate",
        "form": "Z22",
        "mnemonic": "dscri.",
        "operands": [
          "FRT",
          "FRA",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "FRT",
            "size": "5"
          },
          {
            "name": "FRA",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "98",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Right Immediate Quad",
        "form": "Z22",
        "mnemonic": "dscriq",
        "operands": [
          "FRTp",
          "FRAp",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "98",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      },
      {
        "name": "DFP Shift Significand Right Immediate Quad",
        "form": "Z22",
        "mnemonic": "dscriq.",
        "operands": [
          "FRTp",
          "FRAp",
          "SH"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "FRTp",
            "size": "5"
          },
          {
            "name": "FRAp",
            "size": "5"
          },
          {
            "name": "SH",
            "size": "6"
          },
          {
            "name": "98",
            "size": "9"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The significand of the DFP operand in FRA[p] is shifted",
      "right SH digits.",
      "For a NaN or infinity, all significand digits are in the trailing",
      "significand field. SH is a 6-bit unsigned binary integer.",
      "Digits shifted out of the units digit are lost.",
      "Zeros are supplied to the vacated positions on the left.",
      "The result is placed into FRT[p].",
      "The sign of the result is the same as the sign of the source operand",
      "in FRA[p].",
      "",
      "If the source operand in FRA[p] is a finite number, the",
      "exponent of the result is the same as the exponent of the source",
      "operand.",
      "",
      "For an Infinity, QNaN or SNaN result, the target formats N-bit",
      "combination field is set as follows.",
      "",
      "",
      "",
      "dscri[q][.] are treated as Floating-Point",
      "instructions in terms of resource availability.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector Element Byte Indexed",
        "form": "X",
        "mnemonic": "lvebx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "7",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access, the",
      "contents of the byte in storage at address EA are placed",
      "into byte eb of VSR[VRT+32].",
      "The remaining bytes of VSR[VRT+32] are set to undefined",
      "values.",
      "",
      "If Little-Endian byte ordering is used for the storage access, the",
      "contents of the byte in storage at address EA are placed",
      "into byte 15-eb of VSR[VRT+32].",
      "The remaining bytes of VSR[VRT+32] are set to undefined",
      "values.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector Element Halfword Indexed",
        "form": "X",
        "mnemonic": "lvehx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "39",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE with the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "If Little-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector Element Word Indexed",
        "form": "X",
        "mnemonic": "lvewx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "71",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC with the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "If if Little-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector Indexed",
        "form": "X",
        "mnemonic": "lvx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "103",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
      "",
      "The contents of the quadword in storage at address EA are",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector Indexed Last",
        "form": "X",
        "mnemonic": "lvxl",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "359",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
      "",
      "The contents of the quadword in storage at address EA are",
      "placed into VSR[VRT+32].",
      "",
      "lvxl provides a hint that the quadword in storage",
      "addressed by EA will probably not be needed again by the",
      "program in the near future.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Vector Element Byte Indexed",
        "form": "X",
        "mnemonic": "stvebx",
        "operands": [
          "VRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "135",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access, the",
      "contents of byte eb of VSR[VRS+32] are placed",
      "in the byte in storage at address EA.",
      "",
      "If Little-Endian byte ordering is used for the storage access, the",
      "contents of byte 15-eb of VSR[VRS+32] are",
      "placed in the byte in storage at address EA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Vector Element Halfword Indexed",
        "form": "X",
        "mnemonic": "stvehx",
        "operands": [
          "VRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "167",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE with the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "If Little-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Vector Element Word Indexed",
        "form": "X",
        "mnemonic": "stvewx",
        "operands": [
          "VRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "199",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC with the sum (RA|0)+(RB).",
      "",
      "Let eb be bits 60:63 of EA.",
      "",
      "If Big-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "If Little-Endian byte ordering is used for the storage access,",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Vector Indexed",
        "form": "X",
        "mnemonic": "stvx",
        "operands": [
          "VRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "231",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
      "",
      "The contents of VSR[VRS+32] are placed into the quadword",
      "in storage at address EA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Vector Indexed Last",
        "form": "X",
        "mnemonic": "stvxl",
        "operands": [
          "VRS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "487",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
      "",
      "The contents of VSR[VRS+32] are placed into the quadword",
      "in storage at address EA.",
      "",
      "stvxl provides a hint that the quadword in",
      "storage addressed by EA will probably not be needed again",
      "by the program in the near future.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector for Shift Left Indexed",
        "form": "X",
        "mnemonic": "lvsl",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "6",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let sh be bits 60:63 of the sum of the contents of",
      "GPR[RA], or 0 if RA=0, and the contents of",
      "GPR[RB].",
      "",
      "Let X be the 32-byte value 0x00 || 0x01 || 0x02 ||  || 0x1D ||",
      "0x1E || 0x1F.",
      "",
      "Bytes sh to sh+15 of X are placed",
      "into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Vector for Shift Right Indexed",
        "form": "X",
        "mnemonic": "lvsr",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "38",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let sh be bits 60:63 of the sum of the contents of",
      "GPR[RA], or 0 if RA=0, and the contents of",
      "GPR[RB].",
      "",
      "Let X be the 32-byte value 0x00 || 0x01 || 0x02 ||  || 0x1D ||",
      "0x1E || 0x1F.",
      "",
      "Bytes 16-sh to 31-sh of X are",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Pixel",
        "form": "VX",
        "mnemonic": "vpkpx",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "782",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of word element i of vsrc are",
      "packed to produce a 16-bit value as described below.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Halfword Signed Saturate",
        "form": "VX",
        "mnemonic": "vpkshss",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "398",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "vsrc is placed into byte element i of",
      "VSR[VRT+32] in signed integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Halfword Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpkshus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "270",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "vsrc is placed into byte element i of",
      "VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Word Signed Saturate",
        "form": "VX",
        "mnemonic": "vpkswss",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "462",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i of vsrc is placed into halfword element i of VSR[VRT+32] in signed integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Word Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpkswus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "334",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i of vsrc is placed into halfword element i of VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Doubleword Signed Saturate",
        "form": "VX",
        "mnemonic": "vpksdss",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1486",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in doubleword element i of",
      "vsrc is placed into word element i of",
      "VSR[VRT+32] in signed integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Signed Doubleword Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpksdus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1358",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in doubleword element i of",
      "vsrc is placed into word element i of",
      "VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Halfword Unsigned Modulo",
        "form": "VX",
        "mnemonic": "vpkuhum",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "14",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of bits 8:15 of halfword element i of",
      "vsrc are placed into byte element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Halfword Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpkuhus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "142",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i of",
      "vsrc are placed into byte element i of",
      "VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Word Unsigned Modulo",
        "form": "VX",
        "mnemonic": "vpkuwum",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "78",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of bits 16:31 of word element i of",
      "vsrc are placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Word Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpkuwus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "206",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i of",
      "vsrc is placed into halfword element i of",
      "VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Doubleword Unsigned Modulo",
        "form": "VX",
        "mnemonic": "vpkudum",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1102",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of bits 32:63 of doubleword element i of",
      "vsrc are placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Pack Unsigned Doubleword Unsigned Saturate",
        "form": "VX",
        "mnemonic": "vpkudus",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1230",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in doubleword element i of",
      "vsrc are placed into halfword element i of",
      "VSR[VRT+32] in unsigned integer format.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack High Signed Byte",
        "form": "VX",
        "mnemonic": "vupkhsb",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "526",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i of VSR[VRB+32] is sign-extended and placed into halfword element",
      "i in VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack Low Signed Byte",
        "form": "VX",
        "mnemonic": "vupklsb",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "654",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i+8 of",
      "VSR[VRB+32] is sign-extended and placed into halfword",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack High Signed Halfword",
        "form": "VX",
        "mnemonic": "vupkhsh",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "590",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "VSR[VRB+32] is sign-extended and placed into word element",
      "i in VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack Low Signed Halfword",
        "form": "VX",
        "mnemonic": "vupklsh",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "718",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i+4 of",
      "VSR[VRB+32] is sign-extended to produce a signed-integer",
      "word and placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack High Signed Word",
        "form": "VX",
        "mnemonic": "vupkhsw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1614",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i of VSR[VRB+32] is sign-extended and placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack Low Signed Word",
        "form": "VX",
        "mnemonic": "vupklsw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1742",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i+2 of",
      "VSR[VRB+32] is sign-extended and placed into doubleword",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack High Pixel",
        "form": "VX",
        "mnemonic": "vupkhpx",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "846",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of halfword element i of VSR[VRB+32] are unpacked as follows.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed in word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Unpack Low Pixel",
        "form": "VX",
        "mnemonic": "vupklpx",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "974",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of halfword element i+4 of VSR[VRB+32] are unpacked as follows.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed in word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge High Byte",
        "form": "VX",
        "mnemonic": "vmrghb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "12",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of byte element i of VSR[VRA+32]",
      "are placed into byte element 2i of VSR[VRT+32].",
      "",
      "",
      "The contents of byte element i of VSR[VRB+32]",
      "are placed into byte element 2i+1 of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge Low Byte",
        "form": "VX",
        "mnemonic": "vmrglb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "268",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of byte element i+8 of VSR[VRA+32] are",
      "placed into byte element 2i of VSR[VRT+32].",
      "",
      "",
      "The contents of byte element i+8 of VSR[VRB+32] are",
      "placed into byte element 2i+1 of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge High Halfword",
        "form": "VX",
        "mnemonic": "vmrghh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "76",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of halfword element i of VSR[VRA+32] are placed into halfword element 2i of VSR[VRT+32].",
      "",
      "",
      "The contents of halfword element i of VSR[VRB+32] are placed into halfword element 2i+1 of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge Low Halfword",
        "form": "VX",
        "mnemonic": "vmrglh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "332",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of halfword element i+4 of VSR[VRA+32] are placed into halfword element 2i of VSR[VRT+32].",
      "",
      "",
      "The contents of halfword element i+4 of VSR[VRB+32] are placed into halfword element 2i+1 of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge High Word",
        "form": "VX",
        "mnemonic": "vmrghw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "140",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 0 of VSR[VRA+32] are placed",
      "into word element 0 of VSR[VRT+32].",
      "",
      "The contents of word element 0 of VSR[VRB+32] are placed",
      "into word element 1 of VSR[VRT+32].",
      "",
      "The contents of word element 1 of VSR[VRA+32] are placed",
      "into word element 2 of VSR[VRT+32].",
      "",
      "The contents of word element 1 of VSR[VRB+32] are placed",
      "into word element 3 of VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge Low Word",
        "form": "VX",
        "mnemonic": "vmrglw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "396",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 2 of VSR[VRA+32] are placed",
      "into word element 0 of VSR[VRT+32].",
      "",
      "The contents of word element 2 of VSR[VRB+32] are placed",
      "into word element 1 of VSR[VRT+32].",
      "",
      "The contents of word element 3 of VSR[VRA+32] are placed",
      "into word element 2 of VSR[VRT+32].",
      "",
      "The contents of word element 3 of VSR[VRB+32] are placed",
      "into word element 3 of VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge Even Word",
        "form": "VX",
        "mnemonic": "vmrgew",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1932",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 0 of VSR[VRA+32] are placed",
      "into word element 0 of VSR[VRT+32].",
      "",
      "The contents of word element 0 of VSR[VRB+32] are placed",
      "into word element 1 of VSR[VRT+32].",
      "",
      "The contents of word element 2 of VSR[VRA+32] are placed",
      "into word element 2 of VSR[VRT+32].",
      "",
      "The contents of word element 2 of VSR[VRB+32] are placed",
      "into word element 3 of VSR[VRT+32].",
      "",
      "vmrgew is treated as a Vector",
      "instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Merge Odd Word",
        "form": "VX",
        "mnemonic": "vmrgow",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1676",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 1 of VSR[VRA+32] are placed",
      "into word element 0 of VSR[VRT+32].",
      "",
      "The contents of word element 1 of VSR[VRB+32] are placed",
      "into word element 1 of VSR[VRT+32].",
      "",
      "The contents of word element 3 of VSR[VRA+32] are placed",
      "into word element 2 of VSR[VRT+32].",
      "",
      "The contents of word element 3 of VSR[VRB+32] are placed",
      "into word element 3 of VSR[VRT+32].",
      "",
      "vmrgow is treated as a Vector",
      "instruction in terms of resource availability.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Byte",
        "form": "VX",
        "mnemonic": "vspltb",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "524",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of byte element UIM in VSR[VRB+32] are placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Halfword",
        "form": "VX",
        "mnemonic": "vsplth",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "UIM",
            "size": "3"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "588",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of halfword element UIM in VSR[VRB+32] are placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Word",
        "form": "VX",
        "mnemonic": "vspltw",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "UIM",
            "size": "2"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "652",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of word element UIM in VSR[VRB+32] are placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Immediate Signed Byte",
        "form": "VX",
        "mnemonic": "vspltisb",
        "operands": [
          "VRT",
          "SIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "SIM",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "780",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The value of the SIM field, sign-extended to 8 bits, is",
      "placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Immediate Signed Halfword",
        "form": "VX",
        "mnemonic": "vspltish",
        "operands": [
          "VRT",
          "SIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "SIM",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "844",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The value of the SIM field, sign-extended to 16 bits, is",
      "placed into halfword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Splat Immediate Signed Word",
        "form": "VX",
        "mnemonic": "vspltisw",
        "operands": [
          "VRT",
          "SIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "SIM",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "908",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The value of the SIM field, sign-extended to 32 bits, is",
      "placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Permute",
        "form": "VA",
        "mnemonic": "vperm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "43",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let the source vector be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let index be the value specified by bits 3:7 of byte",
      "element i of VSR[VRC+32].",
      "",
      "",
      "The contents of byte element index of src are",
      "placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Permute Right-indexed",
        "form": "VA",
        "mnemonic": "vpermr",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "59",
            "size": "6"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let the source vector be the concatenation of the contents of",
      "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let index be the value specified by bits 3:7 of byte",
      "element i of VSR[VRC+32].",
      "",
      "",
      "The contents of byte element 31-index of src",
      "are placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Select",
        "form": "VA",
        "mnemonic": "vsel",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "42",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "Let mask be the contents of VSR[VRC+32].",
      "",
      "The value, (src1mask)|(src2mask), is",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Double by Bit Immediate",
        "form": "VN",
        "mnemonic": "vsldbi",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "SH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "0",
            "size": "2"
          },
          {
            "name": "SH",
            "size": "3"
          },
          {
            "name": "22",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the contents of VSR[VRA+32]",
      "concatenated with the contents of VSR[VRB+32].",
      "",
      "The contents of bits SH:SH+127 of vsrc are",
      "placed into VSR[VRT+32].",
      "",
      "SH can be any integer value between 0 and 7.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Double by Octet Immediate",
        "form": "VA",
        "mnemonic": "vsldoi",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "SHB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "SHB",
            "size": "4"
          },
          {
            "name": "44",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the contents of VSR[VRA+32]",
      "concatenated with the contents of VSR[VRB+32].",
      "",
      "Bytes SHB:SHB+15 of vsrc are placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Double by Bit Immediate",
        "form": "VN",
        "mnemonic": "vsrdbi",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "SH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "2"
          },
          {
            "name": "SH",
            "size": "3"
          },
          {
            "name": "22",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let vsrc be the contents of VSR[VRA+32]",
      "concatenated with the contents of VSR[VRB+32].",
      "",
      "The contents of bits 128-SH:255-SH of vsrc",
      "are placed into VSR[VRT+32].",
      "",
      "SH can be any integer value between 0 and 7.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left",
        "form": "VX",
        "mnemonic": "vsl",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "452",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are shifted left by the",
      "number of bits specified in bits 125:127 of VSR[VRB+32].",
      "",
      "",
      "",
      "The result is place into VSR[VRT+32], except if, for any",
      "byte element in VSR[VRB+32], the low-order 3 bits are not",
      "equal to the shift amount, then VSR[VRT+32] is undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right",
        "form": "VX",
        "mnemonic": "vsr",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "708",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are shifted right by the",
      "number of bits specified in bits 125:127 of VSR[VRB+32].",
      "",
      "",
      "",
      "The result is place into VSR[VRT+32], except if, for any",
      "byte element in VSR[VRB+32], the low-order 3 bits are not",
      "equal to the shift amount, then VSR[VRT+32] is undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left by Octet",
        "form": "VX",
        "mnemonic": "vslo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1036",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are shifted left by the",
      "number of bytes specified in bits 121:124 of VSR[VRB+32].",
      "",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right by Octet",
        "form": "VX",
        "mnemonic": "vsro",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1100",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are shifted right by the",
      "number of bytes specified in bits 121:124 of VSR[VRB+32].",
      "",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Variable",
        "form": "VX",
        "mnemonic": "vslv",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1860",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let bytes 0:15 of vsrc be the contents of VSR[VRA+32].",
      "",
      "Let byte 16 of vsrc be the value 0x00.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let sh be the value in bits 5:7 of byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The contents of bits sh:sh+7 of the halfword in byte",
      "elements i:i+1 of vsrc are placed into byte",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Variable",
        "form": "VX",
        "mnemonic": "vsrv",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1796",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let bytes 1:16 of vsrc be the contents of VSR[VRA+32].",
      "",
      "Let byte 0 of vsrc be the value 0x00.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let sh be the value in bits 5:7 of byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The contents of bits 8-sh:15-sh of the halfword in byte",
      "elements i:i+1 of vsrc are placed into byte",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Byte to VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vextractub",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "525",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of byte element UIM of VSR[VRB+32] are placed into bits 56:63 of VSR[VRT+32].",
      "The contents of the remaining byte elements of VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Halfword to VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vextractuh",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "589",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of byte elements UIM:UIM+1 of VSR[VRB+32] are placed into halfword element 3 of VSR[VRT+32].",
      "The contents of the remaining halfword elements of VSR[VRT+32] are set to 0.",
      "",
      "If the value of UIM is greater than 14, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Word to VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vextractuw",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "653",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of byte elements UIM:UIM+3 of VSR[VRB+32] are placed into word element 1 of VSR[VRT+32].",
      "The contents of the remaining word elements of VSR[VRT+32] are set to 0.",
      "",
      "If the value of UIM is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Doubleword to VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vextractd",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "717",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of byte elements UIM:UIM+7 of VSR[VRB+32]  are placed into VSR[VRT+32].",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "If the value of UIM is greater than 8, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Byte to GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vextublx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1549",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte element index of VSR[VRB+32] are placed into bits 56:63 of GPR[RT].",
      "",
      "The contents of bits 0:55 of GPR[RT] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Byte to GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vextubrx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1805",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte element 15-index of VSR[VRB+32] are placed into bits 56:63 of GPR[RT].",
      "",
      "The contents of bits 0:55 of GPR[RT] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Halfword to GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vextuhlx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1613",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte elements index:index+1 of VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
      "",
      "The contents of bits 0:47 of GPR[RT] are set to 0.",
      "",
      "If the value of index is greater than 14, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Halfword to GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vextuhrx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1869",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte elements 14-index:15-index of",
      "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
      "",
      "The contents of bits 0:47 of GPR[RT] are set to 0.",
      "",
      "If the value of index is greater than 14, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Word to GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vextuwlx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1677",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte elements index:index+3 of VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
      "",
      "The contents of bits 0:31 of GPR[RT] are set to 0.",
      "",
      "If the value of index is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Unsigned Word to GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vextuwrx",
        "operands": [
          "RT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1933",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of byte elements index:index+3 of VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
      "",
      "The contents of bits 0:31 of GPR[RT] are set to 0.",
      "",
      "If the value of index is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Byte to VSR using GPR-specified Left-Index",
        "form": "VA",
        "mnemonic": "vextdubvlx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "24",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte element index of vsrc",
      "are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Byte to VSR using GPR-specified Right-Index",
        "form": "VA",
        "mnemonic": "vextdubvrx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "25",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte element 31-index of vsrc",
      "are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Halfword to VSR using GPR-specified Left-Index",
        "form": "VA",
        "mnemonic": "vextduhvlx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "26",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements index:index+1 of vsrc are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 30, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Halfword to VSR using GPR-specified Right-Index",
        "form": "VA",
        "mnemonic": "vextduhvrx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "27",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements 30-index:31-index of",
      "vsrc are zero-extended and placed into doubleword 0 of",
      "VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 30, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Word to VSR using GPR-specified Left-Index",
        "form": "VA",
        "mnemonic": "vextduwvlx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "28",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let src be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements index:index+3 of src are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 28, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Unsigned Word to VSR using GPR-specified Right-Index",
        "form": "VA",
        "mnemonic": "vextduwvrx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "29",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let src be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements 28-index:31-index of",
      "src are zero-extended and placed into doubleword 0 of",
      "VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 28, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Doubleword to VSR using GPR-specified Left-Index",
        "form": "VA",
        "mnemonic": "vextddvlx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "30",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let src be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements index:index+7 of src are placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 24, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Double Doubleword to VSR using GPR-specified Right-Index",
        "form": "VA",
        "mnemonic": "vextddvrx",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "RC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RC",
            "size": "5"
          },
          {
            "name": "31",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 59:63 of GPR[RC].",
      "",
      "Let src be the concatenation of the contents of",
      "VSR[VRA+32] and VSR[VRB+32].",
      "",
      "The contents of byte elements 24-index:31-index of src are placed into doubleword 0 of",
      "VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "If index is greater than 24, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Byte from VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinsertb",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "781",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of byte element 7 of VSR[VRB+32]",
      "are placed into byte element UIM of VSR[VRT+32].",
      "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Halfword from VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinserth",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "845",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of halfword element 3 of VSR[VRB+32] are placed into byte elements UIM:UIM+1 of",
      "VSR[VRT+32].",
      "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
      "",
      "If the value of UIM is greater than 14, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinsertw",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "909",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 1 of VSR[VRB+32]",
      "are placed into byte elements UIM:UIM+3 of VSR[VRT+32].",
      "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
      "",
      "If the value of UIM is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Doubleword from VSR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinsertd",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "973",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of doubleword element 0 of VSR[VRB+32] are placed into byte elements UIM:UIM+7 of",
      "VSR[VRT+32].",
      "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
      "",
      "If the value of UIM is greater than 8, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Byte from GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinsblx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "527",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 56:63 of GPR[RB] are placed into",
      "byte element index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Byte from GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinsbrx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "783",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 56:63 of GPR[RB] are placed into",
      "byte element 15-index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Halfword from GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinshlx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "591",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 48:63 of GPR[RB] are placed into",
      "byte elements index:index+1 of VSR[VRT+32].",
      "",
      "If index is greater than 14, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Halfword from GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinshrx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "847",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 48:63 of GPR[RB] are placed into",
      "byte elements 14-index:15-index of VSR[VRT+32].",
      "",
      "If index is greater than 14, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinswlx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "655",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 32:63 of GPR[RB] are placed into",
      "byte elements index:index+3 of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 12, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinswrx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "911",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 32:63 of GPR[RB] are placed into",
      "byte elements 12-index:15-index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 12, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Doubleword from GPR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinsdlx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "719",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of GPR[RB] are placed into byte elements",
      "index:index+7 of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 8, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Doubleword from GPR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinsdrx",
        "operands": [
          "VRT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "975",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of GPR[RB] are placed into byte elements",
      "8-index:15-index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 8, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from GPR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinsw",
        "operands": [
          "VRT",
          "RB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "207",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bits 32:63 of GPR[RB] are placed into",
      "byte elements UIM:UIM+3 of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If UIM is greater than 12, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Doubleword from GPR using immediate-specified index",
        "form": "VX",
        "mnemonic": "vinsd",
        "operands": [
          "VRT",
          "RB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "463",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of GPR[RB] are placed into byte elements",
      "UIM:UIM+7 of",
      "VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If UIM is greater than 8, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Byte from VSR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinsbvlx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "15",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 56:63 of VSR[VRB+32] are placed into",
      "byte element index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Byte from VSR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinsbvrx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "271",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 56:63 of VSR[VRB+32] are placed into",
      "byte element 15-index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Halfword from VSR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinshvlx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "79",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 48:63 of VSR[VRB+32] are placed into",
      "byte elements index:index+1 of VSR[VRT+32].",
      "",
      "If index is greater than 14, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Halfword from VSR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinshvrx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "335",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 48:63 of VSR[VRB+32] are placed into",
      "byte elements 14-index:15-index of VSR[VRT+32].",
      "",
      "If index is greater than 14, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from VSR using GPR-specified Left-Index",
        "form": "VX",
        "mnemonic": "vinswvlx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "143",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 32:63 of VSR[VRB+32] are placed into",
      "byte elements index:index+3 of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 12, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Insert Word from VSR using GPR-specified Right-Index",
        "form": "VX",
        "mnemonic": "vinswvrx",
        "operands": [
          "VRT",
          "RA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "399",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let index be the contents of bits 60:63 of GPR[RA].",
      "",
      "The contents of bits 32:63 of VSR[VRB+32] are placed into",
      "byte elements 12-index:15-index of VSR[VRT+32].",
      "",
      "All other byte elements of VSR[VRT+32] are not modified.",
      "",
      "If index is greater than 12, the result is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add  write Carry-out Unsigned Word",
        "form": "VX",
        "mnemonic": "vaddcuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "384",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i in",
      "VSR[VRA+32] is added to the unsigned integer value in",
      "word element i in VSR[VRB+32].",
      "The carry out of the 32-bit sum is zero-extended to 32 bits and",
      "placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Signed Byte Saturate",
        "form": "VX",
        "mnemonic": "vaddsbs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "768",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i of VSR[VRA+32] is added to the signed integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Signed Halfword Saturate",
        "form": "VX",
        "mnemonic": "vaddshs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "832",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "VSR[VRA+32] is added to the signed integer value in",
      "halfword element i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Signed Word Saturate",
        "form": "VX",
        "mnemonic": "vaddsws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "896",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i of VSR[VRA+32] is added to the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Byte Modulo",
        "form": "VX",
        "mnemonic": "vaddubm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "0",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The integer value in byte element i of VSR[VRA+32] is added to the integer value in byte element i of VSR[VRB+32].",
      "",
      "",
      "The low-order 8 bits of the result are placed into byte element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Halfword Modulo",
        "form": "VX",
        "mnemonic": "vadduhm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "64",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The integer value in halfword element i of VSR[VRA+32] is added to the integer value in halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Word Modulo",
        "form": "VX",
        "mnemonic": "vadduwm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "128",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The integer value in word element i of VSR[VRA+32] is added to the integer value in word element i of VSR[VRB+32].",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Doubleword Modulo",
        "form": "VX",
        "mnemonic": "vaddudm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "192",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The integer value in doubleword element i of VSR[VRB+32] is added to the integer value in doubleword element",
      "i of VSR[VRA+32].",
      "",
      "",
      "The low-order 64 bits of the result are placed into doubleword el",
      "ement i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Byte Saturate",
        "form": "VX",
        "mnemonic": "vaddubs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "512",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element i of",
      "VSR[VRA+32] is added to the unsigned integer value in",
      "byte element i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Halfword Saturate",
        "form": "VX",
        "mnemonic": "vadduhs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "576",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i of",
      "VSR[VRA+32] is added to the unsigned integer value in",
      "halfword element i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Word Saturate",
        "form": "VX",
        "mnemonic": "vadduws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "640",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i of",
      "VSR[VRA+32] is added to the unsigned integer value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Unsigned Quadword Modulo",
        "form": "VX",
        "mnemonic": "vadduqm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "256",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The rightmost 128 bits of the sum of src1 and",
      "src2 are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Extended Unsigned Quadword Modulo",
        "form": "VA",
        "mnemonic": "vaddeuqm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "60",
            "size": "6"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "Let cin be the integer value in bit 127 of",
      "VSR[VRC+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The rightmost 128 bits of the sum of src1,",
      "src2, and cin  are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add  write Carry-out Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vaddcuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "320",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The carry out of the sum of src1 and src2 is",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Extended  write Carry-out Unsigned Quadword",
        "form": "VA",
        "mnemonic": "vaddecuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "61",
            "size": "6"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "Let cin be the integer value in bit 127 of",
      "VSR[VRC+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The carry out of the sum of src1, src2, and",
      "cin  are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract  Write Carry-out Unsigned Word",
        "form": "VX",
        "mnemonic": "vsubcuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1408",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i of",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in word element i in VSR[VRA+32].",
      "The complement of the borrow out of bit 0 of the 32-bit difference is",
      "zero-extended to 32 bits and placed into word element i",
      "of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Signed Byte Saturate",
        "form": "VX",
        "mnemonic": "vsubsbs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1792",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i in VSR[VRB+32] is subtracted from the signed integer value in byte",
      "element i in VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Signed Halfword Saturate",
        "form": "VX",
        "mnemonic": "vsubshs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1856",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i in",
      "VSR[VRB+32] is subtracted from the signed integer value",
      "in halfword element i in VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Signed Word Saturate",
        "form": "VX",
        "mnemonic": "vsubsws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1920",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i in VSR[VRB+32] is subtracted from the signed integer value in word",
      "element i in VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Byte Modulo",
        "form": "VX",
        "mnemonic": "vsububm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1024",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element i in",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in byte element i in VSR[VRA+32].",
      "",
      "",
      "The low-order 8 bits of the result are placed into byte element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Halfword Modulo",
        "form": "VX",
        "mnemonic": "vsubuhm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1088",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i in",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in halfword element i in VSR[VRA+32].",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Word Modulo",
        "form": "VX",
        "mnemonic": "vsubuwm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1152",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i in",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in word element i in VSR[VRA+32].",
      "",
      "",
      "The low-order 16 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Doubleword Modulo",
        "form": "VX",
        "mnemonic": "vsubudm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1216",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The integer value in doubleword element i in VSR[VRB+32] is subtracted from the integer value in doubleword",
      "element i in VSR[VRA+32].",
      "",
      "",
      "The low-order 64 bits of the result are placed into doubleword",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Byte Saturate",
        "form": "VX",
        "mnemonic": "vsububs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1536",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element i of",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in byte element i of VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Halfword Saturate",
        "form": "VX",
        "mnemonic": "vsubuhs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1600",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i of",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in halfword element i of VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Word Saturate",
        "form": "VX",
        "mnemonic": "vsubuws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1664",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i of",
      "VSR[VRB+32] is subtracted from the unsigned integer value",
      "in word element i of VSR[VRA+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Unsigned Quadword Modulo",
        "form": "VX",
        "mnemonic": "vsubuqm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1280",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The rightmost 128 bits of the sum of src1,",
      "the ones complement of src2, and the value 1",
      "are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Extended Unsigned Quadword Modulo",
        "form": "VA",
        "mnemonic": "vsubeuqm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "62",
            "size": "6"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "Let cin be the integer value in bit 127 of",
      "VSR[VRC+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The rightmost 128 bits of the sum of src1,",
      "the ones complement of src2, and cin are",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract  write Carry-out Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vsubcuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1344",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The carry out of the sum of src1, the ones complement of",
      "src2, and the value 1 is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Extended  write Carry-out Unsigned Quadword",
        "form": "VA",
        "mnemonic": "vsubecuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "63",
            "size": "6"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the integer value in VSR[VRA+32].",
      "",
      "Let src2 be the integer value in VSR[VRB+32].",
      "",
      "Let cin be the integer value in bit 127 of",
      "VSR[VRC+32].",
      "",
      "src1 and src2 can be signed or unsigned",
      "integers.",
      "",
      "The carry out of the sum of src1, the ones complement of",
      "src2, and cin are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Signed Byte",
        "form": "VX",
        "mnemonic": "vmulesb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "776",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i2 of",
      "VSR[VRA+32] is multiplied by the signed integer value in",
      "byte element i2 of VSR[VRB+32].",
      "",
      "",
      "The 16-bit product is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Signed Byte",
        "form": "VX",
        "mnemonic": "vmulosb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "264",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element i2+1",
      "of VSR[VRA+32] is multiplied by the signed integer value",
      "in byte element i2+1 of VSR[VRB+32].",
      "",
      "",
      "The 16-bit product is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Unsigned Byte",
        "form": "VX",
        "mnemonic": "vmuleub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "520",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element i2",
      "of VSR[VRA+32] is multiplied by the unsigned integer",
      "value in byte element i2 of VSR[VRB+32].",
      "",
      "",
      "The 16-bit product is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Unsigned Byte",
        "form": "VX",
        "mnemonic": "vmuloub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "8",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element i2+1",
      "of VSR[VRA+32] is multiplied by the unsigned integer",
      "value in byte element i2+1 of VSR[VRB+32].",
      "",
      "",
      "The 16-bit product is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Signed Halfword",
        "form": "VX",
        "mnemonic": "vmulesh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "840",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i2",
      "of VSR[VRA+32] is multiplied by the signed integer value",
      "in halfword element i2 of VSR[VRB+32].",
      "",
      "",
      "The 32-bit product is placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Signed Halfword",
        "form": "VX",
        "mnemonic": "vmulosh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "328",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i2+1 of VSR[VRA+32] is multiplied by the",
      "signed integer value in halfword element i2+1",
      "of VSR[VRB+32].",
      "",
      "",
      "The 32-bit product is placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vmuleuh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "584",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i2 of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in halfword element i2",
      "of VSR[VRB+32].",
      "",
      "",
      "The 32-bit product is placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vmulouh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "72",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i2+1 of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in halfword element  i2+1 of VSR[VRB+32].",
      "",
      "",
      "The 32-bit product is placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Signed Word",
        "form": "VX",
        "mnemonic": "vmulesw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "904",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer in word element 2i of VSR[VRA+32] is multiplied by the signed integer in",
      "word element 2i of VSR[VRB+32].",
      "",
      "",
      "The 64-bit product is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Signed Word",
        "form": "VX",
        "mnemonic": "vmulosw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "392",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer in word element 2i+1 of VSR[VRA+32] is multiplied by the signed integer",
      "in word element 2i+1 of VSR[VRB+32].",
      "",
      "",
      "The 64-bit product is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Unsigned Word",
        "form": "VX",
        "mnemonic": "vmuleuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "648",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The unsigned integer in word element 2i of VSR[VRA+32] is multiplied by",
      "the unsigned integer in word element 2i of VSR[VRB+32].",
      "",
      "",
      "The 64-bit product is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Unsigned Word",
        "form": "VX",
        "mnemonic": "vmulouw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "136",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The unsigned integer in word element 2i+1 of VSR[VRA+32] is multiplied",
      "by the unsigned integer in word element 2i+1 of VSR[VRB+32].",
      "",
      "",
      "The 64-bit product is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vmuleud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "712",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element 0 of VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element 0 of VSR[VRB+32].",
      "",
      "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vmuloud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "200",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element 1 of VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element 1 of VSR[VRB+32].",
      "",
      "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Even Signed Doubleword",
        "form": "VX",
        "mnemonic": "vmulesd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "968",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in doubleword",
      "element 0 of VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in doubleword",
      "element 0 of VSR[VRB+32].",
      "",
      "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Odd Signed Doubleword",
        "form": "VX",
        "mnemonic": "vmulosd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "456",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in doubleword",
      "element 1 of VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in doubleword",
      "element 1 of VSR[VRB+32].",
      "",
      "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Unsigned Word Modulo",
        "form": "VX",
        "mnemonic": "vmuluwm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "137",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The integer in word element i of VSR[VRA+32]",
      "is multiplied by the integer in word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "The low-order 32 bits of the product are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply High Signed Word",
        "form": "VX",
        "mnemonic": "vmulhsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "905",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in word element i of VSR[VRA+32] is multiplied by the signed integer value in word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "The high-order 32 bits of the 64-bit product are placed into word",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply High Unsigned Word",
        "form": "VX",
        "mnemonic": "vmulhuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "649",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in word element i of",
      "VSR[VRA+32] is multiplied by the unsigned integer value",
      "in word element i of VSR[VRB+32].",
      "",
      "",
      "The high-order 32 bits of the 64-bit product are placed into word",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply High Signed Doubleword",
        "form": "VX",
        "mnemonic": "vmulhsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "969",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer value in doubleword element i of",
      "VSR[VRA+32] is multiplied by the signed integer value in",
      "doubleword element i of VSR[VRB+32].",
      "",
      "",
      "The high-order 64 bits of the 128-bit product are placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply High Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vmulhud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "713",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in doubleword element i of",
      "VSR[VRA+32] is multiplied by the unsigned integer value",
      "in doubleword element i of VSR[VRB+32].",
      "",
      "",
      "The high-order 64 bits of the 128-bit product are placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply Low Doubleword",
        "form": "VX",
        "mnemonic": "vmulld",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "457",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The integer value in doubleword element i of VSR[VRA+32] is mutiplied by the integer value in doubleword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The low-order 64 bits of the product are placed into doubleword",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-High-Add Signed Halfword Saturate",
        "form": "VA",
        "mnemonic": "vmhaddshs",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "32",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "VSR[VRA+32] is multiplied by the signed integer value in",
      "halfword element i of VSR[VRB+32], producing",
      "a 32-bit signed integer product.",
      "",
      "",
      "Bits 0:16 of the product are added to the signed integer value in",
      "halfword element i of VSR[VRC+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-High-Round-Add Signed Halfword Saturate",
        "form": "VA",
        "mnemonic": "vmhraddshs",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "33",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element i of",
      "VSR[VRA+32] is multiplied by the signed integer value in",
      "halfword element i of VSR[VRB+32], producing",
      "a 32-bit signed integer product.",
      "",
      "",
      "The value 0x0000_4000 is added to the product.",
      "",
      "",
      "Bits 0:16 of the 32-bit sum are added to the signed integer value in",
      "halfword element i of VSR[VRC+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Low-Add Unsigned Halfword Modulo",
        "form": "VA",
        "mnemonic": "vmladduhm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "34",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element i of",
      "VSR[VRA+32] is multiplied by the unsigned integer value",
      "in halfword element i in VSR[VRB+32].",
      "",
      "",
      "The product is added to the unsigned integer value in halfword",
      "element i of VSR[VRC+32].",
      "",
      "",
      "The low-order 16 bits of the sum of the product and the unsigned",
      "integer value in word element i of VSR[VRC+32] are placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Unsigned Byte Modulo",
        "form": "VA",
        "mnemonic": "vmsumubm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "36",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in byte element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in byte element j of word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the four products is added to the unsigned integer value",
      "in word element i of VSR[VRC+32].",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Mixed Byte Modulo",
        "form": "VA",
        "mnemonic": "vmsummbm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "37",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer value in byte element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in byte element j of word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the four products is added to the signed integer value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Signed Halfword Modulo",
        "form": "VA",
        "mnemonic": "vmsumshm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "40",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "signed integer value in halfword element j of word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the two products is added to the signed integer value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Signed Halfword Saturate",
        "form": "VA",
        "mnemonic": "vmsumshs",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "41",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer value in halfword element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "signed integer value in halfword element j of word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the two products is added to the signed integer value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Unsigned Halfword Modulo",
        "form": "VA",
        "mnemonic": "vmsumuhm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "38",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 1, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in halfword element j of word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the two products is added to the signed integer value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Unsigned Halfword Saturate",
        "form": "VA",
        "mnemonic": "vmsumuhs",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "39",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For each integer value j from 0 to 1, do the following.",
      "",
      "",
      "",
      "The unsigned integer value in halfword element j of word",
      "element i of VSR[VRA+32] is multiplied by the",
      "unsigned integer value in halfword element j of word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "",
      "The sum of the two products is added to the signed integer value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum Unsigned Doubleword Modulo",
        "form": "VA",
        "mnemonic": "vmsumudm",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "35",
            "size": "6"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "",
      "Let prod0 be the product of the unsigned integer values",
      "in doubleword element 0 of VSR[VRA+32] and doubleword",
      "element 0 of VSR[VRB+32].",
      "",
      "Let prod1 be the product of the unsigned integer values",
      "in doubleword element 1 of VSR[VRA+32] and doubleword",
      "element 1 of VSR[VRB+32].",
      "",
      "The low-order 128 bits of the sum of prod0, prod1, and the unsigned integer value in VSR[VRC+32] are",
      "placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Sum  write Carry-out Unsigned Doubleword",
        "form": "VA",
        "mnemonic": "vmsumcud",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "23",
            "size": "6"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let prod0 be the quadword product of the unsigned integer",
      "values in doubleword element 0 of VSR[VRA+32] and",
      "doubleword element 0 of VSR[VRB+32].",
      "",
      "Let prod1 be the quadword product of the unsigned integer",
      "values in doubleword element 1 of VSR[VRA+32] and",
      "doubleword element 1 of VSR[VRB+32].",
      "",
      "The carry out of the low-order 128 bits of the sum of prod0, prod1, and the unsigned integer value in",
      "VSR[VRC+32] is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Signed Word",
        "form": "VX",
        "mnemonic": "vdivsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "395",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "The signed integer in word element i of VSR[VRA+32] is divided by the signed integer in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor| if the dividend is",
      "nonnegative, and -|divisor|  r = 0 if the",
      "dividend is negative.",
      "",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "0x80000000  -1",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the quotient is undefined.",
      "",
      "",
      "The quotient is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Unsigned Word",
        "form": "VX",
        "mnemonic": "vdivuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "139",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "The unsigned integer in word element i of VSR[VRA+32] is divided by the unsigned integer in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor|.",
      "",
      "",
      "If an attempt is made to perform the division",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the quotient is undefined.",
      "",
      "",
      "The quotient is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Signed Word",
        "form": "VX",
        "mnemonic": "vdivesw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "907",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let dividend be the signed integer value in word element",
      "i of VSR[VRA+32], shifted left by 32 bits.",
      "",
      "",
      "Let divisor be the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "dividend is divided by divisor.",
      "",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor| if the dividend is",
      "nonnegative, and -|divisor|  r = 0 if the",
      "dividend is negative.",
      "",
      "",
      "If the quotient cannot be represented in 32 bits, or if an attempt is",
      "made to perform the division,",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "the quotient is undefined.",
      "",
      "",
      "The quotient is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Unsigned Word",
        "form": "VX",
        "mnemonic": "vdiveuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "651",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let dividend be the unsigned integer value in word",
      "element i of VSR[VRA+32], shifted left by 32",
      "bits.",
      "",
      "",
      "Let divisor be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor|.",
      "",
      "",
      "If the quotient cannot be represented in 32 bits, or if an attempt is",
      "made to perform the division,",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "the quotient is undefined.",
      "",
      "",
      "The quotient is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Signed Doubleword",
        "form": "VX",
        "mnemonic": "vdivsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "459",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the",
      "following.",
      "",
      "",
      "",
      "The signed integer in doubleword element i of VSR[VRA+32] is divided by the signed integer in doubleword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = remainder  |divisor| if the dividend",
      "is nonnegative, and -|divisor|  remainder = 0",
      "if the dividend is negative.",
      "",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "0x8000000000000000  -1",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the quotient is undefined.",
      "",
      "",
      "The quotient is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vdivud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "203",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the",
      "following.",
      "",
      "",
      "",
      "The unsigned integer in doubleword element i of",
      "VSR[VRA+32] is divided by the unsigned integer in",
      "doubleword element i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = remainder  divisor.",
      "",
      "",
      "If an attempt is made to perform the division",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the quotient is undefined.",
      "",
      "",
      "The quotient is placed into doubleword element i of",
      "VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Signed Doubleword",
        "form": "VX",
        "mnemonic": "vdivesd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "971",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let dividend be the signed integer value in doubleword",
      "element i of VSR[VRA+32], shifted left by 64",
      "bits.",
      "",
      "",
      "Let divisor be the signed integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "dividend is divided by divisor.",
      "",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor| if the dividend is",
      "nonnegative, and -|divisor|  r = 0 if the",
      "dividend is negative.",
      "",
      "",
      "If the quotient cannot be represented in 64 bits, or if an attempt is",
      "made to perform the division, anything ",
      "0, the quotient is undefined.",
      "",
      "",
      "The quotient is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vdiveud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "715",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let dividend be the unsigned integer value in doubleword",
      "element i of VSR[VRA+32], shifted left by 64",
      "bits.",
      "",
      "",
      "Let divisor be the unsigned integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + remainder",
      "",
      "",
      "",
      "where 0 = r  |divisor|.",
      "",
      "",
      "If the quotient cannot be represented in 64 bits, or if an attempt is",
      "made to perform the division,",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "the quotient is undefined.",
      "",
      "",
      "The quotient is placed into doubleword element i of",
      "VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Signed Quadword",
        "form": "VX",
        "mnemonic": "vdivsq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "267",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "The quotient of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "",
      "where 0r|divisor| if the",
      "dividend is nonnegative, and -|divisor|r0 if the dividend is negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "",
      "",
      "0x8000000000000000  -1",
      "",
      "",
      "anything  0",
      "",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vdivuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "11",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in VSR[VRB+32].",
      "",
      "The quotient of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "",
      "where 0rdivisor.",
      "",
      "If an attempt is made to perform the division",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Signed Quadword",
        "form": "VX",
        "mnemonic": "vdivesq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "779",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32] concatenated with 128 0s.",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "The quotient of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The quotient is the unique signed integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "",
      "where 0  r  |divisor| if",
      "dividend is nonnegative, and -|divisor|  r  0 if dividend is negative.",
      "",
      "If the quotient cannot be represented in 128 bits, or if an attempt",
      "is made to perform the division",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Divide Extended Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vdiveuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "523",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in VSR[VRA+32] concatenated with 128 0s.",
      "",
      "Let src2 be the unsigned integer value in VSR[VRB+32].",
      "",
      "The quotient of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The quotient is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "dividend = (quotient  divisor) + r",
      "",
      "",
      "where 0  r  divisor.",
      "",
      "If the quotient cannot be represented in 128 bits, or if an attempt",
      "is made to perform the division",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Signed Word",
        "form": "VX",
        "mnemonic": "vmodsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1931",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "The signed integer in word element i of VSR[VRA+32] is divided by the signed integer in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "quotient  = dividend  divisor",
      "",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "",
      "",
      "where 0 = remainder  |divisor| if the dividend",
      "is nonnegative, and -|divisor|  remainder = 0",
      "if the dividend is negative.",
      "",
      "",
      "If an attempt is made to perform any of the modulo operations",
      "",
      "",
      "",
      "0x80000000  -1",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the remainder is undefined.",
      "",
      "",
      "The remainder is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Unsigned Word",
        "form": "VX",
        "mnemonic": "vmoduw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1675",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "The unsigned integer in word element i of VSR[VRA+32] is divided by the unsigned integer in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The remainder is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "quotient  = dividend  divisor",
      "",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "",
      "",
      "where 0 = remainder  divisor.",
      "",
      "",
      "If an attempt is made to perform the modulo operation",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "then the remainder is undefined.",
      "",
      "",
      "The remainder is placed into word element i of VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Signed Doubleword",
        "form": "VX",
        "mnemonic": "vmodsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1995",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the",
      "following.",
      "",
      "",
      "",
      "The signed integer in doubleword element i of VSR[VRA+32] is divided by the signed integer in doubleword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The remainder is the unique signed integer that satisfies",
      "",
      "",
      "",
      "quotient  = dividend  divisor",
      "",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "",
      "",
      "where 0 = remainder  |divisor| if the dividend",
      "is nonnegative, and -|divisor|  remainder = 0",
      "if the dividend is negative.",
      "",
      "",
      "If an attempt is made to perform any of the modulo operations",
      "",
      "",
      "",
      "0x80000000  -1",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "the remainder is undefined.",
      "",
      "",
      "The remainder is placed into doubleword element i of",
      "VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vmodud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1739",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the",
      "following.",
      "",
      "",
      "",
      "The unsigned integer in doubleword element i of",
      "VSR[VRA+32] is divided by the unsigned integer in",
      "doubleword element i of VSR[VRB+32].",
      "",
      "",
      "The remainder is the unique unsigned integer that satisfies",
      "",
      "",
      "",
      "quotient  = dividend  divisor",
      "",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "",
      "",
      "where 0 = remainder  divisor.",
      "",
      "",
      "If an attempt is made to perform the modulo operation",
      "",
      "",
      "",
      "anything  0",
      "",
      "",
      "",
      "the remainder is undefined.",
      "",
      "",
      "The remainder is placed into doubleword element i of",
      "VSR[VRT+32]",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Signed Quadword",
        "form": "VX",
        "mnemonic": "vmodsq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1803",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "The remainder of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The remainder is the unique signed integer that satisfies",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "where 0remainder|divisor| if",
      "the dividend is nonnegative, and -|divisor|remainder0 if the dividend is",
      "negative.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "anything  0",
      "",
      "0x8000000000000000  -1",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Modulo Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vmoduq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1547",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "The remainder of src1 divided by src2 is",
      "placed into VSR[VRT+32].",
      "",
      "The remainder is the unique signed integer that satisfies",
      "",
      "remainder = dividend - (quotient  divisor)",
      "",
      "where 0  remainder  divisor.",
      "",
      "If an attempt is made to perform any of the divisions",
      "",
      "anything  0",
      "",
      "then the contents of VSR[VRT+32] are undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Sum across Signed Word Saturate",
        "form": "VX",
        "mnemonic": "vsumsws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1928",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The sum of the signed integer values in the four word elements of",
      "VSR[VRA+32] is added to the signed integer value in the",
      "word element 3 of VSR[VRB+32].",
      "",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element 3 of",
      "VSR[VRT+32].",
      "",
      "Word elements 0 to 2 of VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Sum across Half Signed Word Saturate",
        "form": "VX",
        "mnemonic": "vsum2sws",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1672",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "Word elements 0 and 2 of VSR[VRT+32] are set to 0.",
      "",
      "The sum of the signed integer values in word elements 0 and 1 in",
      "VSR[VRA+32] is added to the signed integer value in word",
      "element 1 of VSR[VRB+32].",
      "",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element 1 of",
      "VSR[VRT+32].",
      "",
      "The sum of the signed integer values in word elements 2 and 3 in",
      "VSR[VRA+32] is added to the signed integer value in word",
      "element 3 of VSR[VRB+32].",
      "",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element 3 of",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Sum across Quarter Signed Byte Saturate",
        "form": "VX",
        "mnemonic": "vsum4sbs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1800",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The sum of the signed integer values in the four byte elements",
      "contained in word element i of VSR[VRA+32] is",
      "added to the signed integer value in word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Sum across Quarter Signed Halfword Saturate",
        "form": "VX",
        "mnemonic": "vsum4shs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1608",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The sum of the signed integer values in the two halfword elements",
      "contained in word element i of VSR[VRA+32] is",
      "added to the signed integer value in word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into the corresponding word element of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Sum across Quarter Unsigned Byte Saturate",
        "form": "VX",
        "mnemonic": "vsum4ubs",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1544",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The sum of the unsigned integer values in the four byte elements",
      "contained in word element i of VSR[VRA+32] is",
      "added to the unsigned integer value in word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Negate Word",
        "form": "VX",
        "mnemonic": "vnegw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "6",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "The sum of the ones-complement of the signed integer in word element",
      "i of VSR[VRB+32] and 1 is placed into word",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Negate Doubleword",
        "form": "VX",
        "mnemonic": "vnegd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "7",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the",
      "following.",
      "",
      "",
      "",
      "The sum of the ones-complement of the signed integer in doubleword",
      "element i of VSR[VRB+32] and 1 is placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Byte To Word",
        "form": "VX",
        "mnemonic": "vextsb2w",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "16",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer in bits 24:31 of word element i of",
      "VSR[VRB+32] is sign-extended and placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Halfword To Word",
        "form": "VX",
        "mnemonic": "vextsh2w",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "17",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The signed integer in bits 16:31 of word element i of",
      "VSR[VRB+32] is sign-extended and placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Byte To Doubleword",
        "form": "VX",
        "mnemonic": "vextsb2d",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer in bits 56:63 of doubleword element i",
      "of VSR[VRB+32] is sign-extended and placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Halfword To Doubleword",
        "form": "VX",
        "mnemonic": "vextsh2d",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer in bits 48:63 of doubleword element i",
      "of VSR[VRB+32] is sign-extended and placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Word To Doubleword",
        "form": "VX",
        "mnemonic": "vextsw2d",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "26",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The signed integer in bits 32:63 of doubleword element i",
      "of VSR[VRB+32] is sign-extended and placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extend Sign Doubleword to Quadword",
        "form": "VX",
        "mnemonic": "vextsd2q",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "27",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The signed integer in bits 64:127 of VSR[VRB+32] is",
      "signed extended to 128 bits and placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Signed Byte",
        "form": "VX",
        "mnemonic": "vavgsb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1282",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 8 bits of the result are placed into byte element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Unsigned Byte",
        "form": "VX",
        "mnemonic": "vavgub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1026",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 8 bits of the result are placed into byte element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Signed Halfword",
        "form": "VX",
        "mnemonic": "vavgsh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1346",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in halfword element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vavguh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1090",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 16 bits of the result are placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Signed Word",
        "form": "VX",
        "mnemonic": "vavgsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1410",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Average Unsigned Word",
        "form": "VX",
        "mnemonic": "vavguw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1154",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The sum is incremented by 1 and then shifted right 1 bit.",
      "",
      "",
      "The low-order 32 bits of the result are placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Absolute Difference Unsigned Byte",
        "form": "VX",
        "mnemonic": "vabsdub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1027",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is subtracted by src2.",
      "",
      "",
      "The absolute value of the difference is placed into byte element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Absolute Difference Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vabsduh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1091",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is subtracted by src2.",
      "",
      "",
      "The absolute value of the difference is placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Absolute Difference Unsigned Word",
        "form": "VX",
        "mnemonic": "vabsduw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1155",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is subtracted by src2.",
      "",
      "",
      "The absolute value of the difference is placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Signed Byte",
        "form": "VX",
        "mnemonic": "vmaxsb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "258",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Unsigned Byte",
        "form": "VX",
        "mnemonic": "vmaxub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "2",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Signed Halfword",
        "form": "VX",
        "mnemonic": "vmaxsh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "322",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in halfword element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vmaxuh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "66",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Signed Word",
        "form": "VX",
        "mnemonic": "vmaxsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "386",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Unsigned Word",
        "form": "VX",
        "mnemonic": "vmaxuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "130",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Signed Doubleword",
        "form": "VX",
        "mnemonic": "vmaxsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "450",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vmaxud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "194",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The larger of the two values is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Signed Byte",
        "form": "VX",
        "mnemonic": "vminsb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "770",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Unsigned Byte",
        "form": "VX",
        "mnemonic": "vminub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "514",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Signed Halfword",
        "form": "VX",
        "mnemonic": "vminsh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "834",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in halfword element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Unsigned Halfword",
        "form": "VX",
        "mnemonic": "vminuh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "578",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into halfword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Signed Word",
        "form": "VX",
        "mnemonic": "vminsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "898",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Unsigned Word",
        "form": "VX",
        "mnemonic": "vminuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "642",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Signed Doubleword",
        "form": "VX",
        "mnemonic": "vminsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "962",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Unsigned Doubleword",
        "form": "VX",
        "mnemonic": "vminud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "706",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "The smaller of the two values is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Unsigned Byte",
        "form": "VC",
        "mnemonic": "vcmpequb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "6",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Equal Unsigned Byte",
        "form": "VC",
        "mnemonic": "vcmpequb.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "6",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if src1 is equal to src2,",
      "and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Unsigned Halfword",
        "form": "VC",
        "mnemonic": "vcmpequh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "70",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Equal Unsigned Halfword",
        "form": "VC",
        "mnemonic": "vcmpequh.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "70",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is equal to",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Unsigned Word",
        "form": "VC",
        "mnemonic": "vcmpequw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "134",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Equal Unsigned Word",
        "form": "VC",
        "mnemonic": "vcmpequw.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "134",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is equal to src2,",
      "and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Unsigned Doubleword",
        "form": "VC",
        "mnemonic": "vcmpequd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "199",
            "size": "10"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "Vector Compare Equal Unsigned Doubleword",
        "form": "VC",
        "mnemonic": "vcmpequd.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "199",
            "size": "10"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is equal to",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Quadword",
        "form": "VC",
        "mnemonic": "vcmpequq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "455",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector Compare Equal Quadword",
        "form": "VC",
        "mnemonic": "vcmpequq.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "455",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in VSR[VRB+32].",
      "",
      "If src1 is equal to src2, set VSR[VRT+32] to all 1s.",
      "Otherwise, set VSR[VRT+32] to all 0s.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Signed Byte",
        "form": "VC",
        "mnemonic": "vcmpgtsb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "774",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Signed Byte",
        "form": "VC",
        "mnemonic": "vcmpgtsb.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "774",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if src1 is equal to src2,",
      "and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Unsigned Byte",
        "form": "VC",
        "mnemonic": "vcmpgtub",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "518",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Unsigned Byte",
        "form": "VC",
        "mnemonic": "vcmpgtub.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "518",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in byte element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Signed Halfword",
        "form": "VC",
        "mnemonic": "vcmpgtsh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "838",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Signed Halfword",
        "form": "VC",
        "mnemonic": "vcmpgtsh.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "838",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in halfword element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Unsigned Halfword",
        "form": "VC",
        "mnemonic": "vcmpgtuh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "582",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Unsigned Halfword",
        "form": "VC",
        "mnemonic": "vcmpgtuh.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "582",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in halfword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in halfword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Signed Word",
        "form": "VC",
        "mnemonic": "vcmpgtsw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "902",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Signed Word",
        "form": "VC",
        "mnemonic": "vcmpgtsw.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "902",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Unsigned Word",
        "form": "VC",
        "mnemonic": "vcmpgtuw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "646",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Unsigned Word",
        "form": "VC",
        "mnemonic": "vcmpgtuw.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "646",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Signed Doubleword",
        "form": "VC",
        "mnemonic": "vcmpgtsd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "967",
            "size": "10"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "Vector Compare Greater Than Signed Doubleword",
        "form": "VC",
        "mnemonic": "vcmpgtsd.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "967",
            "size": "10"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the signed integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the signed integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Unsigned Doubleword",
        "form": "VC",
        "mnemonic": "vcmpgtud",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "711",
            "size": "10"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "Vector Compare Greater Than Unsigned Doubleword",
        "form": "VC",
        "mnemonic": "vcmpgtud.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "711",
            "size": "10"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Signed Quadword",
        "form": "VC",
        "mnemonic": "vcmpgtsq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "903",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector Compare Greater Than Signed Quadword",
        "form": "VC",
        "mnemonic": "vcmpgtsq.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "903",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "src1 is compared to src2.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "src1 is greater than src2, and are set to all",
      "0s otherwise.",
      "",
      "If Rc=1, CR field 6 is set to indicate if src1 is greater than src2 or if src1 is not",
      "greater than src2.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Unsigned Quadword",
        "form": "VC",
        "mnemonic": "vcmpgtuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "647",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector Compare Greater Than Unsigned Quadword",
        "form": "VC",
        "mnemonic": "vcmpgtuq.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "647",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in VSR[VRB+32].",
      "",
      "src1 is compared to src2.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "src1 is greater than src2, and are set to all",
      "0s otherwise.",
      "",
      "If Rc=1, CR field 6 is set to indicate if src1 is greater than src2 or if src1 is not",
      "greater than src2.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal Byte",
        "form": "VC",
        "mnemonic": "vcmpneb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "7",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal Byte",
        "form": "VC",
        "mnemonic": "vcmpneb.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "7",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if src1 is not equal to src2, and are set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal or Zero Byte",
        "form": "VC",
        "mnemonic": "vcmpnezb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "263",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal or Zero Byte",
        "form": "VC",
        "mnemonic": "vcmpnezb.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "263",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if src1 is not equal to src2 or either src1 or src2 is equal to",
      "0x00, and are set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal Halfword",
        "form": "VC",
        "mnemonic": "vcmpneh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "71",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal Halfword",
        "form": "VC",
        "mnemonic": "vcmpneh.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "71",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is not equal to",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal or Zero Halfword",
        "form": "VC",
        "mnemonic": "vcmpnezh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "327",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal or Zero Halfword",
        "form": "VC",
        "mnemonic": "vcmpnezh.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "327",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is not equal to",
      "src2 or either src1 or src2 is",
      "equal to 0x00, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal Word",
        "form": "VC",
        "mnemonic": "vcmpnew",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "135",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal Word",
        "form": "VC",
        "mnemonic": "vcmpnew.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "135",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is not equal to src2, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Not Equal or Zero Word",
        "form": "VC",
        "mnemonic": "vcmpnezw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "391",
            "size": "10"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Vector Compare Not Equal or Zero Word",
        "form": "VC",
        "mnemonic": "vcmpnezw.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "391",
            "size": "10"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is not equal to src2 or either src1 or src2 is equal to",
      "0x00, and is set to all 0s otherwise.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Signed Quadword",
        "form": "VX",
        "mnemonic": "vcmpsq",
        "operands": [
          "BF",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "321",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the signed integer value in VSR[VRA+32].",
      "",
      "Let src2 be the signed integer value in VSR[VRB+32].",
      "",
      "Compare src1 with src2, place the comparison",
      "flags into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vcmpuq",
        "operands": [
          "BF",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "257",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let src2 be the unsigned integer value in VSR[VRB+32].",
      "",
      "Compare src1 with src2, place the comparison",
      "flags into CR field BF.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical AND",
        "form": "VX",
        "mnemonic": "vand",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1028",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ANDed with the contents",
      "of VSR[VRB+32] and the result is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical AND with Complement",
        "form": "VX",
        "mnemonic": "vandc",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1092",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ANDed with the complement",
      "of the contents of VSR[VRB+32] and the result is placed",
      "into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical Equivalence",
        "form": "VX",
        "mnemonic": "veqv",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1668",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are XORed with the contents",
      "of VSR[VRB+32] and the complemented result is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical NAND",
        "form": "VX",
        "mnemonic": "vnand",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1412",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ANDed with the contents",
      "of VSR[VRB+32] and the complemented result is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical OR",
        "form": "VX",
        "mnemonic": "vor",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1156",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ORed with the contents of",
      "VSR[VRB+32] and the result is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical OR with Complement",
        "form": "VX",
        "mnemonic": "vorc",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1348",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ORed with the complement",
      "of the contents of VSR[VRB+32] and the result is placed",
      "into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical NOR",
        "form": "VX",
        "mnemonic": "vnor",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1284",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are ORed with the contents of",
      "VSR[VRB+32] and the complemented result is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Logical XOR",
        "form": "VX",
        "mnemonic": "vxor",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1220",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of VSR[VRA+32] are XORed with the contents",
      "of VSR[VRB+32] and the result is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Byte",
        "form": "VX",
        "mnemonic": "vrlb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "4",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is rotated left by the number of bits specified in",
      "the low-order 3 bits of src2.",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Halfword",
        "form": "VX",
        "mnemonic": "vrlh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "68",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is rotated left by the number of bits specified in",
      "the low-order 4 bits of src2.",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Word",
        "form": "VX",
        "mnemonic": "vrlw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "132",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is rotated left by the number of bits specified in",
      "the low-order 5 bits of src2.",
      "",
      "",
      "The result is placed into word element i in VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Doubleword",
        "form": "VX",
        "mnemonic": "vrld",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "196",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is rotated left by the number of bits specified in",
      "the low-order 6 bits of src2.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Quadword",
        "form": "VX",
        "mnemonic": "vrlq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "5",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let SH be the contents of bits 57:63 of VSR[VRB+32].",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "src1 is rotated left by SH bits.",
      "Bits shifted out on the left are shifted in on the right to replace",
      "vacated bits.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Word then AND with Mask",
        "form": "VX",
        "mnemonic": "vrlwnm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "389",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "Let mb be the contents of bits 11:15 of",
      "src2.",
      "",
      "",
      "Let me be the contents of bits 19:23 of",
      "src2.",
      "",
      "",
      "Let sh be the contents of bits 27:31 of",
      "src2.",
      "",
      "",
      "src1 is rotated left sh bits.",
      "",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "",
      "The rotated data are ANDed with the generated mask.",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Doubleword then AND with Mask",
        "form": "VX",
        "mnemonic": "vrldnm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "453",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "Let mb be the contents of bits 42:47 of",
      "src2.",
      "",
      "",
      "Let me be the contents of bits 50:55 of",
      "src2.",
      "",
      "",
      "Let sh be the contents of bits 58:63 of",
      "src2.",
      "",
      "",
      "src1 is rotated left sh bits.",
      "",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "",
      "The rotated data are ANDed with the generated mask.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Quadword then AND with Mask",
        "form": "VX",
        "mnemonic": "vrlqnm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "325",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "Let mb be the contents of bits 41:47 of src2.",
      "",
      "Let me be the contents of bits 49:55 of src2.",
      "",
      "Let sh be the contents of bits 57:63 of src2.",
      "",
      "src1 is rotated left sh bits.",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "The rotated data are ANDed with the generated mask.",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Word then Mask Insert",
        "form": "VX",
        "mnemonic": "vrlwmi",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "133",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "Let src3 be the contents of word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "Let mb be the contents of bits 11:15 of",
      "src2.",
      "",
      "",
      "Let me be the contents of bits 19:23 of",
      "src2.",
      "",
      "",
      "Let sh be the contents of bits 27:31 of",
      "src2.",
      "",
      "",
      "src1 is rotated left sh bits.",
      "",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "",
      "The rotated data are inserted into src3 under control of",
      "the generated mask.",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Doubleword then Mask Insert",
        "form": "VX",
        "mnemonic": "vrldmi",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "197",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "Let src3 be the contents of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "Let mb be the contents of bits 42:47 of",
      "src2.",
      "",
      "",
      "Let me be the contents of bits 50:55 of",
      "src2.",
      "",
      "",
      "Let sh be the contents of bits 58:63 of",
      "src2.",
      "",
      "",
      "src1 is rotated left sh bits.",
      "",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "",
      "The rotated data are inserted into src3 under control of",
      "the generated mask.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Rotate Left Quadword then Mask Insert",
        "form": "VX",
        "mnemonic": "vrlqmi",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "69",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "Let src3 be the contents of VSR[VRT+32].",
      "",
      "Let mb be the contents of bits 41:47 of src2.",
      "",
      "Let me be the contents of bits 49:55 of src2.",
      "",
      "Let sh be the contents of bits 57:63 of src2.",
      "",
      "src1 is rotated left sh bits.",
      "",
      "A mask is generated having 1-bits from bit mb through bit",
      "me and 0-bits elsewhere.",
      "",
      "The rotated data are inserted into src3 under control of",
      "the generated mask.",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Byte",
        "form": "VX",
        "mnemonic": "vslb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "260",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted left by the number of bits specified in",
      "the low-order 3 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Halfword",
        "form": "VX",
        "mnemonic": "vslh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "324",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is shifted left by the number of bits specified in",
      "the low-order 4 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Word",
        "form": "VX",
        "mnemonic": "vslw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "388",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted left by the number of bits specified in",
      "the low-order 5 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Doubleword",
        "form": "VX",
        "mnemonic": "vsld",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1476",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is shifted left by the number of bits specified in",
      "the low-order 6 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Left Quadword",
        "form": "VX",
        "mnemonic": "vslq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "261",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the contents of bits 57:63 of VSR[VRB+32].",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "src1 is shifted left by the number of bits specified in",
      "the low-order 7 bits of src2.",
      "",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Byte",
        "form": "VX",
        "mnemonic": "vsrb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "516",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 3 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Halfword",
        "form": "VX",
        "mnemonic": "vsrh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "580",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 4 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Word",
        "form": "VX",
        "mnemonic": "vsrw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "644",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 5 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Doubleword",
        "form": "VX",
        "mnemonic": "vsrd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1732",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "src1 are shifted right by the number of bits specified in",
      "bits 58:63 of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Quadword",
        "form": "VX",
        "mnemonic": "vsrq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "517",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 7 bits of src2.",
      "",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Algebraic Byte",
        "form": "VX",
        "mnemonic": "vsrab",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "772",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of byte element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of byte element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 3 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into byte element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Algebraic Halfword",
        "form": "VX",
        "mnemonic": "vsrah",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of halfword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of halfword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 4 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into halfword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Algebraic Word",
        "form": "VX",
        "mnemonic": "vsraw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "900",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of word element i of",
      "VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of word element i of",
      "VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 5 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Algebraic Doubleword",
        "form": "VX",
        "mnemonic": "vsrad",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "964",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 6 bits of src2.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Shift Right Algebraic Quadword",
        "form": "VX",
        "mnemonic": "vsraq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "773",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the contents of VSR[VRA+32].",
      "",
      "Let src2 be the contents of VSR[VRB+32].",
      "",
      "src1 is shifted right by the number of bits specified in",
      "the low-order 7 bits of src2.",
      "",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Add Floating-Point",
        "form": "VX",
        "mnemonic": "vaddfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "10",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "src1 is added to src2.",
      "",
      "",
      "The intermediate result is rounded to the nearest single-precision",
      "floating-point number and placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Subtract Floating-Point",
        "form": "VX",
        "mnemonic": "vsubfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "74",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "src2 is subtracted from src1.",
      "",
      "",
      "The intermediate result is rounded to the nearest single-precision",
      "floating-point number and placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-Add Floating-Point",
        "form": "VA",
        "mnemonic": "vmaddfp",
        "operands": [
          "VRT",
          "VRA",
          "VRC",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "46",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "Let src3 be the single-precision floating-point value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "src1 is multiplied by src3.",
      "",
      "",
      "src2 is added to the infinitely-precise product.",
      "",
      "",
      "The intermediate result is rounded to the nearest single-precision",
      "floating-point number and placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Negative Multiply-Subtract Floating-Point",
        "form": "VA",
        "mnemonic": "vnmsubfp",
        "operands": [
          "VRT",
          "VRA",
          "VRC",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "47",
            "size": "6"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "Let src3 be the single-precision floating-point value in",
      "word element i of VSR[VRC+32].",
      "",
      "",
      "src1 is multiplied by src3.",
      "",
      "",
      "src2 is subtracted from the infinitely-precise product.",
      "",
      "",
      "The intermediate result is rounded to the nearest single-precision",
      "floating-point number, then negated and placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Maximum Floating-Point",
        "form": "VX",
        "mnemonic": "vmaxfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1034",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The larger of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "The maximum of +0.0 and -0.0 is +0.0. The maximum of any value and a NaN is a QNaN.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Minimum Floating-Point",
        "form": "VX",
        "mnemonic": "vminfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1098",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "word element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "word element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The smaller of the two values is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "The minimum of +0.0 and -0.0 is -0.0. The minimum of any value and a NaN is a QNaN.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Convert with round to zero from floating-point To Signed Word format Saturate",
        "form": "VX",
        "mnemonic": "vctsxs",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "970",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the signed floating-point value in word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is multiplied by 2.",
      "The product is converted to a 32-bit signed fixed-point integer using",
      "the rounding mode Round toward Zero.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Convert with round to zero from floating-point To Unsigned Word format Saturate",
        "form": "VX",
        "mnemonic": "vctuxs",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "906",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the signed floating-point value in word",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is multiplied by 2.",
      "The product is converted to a 32-bit unsigned fixed-point integer",
      "using the rounding mode Round toward Zero.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Convert with round to nearest From Signed Word to floating-point format",
        "form": "VX",
        "mnemonic": "vcfsx",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "842",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the signed fixed-point value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src is converted to the nearest single-precision",
      "floating-point value.",
      "Each result is divided by 2 and placed into word",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Convert with round to nearest From Unsigned Word to floating-point format",
        "form": "VX",
        "mnemonic": "vcfux",
        "operands": [
          "VRT",
          "VRB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "778",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the unsigned fixed-point value in word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "src is converted to the nearest single-precision",
      "floating-point value.",
      "The result is divided by 2 and placed into word",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Round to Floating-Point Integer toward -Infinity",
        "form": "VX",
        "mnemonic": "vrfim",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "714",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is rounded to a single-precision floating-point",
      "integer using the rounding mode Round toward -Infinity.",
      "",
      "",
      "The result is placed into the corresponding word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Round to Floating-Point Integer Nearest",
        "form": "VX",
        "mnemonic": "vrfin",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "522",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is rounded to a single-precision floating-point",
      "integer using the rounding mode Round to Nearest.",
      "",
      "",
      "The result is placed into the corresponding word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Round to Floating-Point Integer toward +Infinity",
        "form": "VX",
        "mnemonic": "vrfip",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "650",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is rounded to a single-precision floating-point",
      "integer using the rounding mode Round toward +Infinity.",
      "",
      "",
      "The result is placed into the corresponding word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Round to Floating-Point Integer toward Zero",
        "form": "VX",
        "mnemonic": "vrfiz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "586",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src is rounded to a single-precision floating-point",
      "integer using the rounding mode Round toward Zero.",
      "",
      "",
      "The result is placed into the corresponding word element i  of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Bounds Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpbfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "966",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Bounds Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpbfp.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "966",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "A 2-bit value is formed that indicates whether src1 is",
      "within the bounds specified by src2, as follows.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The 2-bit value is placed into the high-order two bits of word",
      "element i of VSR[VRT+32] and the remaining",
      "bits of element i are set to 0.",
      "",
      "",
      "If Rc=1, CR field 6 is set as follows.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Equal Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpeqfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "198",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Equal Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpeqfp.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "198",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is equal to src2,",
      "and are set to all 0s otherwise.",
      "",
      "",
      "If src1 or src2 is a NaN, the contents of",
      "word element i of VSR[VRT+32] are set to all",
      "0s, indicating not equal to.",
      "If src1 and src2 are both infinity with the",
      "same sign, the contents of word element i of VSR[VRT+32] are set to all 1s, indicating equal to.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than or Equal Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpgefp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "454",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than or Equal Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpgefp.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "454",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is greater than or equal to",
      "src2, and are set to all 0s otherwise.",
      "",
      "",
      "If src1 or src2 is a NaN, the contents of",
      "word element i of VSR[VRT+32] are set to all",
      "0s, indicating not greater than or equal to.",
      "If src1 and src2 are both infinity with the",
      "same sign, the contents of word element i of VSR[VRT+32] are set to all 1s, indicating greater than or equal",
      "to.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Compare Greater Than Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpgtfp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "710",
            "size": "10"
          }
        ],
        "release": "v2.03"
      },
      {
        "name": "Vector Compare Greater Than Floating-Point",
        "form": "VC",
        "mnemonic": "vcmpgtfp.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "710",
            "size": "10"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point value in",
      "element i of VSR[VRA+32].",
      "",
      "",
      "Let src2 be the single-precision floating-point value in",
      "element i of VSR[VRB+32].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if src1 is greater than src2, and are set to all 0s otherwise.",
      "",
      "",
      "If src1 or src2 is a NaN, the contents of",
      "word element i of VSR[VRT+32] are set to all",
      "0s, indicating not greater than.",
      "If src1 and src2 are both infinity with the",
      "same sign, the contents of word element i of VSR[VRT+32] are set to all 0s, indicating not greater than.",
      "",
      "",
      "If Rc=1, CR field 6 is set to indicate whether all vector",
      "elements compared true and whether all vector elements compared false.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector 2 Raised to the Exponent Estimate Floating-Point",
        "form": "VX",
        "mnemonic": "vexptefp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "394",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The single-precision floating-point estimate of 2 raised to the power",
      "of single-precision floating-point element i of",
      "VSR[VRB+32] is placed into word element i of",
      "VSR[VRT+32].",
      "",
      "",
      "Let x be any single-precision floating-point input value.",
      "Unless x  -146 or the single-precision",
      "floating-point result of computing 2 raised to the power x would be a zero, an infinity, or a QNaN, the estimate has a",
      "relative error in precision no greater than one part in 16.",
      "The most significant 12 bits of the estimates significand are",
      "monotonic.",
      "An integral input value returns an integral value when the result is",
      "representable.",
      "",
      "The result for various special cases of the source value is given",
      "below.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Log Base 2 Estimate Floating-Point",
        "form": "VX",
        "mnemonic": "vlogefp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "458",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The single-precision floating-point estimate of the base 2 logarithm",
      "of single-precision floating-point element i of",
      "VSR[VRB+32] is placed into the corresponding word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "Let x be any single-precision floating-point input value.",
      "Unless | x-1 | is less than or equal to 0.125 or the",
      "single-precision floating-point result of computing the base 2",
      "logarithm of x would be an infinity or a QNaN, the",
      "estimate has an absolute error in precision (absolute value of the",
      "difference between the estimate and the infinitely precise value) no",
      "greater than 2.",
      "Under the same conditions, the estimate has a relative error in",
      "precision no greater than one part in 8.",
      "",
      "The most significant 12 bits of the estimates significand are",
      "monotonic.",
      "The estimate is exact if x=2, where y is an integer",
      "between -149 and +127 inclusive.",
      "Otherwise the value placed into the element of VSR[VRT+32] may vary between implementations, and between different",
      "executions on the same implementation.",
      "",
      "The result for various special cases of the source value is given",
      "below.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Reciprocal Estimate Floating-Point",
        "form": "VX",
        "mnemonic": "vrefp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "266",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The single-precision floating-point estimate of the reciprocal of",
      "single-precision floating-point element  i of VSR[VRB+32] is placed into word element  i of VSR[VRT+32].",
      "",
      "",
      "Unless the single-precision floating-point result of computing the",
      "reciprocal of a value would be a zero, an infinity, or a QNaN, the",
      "estimate has a relative error in precision no greater than one part",
      "in 4096.",
      "",
      "Note that results may vary between implementations, and between",
      "different executions on the same implementation.",
      "",
      "The result for various special cases of the source value is given",
      "below.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Reciprocal Square Root Estimate Floating-Point",
        "form": "VX",
        "mnemonic": "vrsqrtefp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "330",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The single-precision floating-point estimate of the reciprocal of the",
      "square root of single-precision floating-point element i",
      "of VSR[VRB+32] is placed into word element i",
      "of VSR[VRT+32].",
      "",
      "",
      "Let x be any single-precision floating-point value.",
      "Unless the single-precision floating-point result of computing the",
      "reciprocal of the square root of x would be a zero, an",
      "infinity, or a QNaN, the estimate has a relative error in precision",
      "no greater than one part in 4096.",
      "",
      "Note that results may vary between implementations, and between",
      "different executions on the same implementation.",
      "",
      "The result for various special cases of the source value is given",
      "below.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector AES Cipher",
        "form": "VX",
        "mnemonic": "vcipher",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1288",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let State be the contents of VSR[VRA+32],",
      "representing the intermediate state array during AES cipher operation.",
      "",
      "Let RoundKey be the contents of VSR[VRB+32],",
      "representing the round key.",
      "",
      "One round of an AES cipher operation is performed on the intermediate",
      "State array, sequentially applying the transforms,",
      "SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey(), as defined in FIPS-197.",
      "",
      "The result is placed into VSR[VRT+32], representing the",
      "new intermediate state of the cipher operation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector AES Cipher Last",
        "form": "VX",
        "mnemonic": "vcipherlast",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1289",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let State be the contents of VSR[VRA+32],",
      "representing the intermediate state array during AES cipher operation.",
      "",
      "Let RoundKey be the contents of VSR[VRB+32],",
      "representing the round key.",
      "",
      "The final round in an AES cipher operation is performed on the",
      "intermediate State array, sequentially applying the",
      "transforms, SubBytes(), ShiftRows(),",
      "AddRoundKey(), as defined in FIPS-197.",
      "",
      "The result is placed into VSR[VRT+32], representing the",
      "final state of the cipher operation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector AES Inverse Cipher",
        "form": "VX",
        "mnemonic": "vncipher",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1352",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let State be the contents of VSR[VRA+32],",
      "representing the intermediate state array during AES inverse cipher",
      "operation.",
      "",
      "Let RoundKey be the contents of VSR[VRB+32],",
      "representing the round key.",
      "",
      "One round of an AES inverse cipher operation is performed on the",
      "intermediate State array, sequentially applying the transforms,",
      "InvShiftRows(), InvSubBytes(), AddRoundKey(), and InvMixColumns(), as defined in",
      "FIPS-197.",
      "",
      "The result is placed into VSR[VRT+32], representing the",
      "new intermediate state of the inverse cipher operation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector AES Inverse Cipher Last",
        "form": "VX",
        "mnemonic": "vncipherlast",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1353",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let State be the contents of VSR[VRA+32],",
      "representing the intermediate state array during AES inverse cipher",
      "operation.",
      "",
      "Let RoundKey be the contents of VSR[VRB+32],",
      "representing the round key.",
      "",
      "The final round in an AES inverse cipher operation is performed on",
      "the intermediate State array, sequentially applying the",
      "transforms, InvShiftRows(), InvSubBytes(),",
      "and AddRoundKey(), as defined in FIPS-197.",
      "",
      "The result is placed into VSR[VRT+32], representing the",
      "final state of the inverse cipher operation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector AES SubBytes",
        "form": "VX",
        "mnemonic": "vsbox",
        "operands": [
          "VRT",
          "VRA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "1480",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let State be the contents of VSR[VRA+32],",
      "representing the intermediate state array during AES cipher operation.",
      "",
      "The result of applying the transform, SubBytes() on",
      "State, as defined in FIPS-197, is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector SHA-512 Sigma Doubleword",
        "form": "VX",
        "mnemonic": "vshasigmad",
        "operands": [
          "VRT",
          "VRA",
          "ST",
          "SIX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "ST",
            "size": "1"
          },
          {
            "name": "SIX",
            "size": "4"
          },
          {
            "name": "1730",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "When ST=0 and bit 2i of SIX is 0, a SHA-512 0 function is performed on",
      "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "When ST=0 and bit 2i of SIX is 1, a SHA-512 1 function is performed on",
      "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "When ST=1 and bit 2i of SIX is 0, a SHA-512 0 function is performed on",
      "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "When ST=1 and bit 2i of SIX is 1, a SHA-512 1 function is performed on",
      "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
      "i of VSR[VRT+32].",
      "",
      "",
      "Bits 1 and 3 of SIX are reserved.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector SHA-256 Sigma Word",
        "form": "VX",
        "mnemonic": "vshasigmaw",
        "operands": [
          "VRT",
          "VRA",
          "ST",
          "SIX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "ST",
            "size": "1"
          },
          {
            "name": "SIX",
            "size": "4"
          },
          {
            "name": "1666",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "When ST=0 and bit i of SIX is",
      "0, a SHA-256 0 function is performed on the",
      "contents of word element i of VSR[VRA+32] and",
      "the result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "When ST=0 and bit i of SIX is",
      "1, a SHA-256 1 function is performed on the",
      "contents of word element i of VSR[VRA+32] and",
      "the result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "When ST=1 and bit i of SIX is",
      "0, a SHA-256 0 function is performed on the",
      "contents of word element i of VSR[VRA+32] and",
      "the result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "When ST=1 and bit i of SIX is",
      "1, a SHA-256 1 function is performed on the",
      "contents of word element i of VSR[VRA+32] and",
      "the result is placed into word element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Polynomial Multiply-Sum Byte",
        "form": "VX",
        "mnemonic": "vpmsumb",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1032",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let prod[i] be the 15-bit result of a binary polynomial",
      "multiplication of the contents of byte element i of",
      "VSR[VRA+32] and the contents of byte element i of VSR[VRB+32].",
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:15 of halfword element",
      "i of VSR[VRT+32].",
      "Bit 0 of halfword element i of VSR[VRT+32] is",
      "set to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Polynomial Multiply-Sum Halfword",
        "form": "VX",
        "mnemonic": "vpmsumh",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1096",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let prod[i] be the 31-bit result of a binary polynomial",
      "multiplication of the contents of halfword element i of",
      "VSR[VRA+32] and the contents of halfword element",
      "i of VSR[VRB+32].",
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:31 of word element",
      "i of VSR[VRT+32].",
      "Bit 0 of word element i of VSR[VRT+32] is set",
      "to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Polynomial Multiply-Sum Word",
        "form": "VX",
        "mnemonic": "vpmsumw",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1160",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let prod[i] be the 63-bit result of a binary polynomial",
      "multiplication of the contents of word element i of",
      "VSR[VRA+32] and the contents of word element i of VSR[VRB+32].",
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:63 of doubleword element",
      "i of VSR[VRT+32].",
      "Bit 0 of doubleword element i of VSR[VRT+32]",
      "is set to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Polynomial Multiply-Sum Doubleword",
        "form": "VX",
        "mnemonic": "vpmsumd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1224",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let prod[0] be the 127-bit result of a binary polynomial",
      "multiplication of the contents of doubleword element 0 of VSR[VRA+32] and the contents of doubleword element 0 of VSR[VRB+32].",
      "",
      "Let prod[1] be the 127-bit result of a binary polynomial",
      "multiplication of the contents of doubleword element 1 of VSR[VRA+32] and the contents of doubleword element 1 of VSR[VRB+32].",
      "",
      "The exclusive-OR of prod[0] and prod[1] is",
      "placed in bits 1:127 of VSR[VRT+32].",
      "Bit 0 of VSR[VRT+32] is set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Permute  Exclusive-OR",
        "form": "VA",
        "mnemonic": "vpermxor",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "VRC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "VRC",
            "size": "5"
          },
          {
            "name": "45",
            "size": "6"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let indexA be the contents of bits 0:3 of byte element",
      "i of VSR[VRC+32].",
      "",
      "",
      "Let indexB be the contents of bits 4:7 of byte element",
      "i of VSR[VRC+32].",
      "",
      "",
      "The exclusive OR of the contents of byte element indexA",
      "of VSR[VRA+32] and the contents of byte element",
      "indexB of VSR[VRB+32] is placed into byte",
      "element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Gather Bits by Bytes by Doubleword",
        "form": "VX",
        "mnemonic": "vgbbd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1292",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the contents of VSR[VRB+32],",
      "composed of two doubleword elements numbered 0 and 1.",
      "",
      "Let each doubleword element be composed of eight bytes  numbered 0",
      "through 7.",
      "",
      "An 8-bit  8-bit bit-matrix transpose is performed on the",
      "contents of each doubleword element of VSR[VRB+32] (see",
      "Figure",
      ").",
      "",
      "For each integer value i from 0 to 1, do the following,",
      "",
      "",
      "",
      "The contents of bit 0 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 0",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 1 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 1",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 2 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 2",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 3 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 3",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 4 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 4",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 5 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 5",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 6 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 6",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of bit 7 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 7",
      "of doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Gather every Nth Bit",
        "form": "VX",
        "mnemonic": "vgnb",
        "operands": [
          "RT",
          "VRB",
          "N"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "N",
            "size": "3"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1228",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Starting with bit 0, the contents of every Nth bit of VSR[VRB+32] are",
      "concatenated and placed into GPR[RT].",
      "",
      "N can be any value between 2 and 7, inclusive.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zeros Byte",
        "form": "VX",
        "mnemonic": "vclzb",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1794",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 0 of",
      "byte element i of VSR[VRB+32] is placed into",
      "byte element i of VSR[VRT+32].",
      "This number ranges from 0 to 8, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zeros Halfword",
        "form": "VX",
        "mnemonic": "vclzh",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1858",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 0 of",
      "halfword element i of VSR[VRB+32] is placed",
      "into halfword element i of VSR[VRT+32].",
      "This number ranges from 0 to 16, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zeros Word",
        "form": "VX",
        "mnemonic": "vclzw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1922",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 0 of",
      "word element i of VSR[VRB+32] is placed into",
      "word element i of VSR[VRT+32].",
      "This number ranges from 0 to 32, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zeros Doubleword",
        "form": "VX",
        "mnemonic": "vclzd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1986",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 0 of",
      "doubleword element i of VSR[VRB+32] is placed",
      "into doubleword element i of VSR[VRT+32].",
      "This number ranges from 0 to 64, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zeros Doubleword under bit Mask",
        "form": "VX",
        "mnemonic": "vclzdm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1924",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, starting on the",
      "left, count the number of consecutive 0 bits in doubleword element",
      "i of VSR[VRA+32] corresponding to 1 bits in",
      "doubleword element i of VSR[VRB+32].",
      "Place count in doubleword element i of VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zeros Byte",
        "form": "VX",
        "mnemonic": "vctzb",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "28",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 7 of",
      "byte element i of VSR[VRB+32] is placed into",
      "byte element i of VSR[VRT+32].",
      "This number ranges from 0 to 8, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zeros Halfword",
        "form": "VX",
        "mnemonic": "vctzh",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "29",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 15 of",
      "halfword element i of VSR[VRB+32] is placed",
      "into halfword element i of VSR[VRT+32].",
      "This number ranges from 0 to 16, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zeros Word",
        "form": "VX",
        "mnemonic": "vctzw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "30",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 31 of",
      "word element i of VSR[VRB+32] is placed into",
      "word element i of VSR[VRT+32].",
      "This number ranges from 0 to 32, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zeros Doubleword",
        "form": "VX",
        "mnemonic": "vctzd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "A count of the number of consecutive zero bits starting at bit 63 of",
      "doubleword element i of VSR[VRB+32] is placed",
      "into doubleword element i of VSR[VRT+32].",
      "This number ranges from 0 to 64, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zeros Doubleword under bit Mask",
        "form": "VX",
        "mnemonic": "vctzdm",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1988",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, starting on the",
      "right, count the number of consecutive 0 bits in doubleword element",
      "i of VSR[VRA+32] corresponding to 1 bits in",
      "doubleword element i of VSR[VRB+32].",
      "Place count in doubleword element i of VSR[VRT+32].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Leading Zero Least-Significant Bits Byte",
        "form": "VX",
        "mnemonic": "vclzlsbb",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let count be the number of contiguous leading byte",
      "elements in VSR[VRB+32] having a zero least-significant",
      "bit.",
      "",
      "count is placed into GPR[RT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Trailing Zero Least-Significant Bits Byte",
        "form": "VX",
        "mnemonic": "vctzlsbb",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let count be the number of contiguous trailing byte",
      "elements of VSR[VRB+32] having a zero least-significant",
      "bit.",
      "",
      "count is placed into GPR[RT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Parallel Bits Deposit Doubleword",
        "form": "VX",
        "mnemonic": "vpdepd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1485",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let n be the number of bits in doubleword element",
      "i of VSR[VRB+32] that contain a 1.",
      "",
      "",
      "The contents of the rightmost n bits of doubleword",
      "element i of VSR[VRA+32] are placed into",
      "doubleword element i of VSR[VRT+32] under",
      "control of the mask in doubleword element i of VSR[VRB+32] as follows.",
      "",
      "",
      "",
      "",
      "",
      "",
      "The contents of bits in doubleword element i of",
      "VSR[VRT+32] corresponding to bits in doubleword element",
      "i of VSR[VRB+32] that contain a 0 are set to",
      "0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Parallel Bits Extract Doubleword",
        "form": "VX",
        "mnemonic": "vpextd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1421",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Starting from the right, for each bit in doubleword element",
      "i of VSR[VRB+32] that is equal to 1, place",
      "the contents of the corresponding bit in doubleword element",
      "i of VSR[VRA+32] into the rightmost",
      "unoccupied bit of doubleword element i of VSR[VRT+32].",
      "Any bits in doubleword element i of VSR[VRT+32]to the left of the most-significant bit copied are set to",
      "0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Centrifuge Doubleword",
        "form": "VX",
        "mnemonic": "vcfuged",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1357",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each doubleword element i of VSR[VRA+32], the bits whose corresponding bits in the",
      "mask in doubleword element i of VSR[VRB+32]",
      "equal 1 are placed in the rightmost bits in doubleword element",
      "i of VSR[VRT+32], maintaining their original",
      "relative order.",
      "The other bits in doubleword element i of VSR[VRA+32] are placed in the leftmost bits in",
      "doubleword element i of VSR[VRT+32],",
      "maintaining their original relative order.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Population Count Byte",
        "form": "VX",
        "mnemonic": "vpopcntb",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1795",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "A count of the number of bits set to 1 in byte element i",
      "of VSR[VRB+32] is placed into byte element i",
      "of VSR[VRT+32]. This number ranges from 0 to 8, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Population Count Halfword",
        "form": "VX",
        "mnemonic": "vpopcnth",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1859",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "A count of the number of bits set to 1 in halfword element i of VSR[VRB+32] is placed into halfword element",
      "i of VSR[VRT+32].",
      "This number ranges from 0 to 16, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Population Count Word",
        "form": "VX",
        "mnemonic": "vpopcntw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1923",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "A count of the number of bits set to 1 in word element",
      "i of VSR[VRB+32] is placed into word element",
      "i of VSR[VRT+32].",
      "This number ranges from 0 to 32, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Population Count Doubleword",
        "form": "VX",
        "mnemonic": "vpopcntd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1987",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "A count of the number of bits set to 1 in doubleword element",
      "i of VSR[VRB+32] is placed into doubleword",
      "element i of VSR[VRT+32].",
      "This number ranges from 0 to 64, inclusive.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Parity Byte Word",
        "form": "VX",
        "mnemonic": "vprtybw",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "8",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following",
      "",
      "",
      "",
      "If the sum of the least significant bit in each byte sub-element of",
      "word element i of VSR[VRB+32] is odd, the",
      "value 1 is placed into word element i of VSR[VRT+32]; otherwise the value 0 is placed into word element",
      "i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Parity Byte Doubleword",
        "form": "VX",
        "mnemonic": "vprtybd",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "9",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following",
      "",
      "",
      "",
      "If the sum of the least significant bit in each byte sub-element of",
      "doubleword element i of VSR[VRB+32] is odd,",
      "the value 1 is placed into doubleword element i of",
      "VSR[VRT+32]; otherwise the value 0 is placed into",
      "doubleword element i of VSR[VRT+32].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Parity Byte Quadword",
        "form": "VX",
        "mnemonic": "vprtybq",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "10",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1538",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "If the sum of the least significant bit in each byte element of",
      "VSR[VRB+32] is odd, the value 1 is placed into VSR[VRT+32]; otherwise the value 0 is placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Bit Permute Doubleword",
        "form": "VX",
        "mnemonic": "vbpermd",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1484",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, and for each",
      "integer value j from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let index be the contents of byte sub-element j of doubleword element i of VSR[VRB+32].",
      "",
      "",
      "If index is less than 64, then the contents of bit",
      "index of doubleword i of VSR[VRA+32] are placed into bit 56+j of doubleword",
      "element i of VSR[VRT+32].",
      "Otherwise, bit 56+j of doubleword element i",
      "of VSR[VRT+32] is set to 0.",
      "",
      "",
      "The contents of bits 0:55 of doubleword element i of",
      "VSR[VRT+32] are set to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Bit Permute Quadword",
        "form": "VX",
        "mnemonic": "vbpermq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1356",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let index be the contents of byte element i",
      "of VSR[VRB+32].",
      "",
      "",
      "If index is less than 128, then the contents",
      "of bit index of VSR[VRA+32] are placed into",
      "bit 48+i of doubleword element i of",
      "VSR[VRT+32].",
      "Otherwise, bit 48+i of doubleword element i",
      "of VSR[VRT+32] is set to 0.",
      "",
      "",
      "The contents of bits 0:47 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "The contents of bits 64:127 of VSR[VRT+32]",
      "are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to VSR Byte Mask",
        "form": "VX",
        "mnemonic": "mtvsrbm",
        "operands": [
          "VRT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "16",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the contents of bits 48:63 of GPR[RB].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "is set to all 0s if bit i of bm is equal to 0.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "is set to all 1s if bit i of bm is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to VSR Halfword Mask",
        "form": "VX",
        "mnemonic": "mtvsrhm",
        "operands": [
          "VRT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "17",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the contents of bits 56:63 of GPR[RB].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] is set to all 0s if bit i of bm",
      "is equal to 0.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] is set to all 1s if bit i of bm",
      "is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to VSR Word Mask",
        "form": "VX",
        "mnemonic": "mtvsrwm",
        "operands": [
          "VRT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the contents of bits 60:63 of GPR[RB].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "is set to all 0s if bit i of bm is equal to 0.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "is set to all 1s if bit i of bm is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to VSR Doubleword Mask",
        "form": "VX",
        "mnemonic": "mtvsrdm",
        "operands": [
          "VRT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "19",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the contents of bits 62:63 of GPR[RB].",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] is set to all 0s if bit i of bm",
      "is equal to 0.",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] is set to all 1s if bit i of bm",
      "is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move to VSR Quadword Mask",
        "form": "VX",
        "mnemonic": "mtvsrqm",
        "operands": [
          "VRT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the contents of bits 63 of GPR[RB].",
      "",
      "The contents of VSR[VRT+32] is set to all 0s if",
      "bm is equal to 0.",
      "",
      "The contents of VSR[VRT+32] is set to all 1s if",
      "bm is equal to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To VSR Byte Mask Immediate",
        "form": "DX",
        "mnemonic": "mtvsrbmi",
        "operands": [
          "VRT",
          "bm"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "bm1",
            "size": "5"
          },
          {
            "name": "bm0",
            "size": "10"
          },
          {
            "name": "10",
            "size": "5"
          },
          {
            "name": "bm2",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bm be the concatenation of b0, b1 and b2.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "is set to all 0s if bit i of bm is equal to 0.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "is set to all 1s if bit i of bm is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Expand Byte Mask",
        "form": "VX",
        "mnemonic": "vexpandbm",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let bmi be the contents of bit 0 of byte element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 0s if bmi is equal to 0.",
      "",
      "",
      "The contents of byte element i of VSR[VRT+32]",
      "are set to all 1s if bmi is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Expand Halfword Mask",
        "form": "VX",
        "mnemonic": "vexpandhm",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "Let bmi be the contents of bit 0 of halfword element",
      "i of VSR[VRB+32],",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 0s if bmi is equal to 0.",
      "",
      "",
      "The contents of halfword element i of VSR[VRT+32] are set to all 1s if bmi is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Expand Word Mask",
        "form": "VX",
        "mnemonic": "vexpandwm",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let bmi be the contents of bit 0 of word element",
      "i of VSR[VRB+32].",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 0s if bmi is equal to 0.",
      "",
      "",
      "The contents of word element i of VSR[VRT+32]",
      "are set to all 1s if bmi is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Expand Doubleword Mask",
        "form": "VX",
        "mnemonic": "vexpanddm",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "3",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let bmi be the contents of bit 0 of doubleword element",
      "i of VSR[VRB+32],",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] are set to all 0s if bmi is equal to 0.",
      "",
      "",
      "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if bmi is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Expand Quadword Mask",
        "form": "VX",
        "mnemonic": "vexpandqm",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "4",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let bmi be the contents of bit 0 of VSR[VRB+32].",
      "",
      "The contents of VSR[VRT+32] are set to all 0s if",
      "bmi is equal to 0.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "bmi is equal to 1.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Mask Bits Byte",
        "form": "VX",
        "mnemonic": "vcntmbb",
        "operands": [
          "RT",
          "VRB",
          "MP"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "12",
            "size": "4"
          },
          {
            "name": "MP",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The number of byte elements having bit 0 set to the value MP in VSR[VRB+32] is placed into bits 0:7 of GPR[RT]. Bits 8:63 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Mask Bits Halfword",
        "form": "VX",
        "mnemonic": "vcntmbh",
        "operands": [
          "RT",
          "VRB",
          "MP"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "13",
            "size": "4"
          },
          {
            "name": "MP",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The number of halfword elements having bit 0 set to the value",
      "MP in VSR[VRB+32] is placed into bits 0:6 of",
      "GPR[RT]. Bits 7:63 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Mask Bits Word",
        "form": "VX",
        "mnemonic": "vcntmbw",
        "operands": [
          "RT",
          "VRB",
          "MP"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "14",
            "size": "4"
          },
          {
            "name": "MP",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The number of word elements having bit 0 set to the value MP in VSR[VRB+32] is placed into bits 0:5 of GPR[RT]. Bits 6:63 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Count Mask Bits Doubleword",
        "form": "VX",
        "mnemonic": "vcntmbd",
        "operands": [
          "RT",
          "VRB",
          "MP"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "15",
            "size": "4"
          },
          {
            "name": "MP",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The number of doubleword elements having bit 0 set to the value",
      "MP in VSR[VRB+32] is placed into bits 0:4 of",
      "GPR[RT]. Bits 5:63 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Byte Mask",
        "form": "VX",
        "mnemonic": "vextractbm",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "8",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of each byte element of VSR[VRB+32]",
      "are concatenated and placed into bits 48:63 of GPR[RT].",
      "Bits 0:47 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Halfword Mask",
        "form": "VX",
        "mnemonic": "vextracthm",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "9",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of each halfword element of VSR[VRB+32] are concatenated and placed into bits 56:63 of",
      "GPR[RT]. Bits 0:55 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Word Mask",
        "form": "VX",
        "mnemonic": "vextractwm",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "10",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of each word element of VSR[VRB+32]",
      "are concatenated and placed into bits 60:63 of GPR[RT].",
      "Bits 0:59 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Doubleword Mask",
        "form": "VX",
        "mnemonic": "vextractdm",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "11",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of each doubleword element of VSR[VRB+32] are concatenated and placed into bits 62:63 of",
      "GPR[RT]. Bits 0:61 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Extract Quadword Mask",
        "form": "VX",
        "mnemonic": "vextractqm",
        "operands": [
          "RT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "12",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1602",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of VSR[VRB+32] are placed into bit",
      "63 of GPR[RT].",
      "Bits 0:62 of GPR[RT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector String Isolate Byte Right-justified",
        "form": "VC",
        "mnemonic": "vstribr",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector String Isolate Byte Right-justified",
        "form": "VC",
        "mnemonic": "vstribr.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "From right-to-left, the contents of each byte element of VSR[VRB+32] are placed into the corresponding byte element in",
      "VSR[VRT+32].",
      "If a byte element in VSR[VRB+32] is found to contain 0,",
      "the corresponding byte element and all byte elements to the left of",
      "that byte element in VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector String Isolate Byte Left-justified",
        "form": "VC",
        "mnemonic": "vstribl",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector String Isolate Byte Left-justified",
        "form": "VC",
        "mnemonic": "vstribl.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "From left-to-right, the contents of each byte element of VSR[VRB+32] are placed into the corresponding byte element in",
      "VSR[VRT+32].",
      "If a byte element in VSR[VRB+32] is found to contain 0,",
      "the corresponding byte element and all byte elements to the right of",
      "that byte element in VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector String Isolate Halfword Right-justified",
        "form": "VC",
        "mnemonic": "vstrihr",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "3",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector String Isolate Halfword Right-justified",
        "form": "VC",
        "mnemonic": "vstrihr.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "3",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "From right-to-left, the contents of each halfword element of",
      "VSR[VRB+32] are placed into the corresponding halfword",
      "element in VSR[VRT+32].",
      "If a halfword element in VSR[VRB+32] is found to contain",
      "0, the corresponding halfword element and all halfword elements to",
      "the left of that halfword element in VSR[VRT+32] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector String Isolate Halfword Left-justified",
        "form": "VC",
        "mnemonic": "vstrihl",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Vector String Isolate Halfword Left-justified",
        "form": "VC",
        "mnemonic": "vstrihl.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "13",
            "size": "10"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "From left-to-right, the contents of each halfword element of",
      "VSR[VRB+32] are placed into the corresponding halfword",
      "element in VSR[VRT+32].",
      "If a halfword element in VSR[VRB+32] is found to contain",
      "0, the corresponding halfword element and all halfword elements to",
      "the right of that halfword element in VSR[VRT+32] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Clear Leftmost Bytes",
        "form": "VX",
        "mnemonic": "vclrlb",
        "operands": [
          "VRT",
          "VRA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "397",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let N be the integer value in GPR[RB], or the",
      "integer value 16 if the integer value in GPR[RB] is",
      "greater than 15.",
      "",
      "The contents of VSR[VRA+32] are placed into VSR[VRT+32] with the leftmost 16-N bytes of VSR[VRT+32] set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Clear Rightmost Bytes",
        "form": "VX",
        "mnemonic": "vclrrb",
        "operands": [
          "VRT",
          "VRA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "461",
            "size": "11"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let N be the integer value in GPR[RB], or the",
      "integer value 16 if the integer value in GPR[RB] is",
      "greater than 15.",
      "",
      "The contents of VSR[VRA+32] are placed into VSR[VRT+32] with the rightmost 16-N bytes of VSR[VRT+32] set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Add Modulo",
        "form": "VX",
        "mnemonic": "bcdadd.",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "1",
            "size": "9"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the decimal integer value in VSR[VRA+32].",
      "",
      "Let src2 be the decimal integer value in VSR[VRB+32].",
      "",
      "src1 is added to src2.",
      "",
      "If the unbounded result is equal to zero, do the following.",
      "",
      "",
      "",
      "If PS=0, the sign code of the result is set to 0b1100.",
      "",
      "",
      "If PS=1, the sign code of the result is set to 0b1111.",
      "",
      "",
      "CR field 6 is set to 0b0010.",
      "",
      "",
      "If the unbounded result is greater than zero, do the following.",
      "",
      "",
      "",
      "If PS=0, the sign code of the result is set to 0b1100.",
      "",
      "",
      "If PS=1, the sign code of the result is set to 0b1111.",
      "",
      "",
      "If the operation overflows, CR field 6 is set",
      "to 0b0101.",
      "Otherwise, CR field 6 is set to 0b0100.",
      "",
      "",
      "If the unbounded result is less than zero, do the following.",
      "",
      "",
      "",
      "The sign code of the result is set to 0b1101.",
      "",
      "",
      "If the operation overflows, CR field 6 is set",
      "to 0b1001.",
      "Otherwise, CR field 6 is set to 0b1000.",
      "",
      "",
      "The low-order 31 digits of the magnitude of the result",
      "are placed in bits 0:123 of VSR[VRT+32].",
      "",
      "The sign code is placed in bits 124:127 of VSR[VRT+32].",
      "",
      "If either src1 or src2 is an invalid encoding of a 31-digit signed decimal value, the",
      "result is undefined and CR field 6 is set to",
      "0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Subtract Modulo",
        "form": "VX",
        "mnemonic": "bcdsub.",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "65",
            "size": "9"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the decimal integer value in VSR[VRA+32].",
      "",
      "Let src2 be the decimal integer value in VSR[VRB+32].",
      "",
      "src1 is subtracted by src2.",
      "",
      "If the unbounded result is equal to zero, do the following.",
      "",
      "",
      "",
      "If PS=0, the sign code of the result is set to 0b1100.",
      "",
      "",
      "If PS=1, the sign code of the result is set to 0b1111.",
      "",
      "",
      "CR field 6 is set to 0b0010.",
      "",
      "",
      "If the unbounded result is greater than zero, do the following.",
      "",
      "",
      "",
      "If PS=0, the sign code of the result is set to 0b1100.",
      "",
      "",
      "If PS=1, the sign code of the result is set to 0b1111.",
      "",
      "",
      "If the operation overflows, CR field 6 is set",
      "to 0b0101.",
      "Otherwise, CR field 6 is set to 0b0100.",
      "",
      "",
      "If the unbounded result is less than zero, do the following.",
      "",
      "",
      "",
      "The sign code of the result is set to 0b1101.",
      "",
      "",
      "If the operation overflows, CR field 6 is set",
      "to 0b1001.",
      "Otherwise, CR field 6 is set to 0b1000.",
      "",
      "",
      "The low-order 31 digits of the magnitude of the result",
      "are placed in bits 0:123 of VSR[VRT+32].",
      "",
      "The sign code is placed in bits 124:127 of VSR[VRT+32].",
      "",
      "If either src1 or src2 is an invalid encoding of a 31-digit signed decimal value, the",
      "result is undefined and CR field 6 is set to",
      "0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert From National",
        "form": "VX",
        "mnemonic": "bcdcfn.",
        "operands": [
          "VRT",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "7",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the national decimal value in VSR[VRB+32].",
      "",
      "src is placed in VSR[VRT+32] in packed",
      "decimal format.",
      "",
      "A valid encoding of a national decimal value requires the following.",
      "",
      "",
      "",
      "National decimal values having a sign code of 0x002B are",
      "interpreted as positive values.",
      "",
      "National decimal values having a sign code of 0x002D are",
      "interpreted as negative values.",
      "",
      "For each integer value i from 0 to 23, do the following.",
      "",
      "",
      "",
      "The contents of nibble element i of VSR[VRT+32] are set to 0x0.",
      "",
      "",
      "For each integer value i from 0 to 6, do the following.",
      "",
      "",
      "",
      "The contents of nibble 3 of halfword element i of",
      "src are placed into nibble element i+24 of",
      "VSR[VRT+32].",
      "",
      "",
      "For PS=0, the contents of nibble element 31 (i.e., sign",
      "code) of VSR[VRT+32] are set to 0xC for",
      "positive values and to 0xD for negative values.",
      "",
      "For PS=1, the contents of nibble element 31 (i.e., sign",
      "code) of VSR[VRT+32] are set to 0xF for",
      "positive values and to 0xD for negative values.",
      "",
      "CR field 6 is set to reflect src compared to zero.",
      "",
      "If src is an invalid encoding of a national",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert From Zoned",
        "form": "VX",
        "mnemonic": "bcdcfz.",
        "operands": [
          "VRT",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "6",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the zoned decimal value in VSR[VRB+32].",
      "",
      "src is placed in VSR[VRT+32] in packed",
      "decimal format.",
      "",
      "When PS=0, do the following.",
      "",
      "",
      "",
      "A valid encoding of a zoned decimal value requires the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "Zoned decimal values having a sign code of 0x0,",
      "0x1, 0x2, 0x3, 0x8,",
      "0x9, 0xA, or 0xB are interpreted",
      "as positive values.",
      "",
      "",
      "Zoned decimal values having a sign code of 0x4,",
      "0x5, 0x6, 0x7, 0xC,",
      "0xD, 0xE, or 0xF are interpreted",
      "as negative values.",
      "",
      "",
      "When PS=1, do the following.",
      "",
      "",
      "",
      "A valid encoding of a zoned decimal source operand requires the",
      "following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "Zoned decimal source operands having a sign code of 0xA,",
      "0xC, 0xE, or 0xF are interpreted",
      "as positive values.",
      "",
      "",
      "Zoned decimal source operands having a sign code of 0xB",
      "or 0xD are interpreted as negative values.",
      "",
      "",
      "Positive packed decimal results are returned with a sign code of",
      "0xC.",
      "",
      "Negative packed decimal results are returned with a sign code of",
      "0xD.",
      "",
      "For each integer value i from 0 to 14,",
      "",
      "",
      "",
      "The contents of nibble element i of VSR[VRT+32] are set to 0x0.",
      "",
      "",
      "For each integer value i from 0 to 15,",
      "",
      "",
      "",
      "The contents of nibble 1 of byte element i of src are placed into nibble element i+15 of VSR[VRT+32].",
      "",
      "",
      "CR field 6 is set to reflect src compared to zero.",
      "",
      "If src is an invalid encoding of a zoned",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert To National",
        "form": "VX",
        "mnemonic": "bcdctn.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "5",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the packed decimal value in VSR[VRB+32].",
      "",
      "src is placed into VSR[VRT+32] in national",
      "decimal format.",
      "",
      "A valid encoding of a signed packed decimal value requires the",
      "following.",
      "",
      "",
      "",
      "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
      "values.",
      "",
      "Packed decimal values with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "Values greater in magnitude than 107-1 are too",
      "large to be represented in national decimal format.",
      "",
      "For each integer value i from 0 to 6, do the following.",
      "",
      "",
      "",
      "The value 0x003 is placed into nibbles 0:2 of halfword",
      "element i of VSR[VRT+32].",
      "",
      "",
      "The contents of nibble element i+24 of VSR[VRB+32] are placed into nibble 3 of halfword element i of VSR[VRT+32].",
      "",
      "",
      "The contents of halfword element 7 (i.e., sign code) of VSR[VRT+32] are set to 0x002B for positive values and to",
      "0x002D for negative values.",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not src is too large to be",
      "represented in national decimal format.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert To Zoned",
        "form": "VX",
        "mnemonic": "bcdctz.",
        "operands": [
          "VRT",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "4",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the packed decimal value in VSR[VRB+32].",
      "",
      "src is placed into  VSR[VRT+32] in zoned",
      "decimal format.",
      "",
      "A valid encoding of a signed packed decimal value requires the",
      "following.",
      "",
      "",
      "",
      "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
      "values.",
      "",
      "Packed decimal values with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "Values greater in magnitude than 1016-1 are too",
      "large to be represented in zoned decimal format.",
      "",
      "For PS=0, do the following.",
      "",
      "",
      "",
      "The leftmost nibble of each digit 0-14 of the zoned decimal result is",
      "set to 0x3.",
      "",
      "",
      "Positive zoned decimal results are returned with a sign code of",
      "0x3.",
      "",
      "",
      "Negative zoned decimal results are returned with a sign code of",
      "0x7.",
      "",
      "",
      "For PS=1, do the following.",
      "",
      "",
      "",
      "The leftmost nibble of each digit 0-14 of the zoned decimal result is",
      "set to 0xF.",
      "",
      "",
      "Positive zoned decimal results are returned with a sign code of",
      "0xC.",
      "",
      "",
      "Negative zoned decimal results are returned with a sign code of",
      "0xD.",
      "",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The rightmost nibble of each digit i of the zoned decimal",
      "result is set to the contents of nibble i+15 of",
      "src.",
      "",
      "",
      "The result is placed into VSR[VRT+32].",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not src is too large to be",
      "represented in zoned decimal format.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert From Signed Quadword",
        "form": "VX",
        "mnemonic": "bcdcfsq.",
        "operands": [
          "VRT",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the signed integer value in VSR[VRB+32].",
      "",
      "src is placed into VSR[VRT+32] in signed",
      "packed decimal format.",
      "",
      "For PS=0, the contents of nibble element 31 (i.e., sign",
      "code) of VSR[VRT+32] are set to 0xC for",
      "values greater than or equal to 0 and to 0xD for values",
      "less than 0.",
      "",
      "For PS=1, the contents of nibble element 31 (i.e., sign",
      "code) of VSR[VRT+32] are set to 0xF for",
      "values greater than or equal to 0 and to 0xD for values",
      "less than 0.",
      "",
      "If the signed integer value in VSR[VRB+32] is greater",
      "than 10-1 or less than -10-1, the value is too large to be represented in",
      "packed decimal format, and the contents of VSR[VRT+32]",
      "are undefined.",
      "",
      "CR field 6 is set to reflect src compared to",
      "zero and whether or not src is too large in magnitude to",
      "be represented in packed decimal format.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Convert To Signed Quadword",
        "form": "VX",
        "mnemonic": "bcdctsq.",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the packed decimal value in VSR[VRB+32].",
      "",
      "src is placed into VSR[VRT+32] in signed",
      "integer format.",
      "",
      "A valid encoding of a signed packed decimal value requires the",
      "following.",
      "",
      "",
      "",
      "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
      "values.",
      "",
      "Packed decimal values with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "CR field 6 is set to reflect src compared to zero.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-by-10 Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vmul10uq",
        "operands": [
          "VRT",
          "VRA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "513",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the unsigned integer value in VSR[VRA+32].",
      "",
      "The rightmost 128 bits of the product of src multiplied",
      "by the value 10 are placed into VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-by-10  write Carry-out Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vmul10cuq",
        "operands": [
          "VRT",
          "VRA"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "1",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the unsigned integer value in VSR[VRA+32].",
      "",
      "The product of src multiplied by the value 10 is shifted",
      "right by 128 bits.",
      "The rightmost 128 bits of the shifted result is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-by-10 Extended Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vmul10euq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "577",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let cin be the unsigned packed decimal value in bits",
      "124:127 of VSR[VRB+32].",
      "Values of cin greater than 9 are undefined.",
      "",
      "The rightmost 128 bits of the sum of cin and the product",
      "of src multiplied by the value 10 are placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Vector Multiply-by-10 Extended  write Carry-out Unsigned Quadword",
        "form": "VX",
        "mnemonic": "vmul10ecuq",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "65",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the unsigned integer value in VSR[VRA+32].",
      "",
      "Let cin be the unsigned packed decimal value in bits",
      "124:127 of VSR[VRA+32].",
      "Values of cin greater than 9 are undefined.",
      "",
      "The sum of cin and the product of src",
      "multiplied by the value 10 is shifted right by 128 bits.",
      "The rightmost 128 bits of the shifted result is placed into",
      "VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Copy Sign",
        "form": "VX",
        "mnemonic": "bcdcpsgn.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "833",
            "size": "11"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The decimal value in VSR[VRA+32] is placed into",
      "VSR[VRT+32] with the sign code of the decimal value in",
      "VSR[VRB+32].",
      "",
      "CR field 6 is set to reflect the result compared to zero.",
      "",
      "If either the decimal value in VSR[VRA+32] or the decimal",
      "value in VSR[VRB+32] is an invalid encoding,",
      "the contents of VSR[VRT+32] are undefined and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Set Sign",
        "form": "VX",
        "mnemonic": "bcdsetsgn.",
        "operands": [
          "VRT",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "385",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the packed decimal value in VSR[VRB+32].",
      "",
      "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
      "values.",
      "",
      "Packed decimal values with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "If src is negative, src is placed into",
      "VSR[VRT+32] with the sign code set to 0xD.",
      "",
      "If src is positive and PS=0, src",
      "is placed into VSR[VRT+32] with the sign code set to",
      "0xC.",
      "",
      "If src is positive and PS=1, src",
      "is placed into VSR[VRT+32] with the sign code set to",
      "0xF.",
      "",
      "CR field 6 is set to reflect src compared to zero.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Shift",
        "form": "VX",
        "mnemonic": "bcds.",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "193",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the signed integer value in byte element",
      "7 of VSR[VRA+32].",
      "",
      "Let src be the signed packed decimal value in VSR[VRB+32].",
      "",
      "A valid encoding of a signed packed decimal value requires the",
      "following.",
      "",
      "",
      "",
      "Packed decimal source operands with sign codes of 0xA,",
      "0xC, 0xE, or 0xF are interpreted",
      "as positive values.",
      "",
      "Packed decimal source operands with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "If n is greater than zero, src is shifted",
      "left n digits.",
      "Zeros are supplied to vacated digits on the right.",
      "If any non-zero digits are shifted out, an overflow occurs.",
      "",
      "If n is less than zero, src is shifted right",
      "-n digits.",
      "Zeros are supplied to vacated digits on the left.",
      "",
      "If the packed decimal value in VSR[VRB+32] is negative,",
      "the sign code of the result is set to 0b1101.",
      "",
      "If the packed decimal value in VSR[VRB+32] is positive,",
      "the sign code of the result is set to 0b1100 if",
      "PS=0 and is set to 0b1111 if PS=1.",
      "",
      "The shifted result is placed into VSR[VRT+32].",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not significant digits were shifted out when the",
      "shift count is positive (i.e., left shift operation).",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Unsigned Shift",
        "form": "VX",
        "mnemonic": "bcdus.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "129",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the signed integer value in byte element",
      "7 of VSR[VRA+32].",
      "",
      "Let src be the unsigned packed decimal value in",
      "VSR[VRB+32].",
      "",
      "A valid encoding of an unsigned packed decimal value requires the",
      "contents of each nibble 0-31 must be a value in the range 0x0 to 0x9.",
      "",
      "If n is greater than zero, src is shifted",
      "left n digits.",
      "Zeros are supplied to vacated digits on the right.",
      "If any non-zero digits are shifted out, an overflow occurs.",
      "",
      "If n is less than zero, src is shifted right",
      "-n digits.",
      "Zeros are supplied to vacated digits on the left.",
      "",
      "The shifted result is placed into VSR[VRT+32].",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not significant digits were shifted out when the",
      "shift count is positive (i.e., left shift operation).",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Shift  Round",
        "form": "VX",
        "mnemonic": "bcdsr.",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "449",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let n be the signed integer value in byte element",
      "7 of VSR[VRA+32].",
      "",
      "Let src be the signed packed decimal value in VSR[VRB+32].",
      "",
      "A valid encoding of a signed packed decimal source operand requires",
      "the following.",
      "",
      "",
      "",
      "Packed decimal source operands with sign codes of 0xA,",
      "0xC, 0xE, or 0xF are interpreted",
      "as positive values.",
      "",
      "Packed decimal source operands with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "If n is greater than zero, src is shifted",
      "left n digits.",
      "Zeros are supplied to vacated digits on the right.",
      "If any non-zero digits are shifted out, an overflow occurs.",
      "",
      "If n is less than zero, src is shifted right",
      "-n digits.",
      "Zeros are supplied to vacated digits on the left.",
      "If the value of the last nibble shifted out on the right was greater",
      "than or equal to 5, the magnitude of the result is incremented by 1.",
      "",
      "If src is negative, the sign code of the result is set to",
      "0b1101.",
      "",
      "If src is positive, the sign code of the result is set to",
      "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
      "",
      "The shifted and rounded result is placed into VSR[VRT+32].",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not significant digits were shifted out when the",
      "shift count is positive (i.e., left shift operation).",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Truncate",
        "form": "VX",
        "mnemonic": "bcdtrunc.",
        "operands": [
          "VRT",
          "VRA",
          "VRB",
          "PS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "PS",
            "size": "1"
          },
          {
            "name": "257",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let length be the integer value in bits 48:63 of",
      "VSR[VRA+32].",
      "",
      "Let src be the signed decimal value in VSR[VRB+32].",
      "",
      "A valid encoding of a packed decimal source operand requires the",
      "following.",
      "",
      "",
      "",
      "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
      "values.",
      "",
      "Packed decimal values with sign codes of 0xB or",
      "0xD are interpreted as negative values.",
      "",
      "If src is negative, the sign code of the result is set to",
      "0b1101.",
      "",
      "If src is positive, the sign code of the result is set to",
      "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
      "",
      "src is copied into VSR[VRT+32] with the",
      "leftmost 31-length digits each set to 0b0000.",
      "If any of the leftmost 31-length digits of the signed",
      "decimal value in VSR[VRB+32] are non-zero, an overflow",
      "occurs.",
      "",
      "CR field 6 is set to reflect src compared to zero,",
      "including whether or not significant digits were truncated.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Decimal Unsigned Truncate",
        "form": "VX",
        "mnemonic": "bcdutrunc.",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "321",
            "size": "9"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let length be the integer value in bits 48:63 of",
      "VSR[VRA+32].",
      "",
      "Let src be the unsigned decimal value in VSR[VRB+32].",
      "",
      "A valid encoding of a packed decimal source operand requires the",
      "contents of each nibble 0-31 must be a value in the range 0x0 to 0x9.",
      "",
      "src is copied into VSR[VRT+32] with the",
      "leftmost 32-length digits each set to 0b0000.",
      "If any of the leftmost 32-length digits of the signed",
      "decimal value in VSR[VRB+32] are non-zero, an overflow",
      "occurs.",
      "",
      "CR field 6 is set to reflect src compared to",
      "zero, including whether or not significant digits were truncated.",
      "",
      "If src is an invalid encoding of a packed",
      "decimal value, the contents of VSR[VRT+32] are undefined",
      "and CR field 6 is set to 0b0001.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Vector Status and Control Register",
        "form": "VX",
        "mnemonic": "mtvscr",
        "operands": [
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "1604",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of word element 3 of VSR[VRB+32] are placed",
      "into the VSCR.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Vector Status and Control Register",
        "form": "VX",
        "mnemonic": "mfvscr",
        "operands": [
          "VRT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "4",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "1540",
            "size": "11"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "",
      "The contents of the VSCR are placed into word element 3 of VSR[VRT+32].",
      "",
      "The remaining word elements in VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar Doubleword",
        "form": "DS",
        "mnemonic": "lxsd",
        "operands": [
          "VRT",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "57",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "2",
            "size": "2"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Load VSX Scalar Doubleword",
        "form": "8LS:D",
        "mnemonic": "plxsd",
        "operands": [
          "VRT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "42",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let XT be the value VRT + 32.",
      "",
      "For lxsd, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
      "",
      "For plxsd with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plxsd with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte",
      "ordering is employed, let load_data be the contents of",
      "the doubleword in storage at address EA such that;",
      "",
      "",
      "",
      "load_data is placed into doubleword element 0 of",
      "VSR[VRT+32].",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are set to 0.",
      "",
      "For plxsd, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar Doubleword Indexed",
        "form": "X",
        "mnemonic": "lxsdx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "588",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is placed into doubleword element 0 of",
      "VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar as Integer Byte  Zero Indexed",
        "form": "X",
        "mnemonic": "lxsibzx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "781",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be sum of the contents of",
      "GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "The unsigned integer in the byte in storage addressed by EA is placed in doubleword element 0 of VSR[XT].",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar as Integer Halfword  Zero Indexed",
        "form": "X",
        "mnemonic": "lxsihzx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "813",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be sum of the contents of",
      "GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "The unsigned integer in the halfword in storage addressed by",
      "EA is placed in doubleword element 0 of VSR[XT].",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar as Integer Word Algebraic Indexed",
        "form": "X",
        "mnemonic": "lxsiwax",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "76",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "load_data is sign-extended to a doubleword and placed in",
      "doubleword element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar as Integer Word  Zero Indexed",
        "form": "X",
        "mnemonic": "lxsiwzx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "12",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "load_data is zero-extended and placed in doubleword",
      "element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar Single-Precision",
        "form": "DS",
        "mnemonic": "lxssp",
        "operands": [
          "VRT",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "57",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "3",
            "size": "2"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Load VSX Scalar Single-Precision",
        "form": "8LS:D",
        "mnemonic": "plxssp",
        "operands": [
          "VRT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "43",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value VRT + 32.",
      "",
      "For lxssp, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
      "",
      "For plxssp with R=0, let the",
      "effective address (EA) be the sum of the contents of",
      "register RA, or the value 0 if RA=0, and the",
      "value d0||d1, sign-extended to 64 bits.",
      "",
      "For plxssp with R=1, let the",
      "effective address (EA) be the sum of the address of the",
      "instruction and the value d0||d1,",
      "sign-extended to 64 bits.",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "load_data, interpreted as a single-precision",
      "floating-point value, is placed into doubleword element 0 of",
      "VSR[VRT+32] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "For plxssp, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Scalar Single-Precision Indexed",
        "form": "X",
        "mnemonic": "lxsspx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "524",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "load_data, interpreted as a single-precision",
      "floating-point value, is placed in doubleword element 0 of VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector",
        "form": "DQ",
        "mnemonic": "lxv",
        "operands": [
          "XT",
          "DQ(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DQ",
            "size": "12"
          },
          {
            "name": "TX",
            "size": "1"
          },
          {
            "name": "1",
            "size": "3"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Load VSX Vector",
        "form": "8LS:D",
        "mnemonic": "plxv",
        "operands": [
          "XT",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "imm18",
            "size": "18"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "TX",
            "size": "1"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX +",
      "T.",
      "",
      "For lxv, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
      "",
      "For plxv with R=0, let the effective",
      "address (EA) be the sum of the contents of register",
      "RA, or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For plxv with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "quadword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "quadword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is placed into VSR[XT].",
      "",
      "For plxv, if R is equal to 1 and RA is not equal to 0, the instruction form is",
      "invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Byte*16 Indexed",
        "form": "X",
        "mnemonic": "lxvb16x",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "876",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "For each integer value from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of the byte in storage at address EA+i are",
      "placed into byte element i of VSR[XT],",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Doubleword*2 Indexed",
        "form": "X",
        "mnemonic": "lxvd2x",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "844",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA+8i are",
      "placed into load_data in such an order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA+8i are",
      "placed into load_data in such an order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "load_data is placed into doubleword element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Special Value Quadword",
        "form": "X",
        "mnemonic": "lxvkq",
        "operands": [
          "XT",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "UIM",
            "size": "5"
          },
          {
            "name": "360",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "UIM specifies one of a set of common values that is",
      "placed into VSR[XT].",
      "Unspecified values of UIM are reserved.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector with Length",
        "form": "X",
        "mnemonic": "lxvl",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "269",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the contents of",
      "GPR[RA], or 0 if RA is equal to 0.",
      "",
      "Let nb be the unsigned integer value in bits 0:7 of",
      "GPR[RB].",
      "",
      "If nb is equal to 0, the storage access is not performed",
      "and the contents of VSR[XT] are set to 0.",
      "",
      "Otherwise, when Big-Endian byte-ordering is employed, do the",
      "following.",
      "",
      "",
      "",
      "Otherwise, when Little-Endian byte ordering is employed, do the",
      "following.",
      "",
      "",
      "",
      "If the contents of bits 8:63 of GPR[RB] are not equal to",
      "0, the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector with Length Left-justified",
        "form": "X",
        "mnemonic": "lxvll",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "301",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the contents of",
      "GPR[RA], or 0 if RA is equal to 0.",
      "",
      "Let nb be the unsigned integer value in bits 0:7 of GPR[RB].",
      "",
      "If nb is equal to 0, the storage access is not performed",
      "and the contents of VSR[XT] are set to 0.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "If nb less than 16, the contents of the",
      "nb bytes in storage starting at address EA",
      "are placed into the lefttmost nb bytes of VSR[XT], and the contents of the rightmost 16-nb bytes",
      "of VSR[XT] are set to 0x00.",
      "",
      "",
      "Otherwise, the contents of the quadword in storage at address",
      "EA are placed into VSR[XT].",
      "",
      "",
      "Data is loaded from storage into VSR[XT] in Big-Endian",
      "byte ordering (i.e., the byte in storage at address EA is",
      "placed into byte element 0 of VSR[XT], the byte in",
      "storage at address EA+1 is placed in byte element 1 of",
      "VSR[XT], and so forth).",
      "",
      "",
      "If the contents of bits 8:63 of GPR[RB] are not equal to",
      "0, the results are boundedly undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Paired",
        "form": "DQ",
        "mnemonic": "lxvp",
        "operands": [
          "XTp",
          "DQ(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "6",
            "size": "6"
          },
          {
            "name": "Tp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DQ",
            "size": "12"
          },
          {
            "name": "0",
            "size": "4"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Load VSX Vector Paired",
        "form": "8LS:D",
        "mnemonic": "plxvp",
        "operands": [
          "XTp",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "58",
            "size": "6"
          },
          {
            "name": "Tp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XTp be the value 32TX +",
      "2Tp (i.e., only even values of XTp can be",
      "encoded in the instruction).",
      "",
      "Let EAbase be the contents of GPR[RA], or 0",
      "if RA=0.",
      "",
      "For lxvp, let the effective address (EA) be",
      "the sum of the integer value in GPR[RA], or 0 if",
      "RA=0, and the value DQ||0b0000,",
      "sign-extended to 64 bits.",
      "",
      "For plxvp, if R=0, let the effective address",
      "(EA) be the sum of the integer value in GPR[RA], or 0 if RA=0, and the value d0||d1, sign-extended to 64 bits.",
      "",
      "For plxvp, if R=1, let the effective address",
      "(EA) be the sum of the address of the instruction and the",
      "value d0||d1, sign-extended to 64 bits.",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "octword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "octword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "Bits 0-127 of load_data are placed into VSR[XTp].",
      "",
      "Bits 128-255 of load_data is placed into VSR[XTp+1].",
      "",
      "For plxvp, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Paired Indexed",
        "form": "X",
        "mnemonic": "lxvpx",
        "operands": [
          "XTp",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "Tp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "333",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XTp be the value 32TX +",
      "2Tp (i.e., only even values of XTp can be",
      "encoded in the instruction).",
      "",
      "Let the effective address (EA) be the sum of the integer",
      "value in GPR[RA], or 0 if RA=0, and the",
      "integer value in GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "octword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "octword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "Bits 0-127 of load_data are placed into VSR[XTp].",
      "",
      "Bits 128-255 of load_data is placed into VSR[XTp+1].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Rightmost Byte Indexed",
        "form": "X",
        "mnemonic": "lxvrbx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "13",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value of 32TX + T.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "Load the contents of the byte in storage at address EA",
      "into byte element 15 of VSR[XT].",
      "The contents of byte elements 0-14 of VSR[XT] are set to",
      "0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Rightmost Doubleword Indexed",
        "form": "X",
        "mnemonic": "lxvrdx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "109",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value of 32TX + T.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "Load the contents of the doubleword in storage at address EA into doubleword element 1 of VSR[XT].",
      "The contents of doubleword element 0 of VSR[XT] are set",
      "to 0.",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is placed into doubleword element 1 of",
      "VSR[XT].",
      "The contents of doubleword element 0 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Rightmost Halfword Indexed",
        "form": "X",
        "mnemonic": "lxvrhx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "45",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value of 32TX + T.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "halfword in storage at address EA are placed into",
      "loaddata in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "halfword in storage at address EA are placed into",
      "loaddata in such an order that;",
      "",
      "",
      "",
      "load_data is placed into halfword element 7 of",
      "VSR[XT].",
      "The contents of halfword elements 0-6 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Rightmost Word Indexed",
        "form": "X",
        "mnemonic": "lxvrwx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "77",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value of 32TX + T.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "load_data is placed into word element 3 of VSR[XT].",
      "The contents of word elements 0-2 of VSR[XT] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Indexed",
        "form": "X",
        "mnemonic": "lxvx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "4",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "12",
            "size": "5"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "quadword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "quadword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is placed into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Doubleword  Splat Indexed",
        "form": "X",
        "mnemonic": "lxvdsx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "332",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "doubleword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is copied into each doubleword element of",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Halfword*8 Indexed",
        "form": "X",
        "mnemonic": "lxvh8x",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "812",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Word*4 Indexed",
        "form": "X",
        "mnemonic": "lxvw4x",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "780",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA+4i are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "word in storage at address EA+4i are placed",
      "into word element i of VSR[XT] in such an",
      "order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "load_data is placed into word element i of",
      "VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load VSX Vector Word  Splat Indexed",
        "form": "X",
        "mnemonic": "lxvwsx",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "364",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, the contents of the word",
      "in storage at address EA are placed into load_data in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of the",
      "quadword in storage at address EA are placed into",
      "load_data in such an order that;",
      "",
      "",
      "",
      "load_data is copied into each word element of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar Doubleword",
        "form": "DS",
        "mnemonic": "stxsd",
        "operands": [
          "VRS",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "2",
            "size": "2"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Store VSX Scalar Doubleword",
        "form": "8LS:D",
        "mnemonic": "pstxsd",
        "operands": [
          "VRS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "46",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value VRS + 32.",
      "",
      "For stxsd, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
      "",
      "For pstxsd with R=0, let the",
      "effective address (EA) be the sum of the contents of",
      "register RA, or the value 0 if RA=0, and the",
      "value d0||d1, sign-extended to 64 bits.",
      "",
      "For pstxsd with R=1, let the",
      "effective address (EA) be the sum of the address of the",
      "instruction and the value d0||d1,",
      "sign-extended to 64 bits.",
      "",
      "Let store_data be the contents of doubleword element 0",
      "of VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the doubleword in storage at address EA in such",
      "order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the doubleword in storage at address EA in",
      "such order that;",
      "",
      "",
      "",
      "For pstxsd, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar Doubleword Indexed",
        "form": "X",
        "mnemonic": "stxsdx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "716",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "Let store_data be the contents of doubleword element 0",
      "of VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the doubleword in storage at address EA in such",
      "order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the doubleword in storage at address EA in",
      "such order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar as Integer Byte Indexed",
        "form": "X",
        "mnemonic": "stxsibx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "909",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be sum of the contents of",
      "GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "The contents of byte element 7 of VSR[XS] are placed into",
      "the byte in storage addressed by EA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar as Integer Halfword Indexed",
        "form": "X",
        "mnemonic": "stxsihx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "941",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be sum of the contents of",
      "GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "The contents of halfword element 3 of VSR[XS] are placed",
      "into the halfword in storage addressed by EA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar as Integer Word Indexed",
        "form": "X",
        "mnemonic": "stxsiwx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "140",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "Let store_data be the contents of word element 1 of",
      "VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the word in storage at address EA in such order",
      "that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the word in storage at address EA in such",
      "order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar Single-Precision",
        "form": "DS",
        "mnemonic": "stxssp",
        "operands": [
          "VRS",
          "DS(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DS",
            "size": "14"
          },
          {
            "name": "3",
            "size": "2"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Store VSX Scalar Single-Precision",
        "form": "8LS:D",
        "mnemonic": "pstxssp",
        "operands": [
          "VRS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "47",
            "size": "6"
          },
          {
            "name": "VRS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value VRS + 32.",
      "",
      "For stxssp, let the effective address (EA) be the sum of the contents of register RA, or the",
      "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
      "",
      "For pstxssp with R=0, let the",
      "effective address (EA) be the sum of the contents of",
      "register RA, or the value 0 if RA=0, and the",
      "value d0||d1, sign-extended to 64 bits.",
      "",
      "For pstxssp with R=1, let the",
      "effective address (EA) be the sum of the address of the",
      "instruction and the value d0||d1,",
      "sign-extended to 64 bits.",
      "",
      "Let store_data be the double-precision floating-point",
      "value in doubleword element 0 of VSR[XS] converted to",
      "single-precision format",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the word in storage at address EA in such order",
      "that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the word in storage at address EA in such",
      "order that;",
      "",
      "",
      "",
      "For pstxssp, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Scalar Single-Precision Indexed",
        "form": "X",
        "mnemonic": "stxsspx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "652",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "Let store_data be the double-precision floating-point",
      "value in doubleword element 0 of VSR[XS] converted to",
      "single-precision format",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the word in storage at address EA in such order",
      "that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the word in storage at address EA in such",
      "order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector",
        "form": "DQ",
        "mnemonic": "stxv",
        "operands": [
          "XS",
          "DQ(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "61",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DQ",
            "size": "12"
          },
          {
            "name": "SX",
            "size": "1"
          },
          {
            "name": "5",
            "size": "3"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "Prefixed Store VSX Vector",
        "form": "8LS:D",
        "mnemonic": "pstxv",
        "operands": [
          "XS",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "imm18",
            "size": "18"
          },
          {
            "name": "27",
            "size": "5"
          },
          {
            "name": "SX",
            "size": "1"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX +",
      "S.",
      "",
      "For stxv, let the effective address (EA) be the sum of the contents of GPR[RA], or the value",
      "0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
      "",
      "For pstxv with R=0, let the effective",
      "address (EA) be the sum of the contents of GPR[RA], or the value 0 if RA=0, and the value",
      "d0||d1, sign-extended to 64 bits.",
      "",
      "For pstxv with R=1, let the effective",
      "address (EA) be the sum of the address of the instruction",
      "and the value d0||d1, sign-extended to 64",
      "bits.",
      "",
      "Let store_data be the contents of VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the quadword in storage at address EA in such",
      "an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the quadword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "For pstxv, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Byte*16 Indexed",
        "form": "X",
        "mnemonic": "stxvb16x",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1004",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "For each integer value from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of byte element i of VSR[XS] are",
      "placed into the byte in storage at address EA+i.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Doubleword*2 Indexed",
        "form": "X",
        "mnemonic": "stxvd2x",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "972",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let store_data be the contents of doubleword element",
      "i of VSR[XS].",
      "",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the doubleword in storage at address EA+8i in such order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the doubleword in storage at address EA+8i in such order that;",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Halfword*8 Indexed",
        "form": "X",
        "mnemonic": "stxvh8x",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "940",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "For each integer value from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of byte element i of VSR[XS] are",
      "placed into the byte in storage at address EA+i.",
      "",
      "",
      "For each integer value from 0 to 7, do the following.",
      "",
      "",
      "",
      "When Big-Endian byte ordering is employed, the contents of halfword",
      "element i of VSR[XS] are placed into the",
      "halfword in storage at address EA+2i in such an",
      "order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, the contents of",
      "halfword element i of VSR[XS] are placed into",
      "the halfword in storage at address EA+2i in",
      "such an order that;",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector with Length",
        "form": "X",
        "mnemonic": "stxvl",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "397",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be the contents of",
      "GPR[RA], or 0 if RA is equal to 0.",
      "",
      "Let nb be the unsigned integer value in bits 0:7 of",
      "GPR[RB].",
      "",
      "If nb is equal to 0, the storage access is not performed.",
      "",
      "Otherwise, when Big-Endian byte-ordering is employed, do the",
      "following.",
      "",
      "",
      "",
      "If nb less than 16, the contents of the",
      "leftmost nb bytes of VSR[XS] are placed in",
      "storage starting at address EA.",
      "",
      "",
      "Otherwise, the contents of VSR[XS] are placed into the",
      "quadword in storage at address EA.",
      "",
      "",
      "Otherwise, when Little-Endian byte ordering is employed, do the",
      "following.",
      "",
      "",
      "",
      "If nb less than 16, the contents of the",
      "rightmost nb bytes of VSR[XS] are placed in",
      "storage starting at address EA in byte-reversed order.",
      "",
      "",
      "Otherwise, the contents of VSR[XS] are placed into the",
      "quadword in storage at address EA in byte-reversed order.",
      "",
      "",
      "If the contents of bits 8:63 of GPR[RB] are not equal to",
      "0, the results are boundedly undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector with Length Left-justified",
        "form": "X",
        "mnemonic": "stxvll",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "429",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be the contents of",
      "GPR[RA], or 0 if RA is equal to 0.",
      "",
      "Let nb be the unsigned integer value in bits 0:7 of GPR[RB].",
      "",
      "If nb is equal to 0, the storage access is not performed.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "If nb less than 16, the contents of the",
      "leftmost nb bytes of VSR[XS] are placed in",
      "storage starting at address EA.",
      "",
      "",
      "Otherwise, the contents of VSR[XS] are placed into the",
      "quadword in storage at address EA.",
      "",
      "",
      "Data is stored from VSR[XS] into storage in Big-Endian",
      "byte ordering (i.e., the contents of byte element 0 of VSR[XS] are placed into the byte in storage at address EA, the contents of byte element 1 of VSR[XS] are placed",
      "into the byte in storage at address EA+1, and so forth).",
      "",
      "",
      "If the contents of bits 8:63 of GPR[RB] are not equal to",
      "0, the results are boundedly undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Rightmost Byte Indexed",
        "form": "X",
        "mnemonic": "stxvrbx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "141",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value of 32SX + S.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "The contents of byte element 15 of VSR[XS] are placed",
      "into storage at address EA.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Rightmost Doubleword Indexed",
        "form": "X",
        "mnemonic": "stxvrdx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "237",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value of 32SX + S.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "Let store_data be the contents of doubleword element 1",
      "of VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the doubleword in storage at address EA in such an order",
      "that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the doubleword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Rightmost Halfword Indexed",
        "form": "X",
        "mnemonic": "stxvrhx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "173",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value of 32SX + S.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "Let store_data be the contents of halfword element 7 of",
      "VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the halfword in storage at address EA in such an order",
      "that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the halfword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Rightmost Word Indexed",
        "form": "X",
        "mnemonic": "stxvrwx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "205",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value of 32SX + S.",
      "",
      "Let EA be the sum of GPR[RA], or 0 if",
      "RA=0, and GPR[RB].",
      "",
      "Let store_data be the contents of word element 3 of",
      "VSR[XS].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the word in storage at address EA in such an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the word in storage at address EA in such",
      "an order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Word*4 Indexed",
        "form": "X",
        "mnemonic": "stxvw4x",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "908",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let EA be the sum of the contents of GPR[RA],",
      "or 0 if RA is equal to 0, and the contents of GPR[RB].",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let store_data be the contents of word element",
      "i of VSR[XS].",
      "",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed in the word in storage at address EA+4i",
      "in such order that;",
      "",
      "",
      "",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed in the word in storage at address EA+4i in such order that;",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Paired",
        "form": "DQ",
        "mnemonic": "stxvp",
        "operands": [
          "XSp",
          "DQ(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "6",
            "size": "6"
          },
          {
            "name": "Sp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "DQ",
            "size": "12"
          },
          {
            "name": "1",
            "size": "4"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Store VSX Vector Paired",
        "form": "8LS:D",
        "mnemonic": "pstxvp",
        "operands": [
          "XSp",
          "D(RA)",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "8",
            "size": "9"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "d0",
            "size": "18"
          },
          {
            "name": "62",
            "size": "6"
          },
          {
            "name": "Sp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "d1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XSp be the value 32SX+2Sp (i.e., only even values of XSp can be encoded in the instruction).",
      "",
      "For stxvp, let the effective address (EA) be",
      "the sum of the integer value in GPR[RA], or 0 if",
      "RA=0 and the value DQ||0b0000,",
      "sign-extended to 64 bits.",
      "",
      "For pstxvp, if R=0, let the effective address",
      "(EA) be the sum of the integer value in GPR[RA], or 0 if RA=0, and the value d0||d1, sign-extended to 64 bits.",
      "",
      "For pstxvp, if R=1, let the effective address",
      "(EA) be the sum of the address of the instruction and the",
      "value d0||d1, sign-extended to 64 bits.",
      "",
      "Let store_data be the contents of VSR[XSp]",
      "concatenated with VSR[XSp+1].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the octword in storage at address EA in such",
      "an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the octword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "For pstxvp, if R is equal to",
      "1 and RA is not equal to 0, the instruction",
      "form is invalid.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Paired Indexed",
        "form": "X",
        "mnemonic": "stxvpx",
        "operands": [
          "XSp",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "Sp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "461",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XSp be the value 32SX +",
      "2Sp (i.e., only even values of XSp can be",
      "encoded in the instruction).",
      "",
      "Let the effective address (EA) be the sum of the integer",
      "value in GPR[RA], or 0 if RA=0, and the",
      "integer value in GPR[RB].",
      "",
      "Let store_data be the contents of VSR[XSp]",
      "concatenated with VSR[XSp+1].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the octword in storage at address EA in such",
      "an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the octword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store VSX Vector Indexed",
        "form": "X",
        "mnemonic": "stxvx",
        "operands": [
          "XS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "S",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "396",
            "size": "10"
          },
          {
            "name": "SX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XS be the value 32SX + S.",
      "",
      "Let the effective address (EA) be the sum of the contents",
      "of GPR[RA], or 0 if RA is equal to 0, and the",
      "contents of GPR[RB].",
      "",
      "When Big-Endian byte ordering is employed, store_data is",
      "placed into the quadword in storage at address EA in such",
      "an order that;",
      "",
      "",
      "",
      "When Little-Endian byte ordering is employed, store_data",
      "is placed into the quadword in storage at address EA in",
      "such an order that;",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Absolute Double-Precision",
        "form": "XX2",
        "mnemonic": "xsabsdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "345",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The absolute value of the double-precision floating-point operand in",
      "doubleword element 0 of VSR[XB] is placed into doubleword",
      "element 0 of VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Absolute Quad-Precision",
        "form": "X",
        "mnemonic": "xsabsqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value VRT + 32.",
      "",
      "Let XB be the value VRB + 32.",
      "",
      "The absolute value of the quad-precision floating-point value in",
      "VSR[XB] is placed into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Add Double-Precision",
        "form": "XX3",
        "mnemonic": "xsadddp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "32",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src2 is added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See Table, Actions for xsadddp, on",
      "pagetable:PPC1ChVSX-Add.",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Add Single-Precision",
        "form": "XX3",
        "mnemonic": "xsaddsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "0",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src2 is added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See Table,",
      "Actions for xsaddsp, on",
      "pagetable:PPC1ChVSX-Table-51-Actions-for-xsaddsp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when rounded.",
      "FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsaddqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "4",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsaddqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "4",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1 or src2 is a Signalling NaN,",
      "an Invalid Operation exception occurs and VXSNAN is set",
      "to 1.",
      "",
      "If src1 and src2 are Infinity values having",
      "opposite signs, an Invalid Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src1 and src2 are Infinity",
      "values having opposite signs, the result is the default Quiet",
      "NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "The normalized sum of src2 added to src1 is",
      "produced with unbounded significand precision and exponent range.",
      "",
      "",
      "See",
      "Table,",
      "Actions for xsaddqp[o], on",
      "pagetable:PPC1ChVSX-Table-5-Actions-for-add-bfp128-src1,src2.",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "The intermediate result is rounded to quad-precision using the",
      "specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Exponents Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpexpdp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "59",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the sum 32AX + A.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "The exponent of src1 is compared with the exponent of",
      "src2.",
      "The result of the compare is placed into FPCC and",
      "CR field BF.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Exponents Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpexpqp",
        "operands": [
          "BF",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "164",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "The exponent of src1 is compared with the exponent of",
      "src2 as unsigned integer values.",
      "The result of the compare is placed into FPCC and",
      "CR field BF.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Equal Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpeqdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, equal.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to",
      "0xFFFF_FFFF_FFFF_FFFF if src1 is equal to",
      "src2, and are set to 0x0000_0000_0000_0000",
      "otherwise.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to",
      "0x0000_0000_0000_0000.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Equal Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpeqqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "68",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let src1 be the quad-precision floating-point value in",
      "VSR[VRA+32].",
      "",
      "Let src2 be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, equal.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "src1 is equal to src2, and are set to all 0s",
      "otherwise.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Greater Than or Equal Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpgedp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "19",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, greater than or equal.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to",
      "0xFFFF_FFFF_FFFF_FFFF if src1 is greater",
      "than or equal to src2, and are set to 0x0000_0000_0000_0000 otherwise.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to",
      "0x0000_0000_0000_0000.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Greater Than or Equal Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpgeqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "196",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let src1 be the quad-precision floating-point value in",
      "VSR[VRA+32].",
      "",
      "Let src2 be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, greater than or equal.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "src1 is greater than or equal to src2, and",
      "are set to all 0s otherwise.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Greater Than Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpgtdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "11",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, greater than.",
      "",
      "The contents of doubleword 0 of VSR[VRT] are set to",
      "0xFFFF_FFFF_FFFF_FFFF if src1 is greater",
      "than src2, and are set to 0x0000_0000_0000_0000 otherwise.",
      "",
      "The contents of doubleword 1 of VSR[VRT] are set to",
      "0x0000_0000_0000_0000.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Greater Than Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpgtqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "228",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let src1 be the quad-precision floating-point value in",
      "VSR[VRA+32].",
      "",
      "Let src2 be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "src1 is compared to src2.",
      "",
      "A NaN compared to any value, including itself, compares false for the",
      "predicate, greater than.",
      "",
      "The contents of VSR[VRT+32] are set to all 1s if",
      "src1 is greater than src2, and are set to all",
      "0s otherwise.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Ordered Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpodp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "43",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is compared to src2.",
      "",
      "Zeros of same or opposite signs compare equal.",
      "",
      "Infinities of same signs compare equal.",
      "",
      "See Table, Actions for xscmpodp -",
      "Part 1: Compare Ordered, on pagetable:PPC1ChVSX-Compare.",
      "",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "If either of the operands is a NaN, either quiet or signaling, CR",
      "field BF and the FPCC are set to reflect",
      "unordered.",
      "If either of the operands is a Signaling NaN, VXSNAN is",
      "set, and Invalid Operation is disabled (VE=0), VXVC is set.",
      "If neither operand is a Signaling NaN but at least one operand is a",
      "Quiet NaN, VXVC is set.",
      "",
      "See Table, Actions for xscmpodp - Part",
      "2: Result, on pagetable:PPC1ChVSX-Result.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Ordered Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpoqp",
        "operands": [
          "BF",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "132",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "src1 is compared to src2.",
      "",
      "Zeros of same or opposite signs compare equal.",
      "Infinities of same signs compare equal.",
      "",
      "Bit 0 of CR field BF and FL are",
      "set to indicate if src1 is less than src2.",
      "",
      "Bit 1 of CR field BF and FG are",
      "set to indicate if src1 is greater than src2.",
      "",
      "Bit 2 of CR field BF and FE are",
      "set to indicate if src1 is equal to src2.",
      "",
      "Bit 3 of CR field BF and FU are",
      "set to indicate unordered (i.e., src1 or src2",
      "is a NaN).",
      "",
      "If either of the operands is a NaN, either quiet or signaling, CR",
      "field BF and the FPCC are set to reflect",
      "unordered.",
      "If either of the operands is a Signaling NaN, an Invalid Operation",
      "exception occurs and VXSNAN is set, and if Invalid",
      "Operation exceptions are disabled (VE=0), VXVC is set.",
      "If neither operand is a Signaling NaN but at least one operand is a",
      "Quiet NaN, an Invalid Operation exception occurs and VXVC",
      "is set.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Unordered Double-Precision",
        "form": "XX3",
        "mnemonic": "xscmpudp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is compared to src2.",
      "",
      "Zeros of same or opposite signs compare equal equal.",
      "",
      "Infinities of same signs compare equal.",
      "",
      "See Table, Actions for",
      "xscmpudp - Part 1: Compare Unordered, on",
      "pagetable:PPC1ChVSX-Compare-Unordered.",
      "",
      "The result of the compare is placed into CR field BF and",
      "the FPCC.",
      "",
      "If either of the operands is a NaN, either quiet or signaling, CR",
      "field BF and the FPCC are set to reflect",
      "unordered.",
      "If either of the operands is a Signaling NaN, VXSNAN is",
      "set.",
      "",
      "See Table, Actions for xscmpudp -",
      "Part 2: Result, on pagetable:PPC1ChVSX-Result-l1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Compare Unordered Quad-Precision",
        "form": "X",
        "mnemonic": "xscmpuqp",
        "operands": [
          "BF",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "644",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "src1 is compared to src2.",
      "",
      "Zeros of same or opposite signs compare equal.",
      "Infinities of same signs compare equal.",
      "",
      "Bit 0 of CR field BF and FL are",
      "set to indicate if src1 is less than src2.",
      "",
      "Bit 1 of CR field BF and FG are",
      "set to indicate if src1 is greater than src2.",
      "",
      "Bit 2 of CR field BF and FE are",
      "set to indicate if src1 is equal to src2.",
      "",
      "Bit 3 of CR field BF and FU are",
      "set to indicate unordered (i.e., src1 or src2",
      "is a NaN).",
      "",
      "If either of the operands is a Signaling NaN, an Invalid Operation",
      "exception occurs and VXSNAN is set to 1.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Copy Sign Double-Precision",
        "form": "XX3",
        "mnemonic": "xscpsgndp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "176",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Bit 0 of VSR[XT] is set to the contents of bit 0 of",
      "VSR[XA].",
      "",
      "Bits 1:63 of VSR[XT] are set to the contents of bits 1:63",
      "of VSR[XB].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Copy Sign Quad-Precision",
        "form": "X",
        "mnemonic": "xscpsgnqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "100",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "src2 is placed into VSR[VRT+32] with the sign",
      "of src1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Double-Precision to Half-Precision format",
        "form": "XX2",
        "mnemonic": "xscvdphp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "17",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "347",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is an SNaN, the result is the half-precision",
      "representation of that SNaN converted to a QNaN.",
      "",
      "Otherwise, if src is a QNaN, the result is the",
      "half-precision representation of that QNaN.",
      "",
      "Otherwise, if src is an Infinity, the result is the",
      "half-precision representation of Infinity with the same sign as",
      "src.",
      "",
      "Otherwise, if src is a Zero, the result is the",
      "half-precision representation of Zero with the same sign as",
      "src.",
      "",
      "Otherwise, the result is the half-precision representation of",
      "src rounded to half-precision using the rounding mode",
      "specified by RN.",
      "",
      "The result is zero-extended and placed into doubleword element",
      "0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in half-precision.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Double-Precision to Quad-Precision format",
        "form": "X",
        "mnemonic": "xscvdpqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "22",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the floating-point value in doubleword element",
      "0 of VSR[VRB+32] represented in double-precision format.",
      "",
      "src is placed into VSR[VRT+32] in",
      "quad-precision format.",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN is set to 1.",
      "",
      "FPRF is set to the class and sign of the result.",
      "",
      "FR is set to 0. FI is set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[XT] and FPRF are not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Double-Precision to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xscvdpsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "265",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is a SNaN, the result is src converted",
      "to a QNaN (i.e., bit 12 of src is set to",
      "1). VXSNAN is set to 1.",
      "",
      "Otherwise, if src is a QNaN, an Infinity, or a Zero, the",
      "result is src.",
      "",
      "Otherwise, the result is src rounded to single-precision",
      "using the rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into word elements 0 and 1 of",
      "VSR[XT] in single-precision format.",
      "",
      "The contents of word elements 2 and 3 of",
      "VSR[XT] are set to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Scalar Single-Precision to Vector Single-Precision format Non-signalling",
        "form": "XX2",
        "mnemonic": "xscvdpspn",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "267",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the single-precision floating-point value in",
      "doubleword element 0 of VSR[XB] represented",
      "in double-precision format.",
      "",
      "src is placed into word elements 0 and 1 of",
      "VSR[XT] in single-precision format.",
      "",
      "The contents of word elements 2 and 3 of",
      "VSR[XT] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Double-Precision to Signed Doubleword format",
        "form": "XX2",
        "mnemonic": "xscvdpsxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "344",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to",
      "1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "If a trap-enabled invalid operation exception occurs,",
      "",
      "",
      "",
      "Otherwise,",
      "",
      "",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Double-Precision to Signed Word format",
        "form": "XX2",
        "mnemonic": "xscvdpsxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "88",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point",
      "integer using the rounding mode Round Toward Zero.",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "If a trap-enabled invalid operation exception occurs,",
      "",
      "",
      "",
      "Otherwise,",
      "",
      "",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Doubleword format",
        "form": "XX2",
        "mnemonic": "xscvdpuxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "328",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also",
      "set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "Otherwise, if the rounded value is less than 0, the result is",
      "0x0000_0000_0000_0000 and VXCVI is set to",
      "1.",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "If a trap-enabled invalid operation exception occurs,",
      "",
      "",
      "",
      "Otherwise,",
      "",
      "",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Word format",
        "form": "XX2",
        "mnemonic": "xscvdpuxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "72",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF and VXCVI is set to 1.",
      "",
      "Otherwise, if the rounded value is less than 0, the result is",
      "0x0000_0000 and VXCVI is set to 1.",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "If a trap-enabled invalid operation exception occurs,",
      "",
      "",
      "",
      "Otherwise,",
      "",
      "",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Half-Precision to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xscvhpdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "16",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "347",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the half-precision floating-point value in the",
      "rightmost halfword of doubleword element 0 of VSR[XB].",
      "",
      "If src is an SNaN, the result is the double-precision",
      "representation of that SNaN converted to a QNaN.",
      "",
      "Otherwise, if src is a QNaN, the result is the",
      "double-precision representation of that QNaN.",
      "",
      "Otherwise, if src is an Infinity, the result is the",
      "double-precision representation of Infinity with the same sign as",
      "src.",
      "",
      "Otherwise, if src is a Zero, the result is the",
      "double-precision representation of Zero with the same sign as",
      "src.",
      "",
      "Otherwise, if src is a denormal value, the result is the",
      "normalized double-precision representation of src.",
      "",
      "Otherwise, the result is the double-precision representation of",
      "src.",
      "",
      "The result is placed into doubleword element 0 of",
      "VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in double-precision format.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified.",
      "",
      "FR is set to 0. FI is set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [using round to Odd]",
        "form": "X",
        "mnemonic": "xscvqpdp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [using round to Odd]",
        "form": "X",
        "mnemonic": "xscvqpdpo",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "20",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN is set to 1.",
      "",
      "If src is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to the Signalling NaN, with the significand truncated",
      "to the rounding precision.",
      "",
      "Otherwise, if src is a Quiet NaN, then the result is",
      "src with the significand truncated to double-precision.",
      "",
      "Otherwise, if src is an Infinity or a Zero, the result is",
      "src.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "If src is Tiny (i.e., the unbiased exponent is",
      "less than -1022) and UE=0, the significand is",
      "shifted right N bits, where N is the",
      "difference between -1022 and the unbiased exponent of",
      "src.",
      "The exponent of src is set to the value -1022.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to double-precision (i.e., 11-bit exponent range and",
      "53-bit significand precision) using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in double-precision format.",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in double-precision format.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Doubleword format",
        "form": "X",
        "mnemonic": "xscvqpsdz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is 0x8000_0000_0000_0000.",
      "",
      "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "0x7FFF_FFFF_FFFF_FFFF.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "0x8000_0000_0000_0000.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0x7FFF_FFFF_FFFF_FFFF.",
      "",
      "",
      "Otherwise, if rnd is less than -2, an Invalid Operation",
      "exception occurs, VXCVI is set to 1, and the result is",
      "0x8000_0000_0000_0000.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table, Actions for",
      "xscvdpsxds, on",
      "pagetable:PPC1ChVSX-Actions-for-xscvdpsxds.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Quadword",
        "form": "X",
        "mnemonic": "xscvqpsqz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "8",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is -2.",
      "",
      "Otherwise, if src is a Zero, the result is 0.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "2-1.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "-2.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 2.",
      "",
      "",
      "Otherwise, if rnd is less than -2, an Invalid Operation",
      "exception occurs, VXCVI is set to 1, and the result is",
      "-2.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table,",
      "Actions for xscvqpsqz, on",
      "pagetable:PPC1ChVSX-Table-2-Actions-for-xscvqpsdz.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Word format",
        "form": "X",
        "mnemonic": "xscvqpswz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "9",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is 0xFFFF_FFFF_8000_0000.",
      "",
      "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is a Infinity, the result",
      "is 0x0000_0000_7FFF_FFFF.",
      "",
      "Otherwise, if src is a Infinity, the result",
      "is 0xFFFF_FFFF_8000_0000.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0x0000_0000_7FFF_FFFF.",
      "",
      "",
      "Otherwise, if rnd is less than -2, an Invalid Operation",
      "exception occurs, VXCVI is set to 1, and the result is",
      "0xFFFF_FFFF_8000_0000.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table,",
      "Actions for xscvqpswz, on",
      "pagetable:PPC1ChVSX-Table-14-@@@Actions-for-xscvqpsdz.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Doubleword format",
        "form": "X",
        "mnemonic": "xscvqpudz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "17",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is a positive Infinity, the result is",
      "0xFFFF_FFFF_FFFF_FFFF.",
      "",
      "Otherwise, if src is a negative Infinity, the result is",
      "0x0000_0000_0000_0000.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0xFFFF_FFFF_FFFF_FFFF.",
      "",
      "",
      "Otherwise, if rnd is less than 0, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0x0000_0000_0000_0000.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in unsigned integer format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table,",
      "Actions for xscvqpudz, on",
      "pagetable:PPC1ChVSX-Table-20-Actions-for-xscvqpud.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword",
        "form": "X",
        "mnemonic": "xscvqpuqz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is 0.",
      "",
      "Otherwise, if src is a Zero, the result is 0.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "2-1.",
      "",
      "Otherwise, if src is Infinity, the result is",
      "0.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is +2-1.",
      "",
      "",
      "Otherwise, if rnd is less than 0, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into VSR[VRT+32] in unsigned integer",
      "format.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table,",
      "Actions for xscvqpudz, on",
      "pagetable:PPC1ChVSX-Table-20-Actions-for-xscvqpud.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Word format",
        "form": "X",
        "mnemonic": "xscvqpuwz",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN and VXCVI are set",
      "to 1.",
      "",
      "If src is a Quiet NaN or an Infinity, an Invalid",
      "Operation exception occurs and VXCVI is set to 1.",
      "",
      "If src is a NaN, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
      "",
      "Otherwise, if src is a positive Infinity, the result is",
      "0x0000_0000_FFFF_FFFF.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "Let rnd be the value src truncated to a",
      "floating-point integer.",
      "",
      "",
      "If rnd is greater than +2-1, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0x0000_0000_FFFF_FFFF.",
      "",
      "",
      "Otherwise, if rnd is less than 0, an Invalid",
      "Operation exception occurs, VXCVI is set to 1, and the",
      "result is 0x0000_0000_0000_0000.",
      "",
      "",
      "Otherwise, the result is the value rnd, and an Inexact",
      "exception occurs if rnd is inexact (i.e., rnd",
      "is not equal to src).",
      "",
      "",
      "The result is placed into doubleword element 0 of VSR[VRT+32] in unsigned integer format.",
      "",
      "The contents of doubleword element 1 of VSR[VRT+32] are",
      "set to 0.",
      "",
      "FPRF is set to undefined. FR is set to 0.",
      "FI is set to indicate if the rounded result is inexact.",
      "",
      "If an Invalid Operation exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "See Table,",
      "Actions for xscvqpuwz, on",
      "pagetable:PPC1ChVSX-Table-16-@@@Actions-for-xscvqpuwz.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Single-Precision to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xscvspdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "329",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the single-precision floating-point value in",
      "word element 0 of VSR[XB].",
      "",
      "If src is a SNaN, the result is src,",
      "converted to a QNaN (i.e., bit 9 of src set",
      "to 1). VXSNAN is set to 1.",
      "",
      "Otherwise, the result is src.",
      "",
      "The result is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0.",
      "FI is set to 0.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified, FPRF is not modified,",
      "FR is set to 0, and FI is set to",
      "0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Single-Precision to Double-Precision format Non-signalling",
        "form": "XX2",
        "mnemonic": "xscvspdpn",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "331",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the single-precision floating-point value in",
      "word element 0 of VSR[XB].",
      "",
      "src is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Signed Quadword to Quad-Precision",
        "form": "X",
        "mnemonic": "xscvsqqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "11",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the 128-bit signed integer value in VSR[VRB+32].",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to quad-precision using the rounding mode specified",
      "by RN.",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Signed Doubleword to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xscvsxddp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "376",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the signed integer value in doubleword element",
      "0 of VSR[XB].",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to double-precision using the rounding mode",
      "specified by RN.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Signed Doubleword to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xscvsxdsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "312",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the twos-complement integer value in doubleword element 0",
      "of VSR[XB].",
      "",
      "src is converted to floating-point format, and rounded to",
      "single-precision using the rounding mode specified by RN.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Signed Doubleword to Quad-Precision format",
        "form": "X",
        "mnemonic": "xscvsdqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "10",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the signed integer value in doubleword element",
      "0 of VSR[VRB+32].",
      "",
      "src is placed into VSR[VRT+32] in",
      "quad-precision floating-point format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert Unsigned Doubleword to Quad-Precision format",
        "form": "X",
        "mnemonic": "xscvudqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the unsigned integer value in doubleword",
      "element 0 of VSR[VRB+32].",
      "",
      "src is placed into VSR[VRT+32] in",
      "quad-precision floating-point format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Unsigned Quadword to Quad-Precision format",
        "form": "X",
        "mnemonic": "xscvuqqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "3",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "836",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the 128-bit unsigned integer value in",
      "VSR[VRB+32].",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to quad-precision using the rounding mode specified",
      "by RN.",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Unsigned Doubleword to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xscvuxddp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "360",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the unsigned integer value in doubleword",
      "element 0 of VSR[XB].",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to double-precision using the rounding mode",
      "specified by RN.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Convert with round Unsigned Doubleword to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xscvuxdsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "296",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the unsigned-integer value in doubleword element 0 of",
      "VSR[XB].",
      "",
      "src is converted to floating-point format, and rounded to",
      "single-precision using the rounding mode specified by RN.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Divide Double-Precision",
        "form": "XX3",
        "mnemonic": "xsdivdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "56",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is divided by",
      "src2, producing a quotient having unbounded range and",
      "precision.",
      "",
      "The quotient is normalized.",
      "",
      "See  (p. table:PPC1ChVSX-Divide).",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when rounded.",
      "FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Divide Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsdivqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "548",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Divide Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsdivqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "548",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1 or src2 is a Signalling NaN,",
      "an Invalid Operation exception occurs and VXSNAN is set",
      "to 1",
      "",
      "If src1 and src2 are Infinity values, an",
      "Invalid Operation exception occurs and VXIDI is set to 1.",
      "",
      "If src1 and src2 are Zero values, an Invalid",
      "Operation exception occurs and VXZDZ is set to 1.",
      "",
      "If src1 is a finite value and src2 is a Zero",
      "value, an Zero Divide exception occurs and ZX is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src1 and src2 are Infinity",
      "values, or if src1 and src2 are Zero values,",
      "the result is the default Quiet NaN.",
      "",
      "Otherwise, if src1 is a non-zero value and src2 is a Zero value, the result is an Infinity.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "The normalized quotient of src1 divided by src2 is produced with unbounded significand precision and exponent",
      "range.",
      "",
      "",
      "See",
      "Table,",
      "Actions for xsdivqp[o], on",
      "pagetable:PPC1ChVSX-Table-9-Actions-for-divide-bfp128-src1,src2.",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-disabled Zero Divide exception occurs, FR and",
      "FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception or a trap-enabled Zero",
      "Divide exception occurs, VSR[VRT+32] and FPRF",
      "are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Divide Single-Precision",
        "form": "XX3",
        "mnemonic": "xsdivsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "24",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is divided by",
      "src2, producing a quotient having unbounded range and",
      "precision.",
      "",
      "The quotient is normalized.",
      "",
      "See Table,",
      "Actions for xsdivsp, on",
      "pagetable:PPC1ChVSX-Table-62-Actions-for-xsdivsp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Insert Exponent Double-Precision",
        "form": "X",
        "mnemonic": "xsiexpdp",
        "operands": [
          "XT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "918",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let src1 be the unsigned integer value in GPR[RA].",
      "",
      "Let src2 be the unsigned integer value in GPR[RB].",
      "",
      "The contents of bit 0 of src1 are placed into bit 0 of",
      "VSR[XT].",
      "",
      "The contents of bits 53:63 of src2 are placed into bits",
      "1:11 of VSR[XT].",
      "",
      "The contents of bits 12:63 of src1 are placed into bits",
      "12:63 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Insert Exponent Quad-Precision",
        "form": "X",
        "mnemonic": "xsiexpqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "868",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "The contents of bit 0 of VSR[VRA+32] are placed into bit",
      "0 of VSR[VRT+32].",
      "",
      "The contents of bit 49:63 of doubleword element 0 of VSR[VRB+32] are placed into bits 1:15 of VSR[VRT+32].",
      "",
      "The contents of bit 16:127 of VSR[VRA+32] are placed into",
      "bits 16:127 of VSR[VRT+32].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Add Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmaddadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "33",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Scalar Multiply-Add Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmaddmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "41",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "For xsmaddadp, do the following.",
      "",
      "",
      "",
      "For xsmaddmdp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of Table .",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Add Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xsmaddasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "1",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "VSX Scalar Multiply-Add Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xsmaddmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "9",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For xsmaddasp, do the following.",
      "",
      "",
      "",
      "For xsmaddmsp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of",
      "Table,",
      "Actions for xsmadd(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-64-Actions-for-xsmadd-a|m-sp.",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of",
      "Table,",
      "Actions for xsmadd(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-64-Actions-for-xsmadd-a|m-sp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT] in",
      "double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmaddqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "388",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Multiply-Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmaddqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "388",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
      "",
      "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1, src2, or src3 is",
      "a Signalling NaN, an Invalid Operation exception occurs and",
      "VXSNAN is set to 1.",
      "",
      "If src1 is an Infinity value and src3 is a",
      "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
      "VXIMZ is set to 1.",
      "",
      "If src2 and the product of src1 and",
      "src3 are Infinity values having opposite signs, an",
      "Invalid Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src3 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src3.",
      "",
      "Otherwise, if src3 is a Quiet NaN, the result is",
      "src3.",
      "",
      "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
      "src3 is an Infinity value, the result is the default",
      "Quiet NaN.",
      "",
      "Otherwise, if the product of src1 and src3,",
      "and src2 are Infinity values having opposite signs, the",
      "result is the default Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a",
      "product having unbounded significand precision and exponent range.",
      "",
      "",
      "See part 1 of Table.",
      "\"Actions for xsmadd(a|m)dp\".",
      "",
      "",
      "src2 is added to the product, producing a sum having",
      "unbounded range and precision.",
      "",
      "",
      "See part 2 of Table.",
      "\"Actions for xsmadd(a|m)dp\".",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Maximum Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmaxdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "160",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src1 is greater than src2, src1 is placed into doubleword element 0 of VSR[XT].",
      "Otherwise, src2 is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "The maximum of +0 and -0 is +0.",
      "The maximum of a QNaN and any value is that value.",
      "The maximum of any value and an SNaN is that SNaN converted to a QNaN.",
      "",
      "FPRF, FR and FI are not modified.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified.",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Maximum Type-C Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmaxcdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "128",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If either src1 or src2 is a NaN, result is src2.",
      "",
      "Otherwise, if src1 is greater than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to the",
      "value result.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to 0.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Maximum Type-C Quad-Precision",
        "form": "X",
        "mnemonic": "xsmaxcqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "676",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let src1 be the quad-precision floating-point value in",
      "VSR[VRA+32].",
      "",
      "Let src2 be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If either src1 or src2 is a NaN, result is src2.",
      "",
      "Otherwise, if src1 is greater than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of VSR[VRT+32] are set to the value",
      "result.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Maximum Type-J Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmaxjdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "144",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If src1 is a NaN, result is src1.",
      "",
      "Otherwise, if src2 is a NaN, result is",
      "src2.",
      "",
      "Otherwise, if src1 is a Zero and src2 is a",
      "Zero and either src1 or src2 is a +Zero, the",
      "result is +Zero.",
      "",
      "Otherwise, if src1 is a -Zero and src2 is a",
      "-Zero, the result is -Zero.",
      "",
      "Otherwise, if src1 is greater than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to the",
      "value result.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to 0.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Minimum Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmindp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "168",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "If src1 is less than src2, src1",
      "is placed into doubleword element 0 of VSR[XT] in",
      "double-precision format.",
      "Otherwise, src2 is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "The minimum of +0 and 0 is 0.",
      "The minimum of a QNaN and any value is that value.",
      "The minimum of any value and an SNaN is that SNaN converted to a QNaN.",
      "",
      "FPRF, FR and FI are not modified.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified.",
      "",
      "See Table .",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Minimum Type-C Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmincdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "136",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If either src1 or src2 is a NaN, result is src2.",
      "",
      "Otherwise, if src1 is less than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to the",
      "value result.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to 0.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Minimum Type-C Quad-Precision",
        "form": "X",
        "mnemonic": "xsmincqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "740",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let src1 be the quad-precision floating-point value in",
      "VSR[VRA+32].",
      "",
      "Let src2 be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If either src1 or src2 is a NaN, result is src2.",
      "",
      "Otherwise, if src1 is less than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of VSR[VRT+32] are set to the value",
      "result.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
      "is not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Minimum Type-J Double-Precision",
        "form": "XX3",
        "mnemonic": "xsminjdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "152",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword 0 of VSR[XB].",
      "",
      "If src1 or src2 is a SNaN, an Invalid",
      "Operation exception occurs.",
      "",
      "If src1 is a NaN, result is src1.",
      "",
      "Otherwise, if src2 is a NaN, result is",
      "src2.",
      "",
      "Otherwise, if src1 is a Zero and src2 is a",
      "Zero and either src1 or src2 is a -Zero, the",
      "result is -Zero.",
      "",
      "Otherwise, if src1 is a +Zero and src2 is a",
      "+Zero, the result is +Zero.",
      "",
      "Otherwise, if src1 is less than src2,",
      "result is src1.",
      "",
      "Otherwise, result is src2.",
      "",
      "The contents of doubleword 0 of VSR[XT] are set to the",
      "value result.",
      "",
      "The contents of doubleword 1 of VSR[XT] are set to 0.",
      "",
      "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
      "not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Subtract Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmsubadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "49",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Scalar Multiply-Subtract Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmsubmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "57",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For xsmsubadp, do the following.",
      "",
      "",
      "",
      "For xsmsubmdp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of Table .",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The result, having unbounded range and precision, is",
      "normalized.",
      "",
      "See part 2 of Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when rounded.",
      "FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Subtract Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xsmsubasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "17",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "VSX Scalar Multiply-Subtract Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xsmsubmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "25",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For xsmsubasp, do the following.",
      "",
      "",
      "",
      "For xsmsubmsp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of",
      "Table,",
      "Actions for xsmsub(a|m)sp.",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The result, having unbounded range and precision, is",
      "normalized.",
      "",
      "See part 2 of",
      "Table,",
      "Actions for xsmsub(a|m)sp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply-Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmsubqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "420",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Multiply-Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmsubqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "420",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
      "",
      "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1, src2, or src3 is",
      "a Signalling NaN, an Invalid Operation exception occurs and",
      "VXSNAN is set to 1.",
      "",
      "If src1 is an Infinity value and src3 is a",
      "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
      "VXIMZ is set to 1.",
      "",
      "If src2 and the product of src1 and",
      "src3 are Infinity values having same signs, an Invalid",
      "Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src3 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src3.",
      "",
      "Otherwise, if src3 is a Quiet NaN, the result is",
      "src3.",
      "",
      "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
      "src3 is an Infinity value, the result is the default",
      "Quiet NaN.",
      "",
      "Otherwise, if the product of src1 and src3,",
      "and src2 are Infinity values having same signs, the",
      "result is the default Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a",
      "product having unbounded significand precision and exponent range.",
      "",
      "",
      "See part 1 of",
      "Table.",
      "\"Actions for xsmsubqp[o]\".",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "See part 2 of",
      "Table.",
      "\"Actions for xsmsubqp[o]\".",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply Double-Precision",
        "form": "XX3",
        "mnemonic": "xsmuldp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "48",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is multiplied by src2, producing a product having",
      "unbounded range and precision.",
      "",
      "The product is normalized.",
      "",
      "See Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmulqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "36",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Multiply Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsmulqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "36",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1 or src2 is a Signalling NaN,",
      "an Invalid Operation exception occurs and VXSNAN is set",
      "to 1.",
      "",
      "If src1 is an Infinity value and src2 is a",
      "Zero value, or if src1 is a Zero value and src2 is an Infinity value, an Invalid Operation exception occurs and",
      "VXIMZ is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src1 is an Infinity value and src2 is a Zero value, or if src1 is a Zero value and",
      "src2 is an Infinity value, the result is the default",
      "Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "The normalized product of src1 multiplied by src2 is produced with unbounded significand precision and exponent",
      "range.",
      "",
      "",
      "See",
      "Table.",
      "\"Actions for xsmulqp[o]\".",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Multiply Single-Precision",
        "form": "XX3",
        "mnemonic": "xsmulsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "16",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src1 is multiplied by src2, producing a product having",
      "unbounded range and precision.",
      "",
      "The product is normalized.",
      "",
      "See Table,",
      "Actions for xsmulsp, on",
      "pagetable:PPC1ChVSX-Table-70-Actions-for-xsmulsp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Absolute Double-Precision",
        "form": "XX2",
        "mnemonic": "xsnabsdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "361",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of doubleword element 0 of VSR[XB], with bit",
      "0 set to 1, is placed into doubleword element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Absolute Quad-Precision",
        "form": "X",
        "mnemonic": "xsnabsqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "8",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "The negative absolute value of src is placed into",
      "VSR[VRT+32] in quad-precision format.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negate Double-Precision",
        "form": "XX2",
        "mnemonic": "xsnegdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "377",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of doubleword element 0 of VSR[XB], with bit",
      "0 complemented, is placed into doubleword element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negate Quad-Precision",
        "form": "X",
        "mnemonic": "xsnegqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "16",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "src is negated and placed into VSR[VRT+32] in",
      "quad-precision format.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Add Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xsnmaddadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "161",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Scalar Negative Multiply-Add Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xsnmaddmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "169",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "For xsnmaddadp, do the following.",
      "",
      "",
      "",
      "For xsnmaddmdp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of Table .",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is negated and placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See",
      "Table,",
      "Scalar Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Add Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xsnmaddasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "129",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "VSX Scalar Negative Multiply-Add Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xsnmaddmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "137",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For xsnmaddasp, do the following.",
      "",
      "",
      "",
      "For xsnmaddmsp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of",
      "Table,",
      "Actions for xsnmadd(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-72-Actions-for-xsnmadd-a|m-sp.",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of",
      "Table,",
      "Actions for xsnmadd(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-72-Actions-for-xsnmadd-a|m-sp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is negated and placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See",
      "Table,",
      "Scalar Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsnmaddqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "452",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Negative Multiply-Add Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsnmaddqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "452",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
      "",
      "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1, src2, or src3 is",
      "a Signalling NaN, an Invalid Operation exception occurs and",
      "VXSNAN is set to 1.",
      "",
      "If src1 is an Infinity value and src3 is a",
      "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
      "VXIMZ is set to 1.",
      "",
      "If src2 and the product of src1 and",
      "src3 are Infinity values having opposite signs, an",
      "Invalid Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src3 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src3.",
      "",
      "Otherwise, if src3 is a Quiet NaN, the result is",
      "src3.",
      "",
      "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
      "src3 is an Infinity value, the result is the default",
      "Quiet NaN.",
      "",
      "Otherwise, if the product of src1 and src3,",
      "and src2 are Infinity values having opposite signs, the",
      "result is the default Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a",
      "product having unbounded significand precision and exponent range.",
      "",
      "",
      "See part 1 of Table.",
      "\"Actions for xsmadd(a|m)dp\".",
      "",
      "",
      "src2 is added to the product, producing a sum having",
      "unbounded range and precision.",
      "",
      "",
      "See part 2 of Table.",
      "\"Actions for xsmadd(a|m)dp\".",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into VSR[VRT+32] in",
      "quad-precision format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Subtract Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xsnmsubadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "177",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Scalar Negative Multiply-Subtract Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xsnmsubmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "185",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "For xsnmsubadp, do the following.",
      "",
      "",
      "",
      "For xsnmsubmdp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product",
      "having unbounded range and precision.",
      "",
      "See part 1 of Table .",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is negated and placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See",
      "Table,",
      "Scalar Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Subtract Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xsnmsubasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "145",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      },
      {
        "name": "VSX Scalar Negative Multiply-Subtract Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xsnmsubmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "153",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For xsnmsubasp, do the following.",
      "",
      "",
      "",
      "For xsnmsubmsp, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "See part 1 of",
      "Table,",
      "Actions for xsnmsub(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-75-Actions-for-xsnmsub-a|m-sp.",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "The sum is normalized.",
      "",
      "See part 2 of",
      "Table,",
      "Actions for xsnmsub(a|m)sp, on",
      "pagetable:PPC1ChVSX-Table-75-Actions-for-xsnmsub-a|m-sp.",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is negated and placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when rounded.",
      "FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See",
      "Table,",
      "Scalar Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Negative Multiply-Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsnmsubqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "484",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Negative Multiply-Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xsnmsubqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "484",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
      "",
      "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1, src2, or src3 is",
      "a Signalling NaN, an Invalid Operation exception occurs and",
      "VXSNAN is set to 1.",
      "",
      "If src1 is an Infinity value and src3 is a",
      "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
      "VXIMZ is set to 1.",
      "",
      "If src2 and the product of src1 and",
      "src3 are Infinity values having same signs, an Invalid",
      "Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src3 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src3.",
      "",
      "Otherwise, if src3 is a Quiet NaN, the result is",
      "src3.",
      "",
      "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
      "src3 is an Infinity value, the result is the default",
      "Quiet NaN.",
      "",
      "Otherwise, if the product of src1 and src3,",
      "and src2 are Infinity values having same signs, the",
      "result is the default Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a",
      "product having unbounded significand precision and exponent range.",
      "",
      "",
      "See part 1 of",
      "Table.",
      "\"Actions for xsmsubqp[o]\".",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "See part 2 of",
      "Table.",
      "\"Actions for xsmsubqp[o]\".",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into VSR[VRT+32] in",
      "quad-precision format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FR",
      "and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Double-Precision Integer using round to Nearest Away",
        "form": "XX2",
        "mnemonic": "xsrdpi",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "73",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round to Nearest Away.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Double-Precision Integer exact using Current rounding mode",
        "form": "XX2",
        "mnemonic": "xsrdpic",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "107",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point",
      "value in doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to an integer using the rounding",
      "mode specified by RN.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Double-Precision Integer using round toward -Infinity",
        "form": "XX2",
        "mnemonic": "xsrdpim",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "121",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward -Infinity.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Double-Precision Integer using round toward +Infinity",
        "form": "XX2",
        "mnemonic": "xsrdpip",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "105",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward +Infinity.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Double-Precision Integer using round toward Zero",
        "form": "XX2",
        "mnemonic": "xsrdpiz",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "89",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward Zero.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to 0. FI is set to 0.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Reciprocal Estimate Double-Precision",
        "form": "XX2",
        "mnemonic": "xsredp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "90",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "A double-precision floating-point estimate of the reciprocal of",
      "src is placed into doubleword element 0 of VSR[XT] in double-precision format.",
      "",
      "Unless the reciprocal of src would be a zero, an",
      "infinity, or a QNaN, the estimate has a relative error in precision",
      "no greater than one part in 16384 of the reciprocal of",
      "src. That is,",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to an undefined value.",
      "FI is set to an undefined value.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified.",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Reciprocal Estimate Single-Precision",
        "form": "XX2",
        "mnemonic": "xsresp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "26",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "A single-precision floating-point estimate of the reciprocal of",
      "src is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "Unless the reciprocal of src would be a zero, an",
      "infinity, the result of a trap-disabled Overflow exception, or a",
      "QNaN, the estimate has a relative error in precision no greater than",
      "one part in 16384 of the reciprocal of src.",
      "That is,",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to an undefined value.",
      "FI is set to an undefined value.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified.",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Quad-Precision Integer [with Inexact]",
        "form": "Z23",
        "mnemonic": "xsrqpi",
        "operands": [
          "R",
          "VRT",
          "VRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "EX",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "5",
            "size": "8"
          },
          {
            "name": "X",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Round to Quad-Precision Integer [with Inexact]",
        "form": "Z23",
        "mnemonic": "xsrqpix",
        "operands": [
          "R",
          "VRT",
          "VRB",
          "RMC"
        ],
        "conditions": [
          {
            "field": "EX",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "5",
            "size": "8"
          },
          {
            "name": "X",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let R and RMC specify the rounding mode as",
      "follows.",
      "",
      "",
      "",
      "",
      "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs, VXSNAN is set to 1, and the result is",
      "the Quiet NaN corresponding to the Signalling NaN.",
      "",
      "Otherwise, if src is a Quiet NaN, an Infinity, or a Zero,",
      "then the result is src.",
      "",
      "Otherwise, src is rounded to an integer using the",
      "rounding mode rmode.",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "",
      "For xsrqpi, FR is set to 0, FI is",
      "set to 0, and XX is not set by an Inexact exception.",
      "",
      "For xsrqpix, FR is set to indicate if the",
      "result was incremented when rounded, FI is set to",
      "indicate the result is inexact, and XX is set by an",
      "Inexact exception.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round Quad-Precision to Double-Extended-Precision",
        "form": "Z23",
        "mnemonic": "xsrqpxp",
        "operands": [
          "R",
          "VRT",
          "VRB",
          "RMC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "RMC",
            "size": "2"
          },
          {
            "name": "37",
            "size": "8"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let R and RMC specify the rounding mode as",
      "follows.",
      "",
      "",
      "",
      "",
      "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs, VXSNAN is set to 1, and the result is",
      "the Quiet NaN corresponding to the Signalling NaN, with the",
      "significand truncated to double-extended-precision.",
      "",
      "Otherwise, if src is a Quiet NaN, then the result is",
      "src with the significand truncated to",
      "double-extended-precision.",
      "",
      "Otherwise, if src is an Infinity or a Zero, the result is",
      "src.",
      "",
      "Otherwise, src is rounded to double-extended precision",
      "(i.e., 15-bit exponent range and 64-bit significand precision) using",
      "the specified rounding mode.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Round to Single-Precision",
        "form": "XX2",
        "mnemonic": "xsrsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "281",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src is rounded to single-precision using the rounding mode specified",
      "by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Reciprocal Square Root Estimate Double-Precision",
        "form": "XX2",
        "mnemonic": "xsrsqrtedp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "74",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "A double-precision floating-point  estimate of the reciprocal square",
      "root of src is placed into doubleword element 0 of",
      "VSR[XT] in double-precision format.",
      "",
      "Unless the reciprocal of the square root of src would be",
      "a zero, an infinity, or a QNaN, the estimate has a relative error in",
      "precision no greater than one part in 16384 of the reciprocal of the",
      "square root of src. That is,",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to an undefined value.",
      "FI is set to an undefined value.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified.",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Reciprocal Square Root Estimate Single-Precision",
        "form": "XX2",
        "mnemonic": "xsrsqrtesp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "10",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in doubleword",
      "element 0 of VSR[XB].",
      "",
      "A single-precision floating-point  estimate of the reciprocal square",
      "root of src is placed into doubleword element 0 of VSR[XT] in double-precision format.",
      "",
      "Unless the reciprocal of the square root of src would be a zero, an",
      "infinity, or a QNaN, the estimate has a relative error in precision",
      "no greater than one part in 16384 of the reciprocal of the square",
      "root of src. That is,",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to an undefined value.",
      "FI is set to an undefined value.",
      "",
      "If a trap-enabled invalid operation exception or a trap-enabled zero",
      "divide exception occurs, VSR[XT] and FPRF are",
      "not modified.",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Square Root Double-Precision",
        "form": "XX2",
        "mnemonic": "xssqrtdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "75",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "The unbounded-precision square root of src is produced.",
      "",
      "See Table .",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Square Root Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xssqrtqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "27",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Square Root Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xssqrtqpo",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "27",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If src is a Signalling NaN, an Invalid Operation",
      "exception occurs and VXSNAN is set to 1.",
      "",
      "If src is a negative, non-zero value, an Invalid",
      "Operation exception occurs and VXSQRT is set to 1.",
      "",
      "If src is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src.",
      "",
      "Otherwise, if src is a Quiet NaN, the result is",
      "src.",
      "",
      "Otherwise, if src is a negative value, the result is the",
      "default Quiet NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "The normalized square root of src is produced with",
      "unbounded significand precision and exponent range.",
      "",
      "",
      "See",
      "Table,",
      "Actions for xssqrtqp[o], on",
      "pagetable:PPC1ChVSX-Table-15-Actions-for-bfp128-square-root-src.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Section, Rounding on",
      "pagesec:PPC1ChVSX-Rounding for a description of rounding",
      "modes.",
      "",
      "",
      "If there is loss of precision, an Inexact exception occurs.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Square Root Single-Precision",
        "form": "XX2",
        "mnemonic": "xssqrtsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "11",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "The unbounded-precision square root of src is produced.",
      "",
      "See Table .",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT]",
      "in double-precision format.",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Subtract Double-Precision",
        "form": "XX3",
        "mnemonic": "xssubdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "40",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src2 is negated and added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "See Table .",
      "",
      "The sum is normalized.",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xssubqp",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "516",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      },
      {
        "name": "VSX Scalar Subtract Quad-Precision [using round to Odd]",
        "form": "X",
        "mnemonic": "xssubqpo",
        "operands": [
          "VRT",
          "VRA",
          "VRB"
        ],
        "conditions": [
          {
            "field": "RO",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "VRA",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "516",
            "size": "10"
          },
          {
            "name": "RO",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
      "",
      "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
      "",
      "If either src1 or src2 is a Signalling NaN,",
      "an Invalid Operation exception occurs and VXSNAN is set",
      "to 1.",
      "",
      "If src1 and src2 are Infinity values having",
      "same signs, an Invalid Operation exception occurs and VXISI is set to 1.",
      "",
      "If src1 is a Signalling NaN, the result is the Quiet NaN",
      "corresponding to src1.",
      "",
      "Otherwise, if src1 is a Quiet NaN, the result is",
      "src1.",
      "",
      "Otherwise, if src2 is a Signalling NaN, the result is the",
      "Quiet NaN corresponding to src2.",
      "",
      "Otherwise, if src2 is a Quiet NaN, the result is",
      "src2.",
      "",
      "Otherwise, if src1 and src2 are Infinity",
      "values having same signs, the result is the default Quiet",
      "NaN.",
      "",
      "Otherwise, do the following.",
      "",
      "",
      "",
      "The normalized sum of the negation of src2 added to",
      "src1 is produced with unbounded significand precision and",
      "exponent range.",
      "",
      "",
      "See Table, Actions",
      "for xssubqp[o], on",
      "pagetable:PPC1ChVSX-Table-2-Actions-for-xpsub.",
      "",
      "",
      "If the intermediate result is Tiny (i.e., the unbiased",
      "exponent is less than -16382) and UE=0, the",
      "significand is shifted right N bits, where N",
      "is the difference between -16382 and the unbiased",
      "exponent of the intermediate result.",
      "The exponent of the intermediate result is set to the value",
      "-16382.",
      "",
      "",
      "If RO=1, let the rounding mode be Round to Odd.",
      "Otherwise, let the rounding mode be specified by RN.",
      "Unless the result is an Infinity or a Zero, the intermediate result",
      "is rounded to quad-precision using the specified rounding mode.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into VSR[VRT+32] in quad-precision",
      "format.",
      "",
      "FPRF is set to the class and sign of the result.",
      "FR is set to indicate if the rounded result was",
      "incremented. FI is set to indicate the result is inexact.",
      "",
      "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
      "",
      "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Subtract Single-Precision",
        "form": "XX3",
        "mnemonic": "xssubsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "8",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "src2 is negated and added to src1, producing",
      "the sum, v, having unbounded range and precision.",
      "",
      "See Table,",
      "Actions for xssubsp, on",
      "pagetable:PPC1ChVSX-Table-79-Actions-for-xssubsp.",
      "",
      "v is normalized and rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "The result is placed into doubleword element 0 of VSR[XT].",
      "",
      "The contents of doubleword element 1 of VSR[XT] are set",
      "to 0.",
      "",
      "FPRF is set to the class and sign of the result as",
      "represented in single-precision format.",
      "FR is set to indicate if the result was incremented when",
      "rounded. FI is set to indicate the result is inexact.",
      "",
      "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
      "and FI are set to 0.",
      "",
      "See Table, VSX",
      "Scalar Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Test for software Divide Double-Precision",
        "form": "XX3",
        "mnemonic": "xstdivdp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "61",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src1 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XA].",
      "",
      "Let src2 be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "Let e_a be the unbiased exponent of src1.",
      "",
      "Let e_b be the unbiased exponent of src2.",
      "",
      "fe_flag is set to 1 for any of the following conditions.",
      "",
      "",
      "",
      "Otherwise fe_flag is set to 0.",
      "",
      "fg_flag is set to 1 for any of the following conditions.",
      "",
      "",
      "",
      "Otherwise fg_flag is set to 0.",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Test for software Square Root Double-Precision",
        "form": "XX2",
        "mnemonic": "xstsqrtdp",
        "operands": [
          "BF",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "106",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "Let e_b be the unbiased exponent of src.",
      "",
      "fe_flag is set to 1 for any of the following conditions.",
      "",
      "",
      "",
      "Otherwise fe_flag is set to 0.",
      "",
      "fg_flag is set to 1 for any of the following conditions.",
      "",
      "",
      "",
      "Otherwise fg_flag is set to 0.",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Test Data Class Double-Precision",
        "form": "XX2",
        "mnemonic": "xststdcdp",
        "operands": [
          "BF",
          "XB",
          "DCMX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "DCMX",
            "size": "7"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "362",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign bit of src.",
      "",
      "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
      "",
      "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
      "as represented in double-precision format, matches any of the data",
      "classes specified by DCMX (Data Class Mask).",
      "",
      "",
      "",
      "",
      "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Test Data Class Quad-Precision",
        "form": "X",
        "mnemonic": "xststdcqp",
        "operands": [
          "BF",
          "VRB",
          "DCMX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "DCMX",
            "size": "7"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "708",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "Let the DCMX (Data Class Mask) field specify one or more",
      "of the 7 possible data classes, where each bit corresponds to a",
      "specific data class.",
      "",
      "",
      "",
      "",
      "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign of src.",
      "",
      "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
      "",
      "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
      "as represented in quad-precision format, matches any of the data",
      "classes specified by DCM.",
      "",
      "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Test Data Class Single-Precision",
        "form": "XX2",
        "mnemonic": "xststdcsp",
        "operands": [
          "BF",
          "XB",
          "DCMX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "DCMX",
            "size": "7"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "298",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign bit of src.",
      "",
      "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
      "",
      "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
      "as represented in single-precision format, matches any of the data",
      "classes specified by DCMX (Data Class Mask).",
      "",
      "",
      "",
      "",
      "Bit 3 of CR field BF and bit 3 of FPCC are set to indicate if src is not representable in",
      "single-precision format.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Extract Exponent Double-Precision",
        "form": "XX2",
        "mnemonic": "xsxexpdp",
        "operands": [
          "RT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "347",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "The value of the exponent field in src is placed into",
      "GPR[RT] in unsigned integer format.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Extract Exponent Quad-Precision",
        "form": "X",
        "mnemonic": "xsxexpqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "The contents of the exponent field of src (bits 1:15) are",
      "zero-extended and placed into doubleword 0 of VSR[VRT+32].",
      "",
      "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Extract Significand Double-Precision",
        "form": "XX2",
        "mnemonic": "xsxsigdp",
        "operands": [
          "RT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "347",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element 0 of VSR[XB].",
      "",
      "The significand of src is placed into GPR[RT]",
      "in unsigned integer format.",
      "If src is a normal value, the implicit leading bit is set",
      "to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Scalar Extract Significand Quad-Precision",
        "form": "X",
        "mnemonic": "xsxsigqp",
        "operands": [
          "VRT",
          "VRB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "63",
            "size": "6"
          },
          {
            "name": "VRT",
            "size": "5"
          },
          {
            "name": "18",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "804",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let src be the quad-precision floating-point value in",
      "VSR[VRB+32].",
      "",
      "The significand of src is placed into VSR[VRT+32].",
      "",
      "If the value of the exponent field of src is equal to",
      "0b000_0000_0000_0000 (i.e., Zero or Denormal value) or",
      "0b111_1111_1111_1111 (i.e., Infinity or NaN),",
      "0b0 is placed into bit 15 of VSR[VRT+32].",
      "Otherwise (i.e., Normal value), 0b1 is placed into bit 15",
      "of VSR[VRT+32].",
      "The contents of bits 0:14 of VSR[VRT+32] are set to 0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Absolute Double-Precision",
        "form": "XX2",
        "mnemonic": "xvabsdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "473",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of doubleword element i of VSR[XB], with bit 0 set to 0, is placed into doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Absolute Single-Precision",
        "form": "XX2",
        "mnemonic": "xvabssp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "409",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of word element i of VSR[XB],",
      "with bit 0 set to 0, is placed into word element i of",
      "VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Add Double-Precision",
        "form": "XX3",
        "mnemonic": "xvadddp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "96",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src2 is added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Add Single-Precision",
        "form": "XX3",
        "mnemonic": "xvaddsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "64",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src2 is added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector bfloat16 GER (rank-2 update)",
        "form": "XX3",
        "mnemonic": "xvbf16ger2",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "51",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvbf16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "50",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvbf16ger2pn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "178",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvbf16ger2np",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "114",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvbf16ger2nn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "242",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvbf16ger2",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "51",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvbf16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "50",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvbf16ger2pn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "178",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvbf16ger2np",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "114",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvbf16ger2nn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "242",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of single-precision floating-point values.",
      "",
      "For xvbf16ger2, xvbf16ger2pp, xvbf16ger2pn, xvbf16ger2np, or xvbf16ger2nn,",
      "let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let src10 be",
      "the bfloat16 floating-point value in halfword 0 of word element",
      "i of VSR[XA] and let src20 be the",
      "bfloat16 floating-point value in halfword 0 of word element",
      "j of VSR[XB].",
      "Otherwise, let src10 be the value 0.0 and let src20 be the value 0.0, causing the product of src10 and",
      "src20 to be 0.0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let src11 be",
      "the bfloat16 floating-point value in halfword 1 of word element",
      "i of VSR[XA] and let src21 be the",
      "bfloat16 floating-point value in halfword 1 of word element",
      "j of VSR[XB].",
      "Otherwise, let src11 be the value 0.0 and let src21 be the value 0.0, causing the product of src11 and",
      "src21 to be 0.0.",
      "",
      "",
      "Let prod be the product of src10 and",
      "src20, having infinite precision and unbounded exponent",
      "range.",
      "",
      "",
      "Let psum be the sum of the product, src11",
      "multiplied by src21, and prod, having",
      "infinite precision and unbounded exponent range.",
      "",
      "",
      "Let r1 be the value psum with its significand",
      "rounded to 24-bit precision using the rounding mode specified by",
      "RN, but retaining unbounded exponent range (i.e., cannot",
      "overflow or underflow).",
      "",
      "",
      "For [pm]xvbf16ger2, do the",
      "following.",
      "",
      "",
      "",
      "Let r2 be the value r1 rounded to 24-bit",
      "significand precision and 8-bit exponent range (i.e.,",
      "single-precision) using the rounding mode specified by RN.",
      "",
      "",
      "r2 is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "",
      "For [pm]xvbf16ger2pp, do the",
      "following.",
      "",
      "",
      "",
      "Let v2 be the sum of r1 added to the",
      "single-precision floating-point value in word element j",
      "of ACC[AT][i], having infinite precision and unbounded",
      "exponent range.",
      "",
      "",
      "Let r2 be the value v2 rounded to 24-bit",
      "significand precision and 8-bit exponent range (i.e.,",
      "single-precision) using the rounding mode specified by RN.",
      "",
      "",
      "r2 is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "",
      "For [pm]xvbf16ger2pn, do the",
      "following.",
      "",
      "",
      "",
      "Let v2 be the sum of r2 added to the negation",
      "of the single-precision floating-point value in word element",
      "j of ACC[AT][i], having infinite precision",
      "and unbounded exponent range.",
      "",
      "",
      "Let r2 be the value v2 rounded to 24-bit",
      "significand precision and 8-bit exponent range (i.e.,",
      "single-precision) using the rounding mode specified by RN.",
      "",
      "",
      "r2 is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "",
      "For [pm]xvbf16ger2np, do the",
      "following.",
      "",
      "",
      "",
      "Let v2 be the sum of the negation of r2 added",
      "to the single-precision floating-point value in word element",
      "j of ACC[AT][i], having infinite precision",
      "and unbounded exponent range.",
      "",
      "",
      "Let r3 be the value v3 rounded to 24-bit",
      "significand precision and 8-bit exponent range (i.e.,",
      "single-precision) using the rounding mode specified by RN.",
      "",
      "",
      "r2 is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "",
      "For [pm]xvbf16ger2nn, do the",
      "following.",
      "",
      "",
      "",
      "Let v2 be the sum of the negation of r2 added",
      "to the negation of the single-precision floating-point value in word",
      "element j of ACC[AT][i], having infinite",
      "precision and unbounded exponent range.",
      "",
      "",
      "Let r2 be the value v3 rounded to 24-bit",
      "significand precision and 8-bit exponent range (i.e.,",
      "single-precision) using the rounding mode specified by RN.",
      "",
      "",
      "r2 is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "",
      "Otherwise, the contents of word element j of ACC[AT][i] are set to 0x0000_0000.",
      "",
      "",
      "Unlike most other VSX Vector Floating-Point instructions,",
      "this instruction always updates the target register (here, ACC[AT],",
      "even when a trap-enabled exception occurs.",
      "For every multiply-add operation that is performed as part of the",
      "execution of this instruction, the operation is performed as if all",
      "exception enable bits are zero, and the trap-disabled result is",
      "returned.",
      "If the operation causes underflow or produces an inexact result,",
      "whether the operation causes an Underflow or Inexact exception is",
      "based on the actual contents of the Underflow and Overflow Enable",
      "bits.",
      "Exception status is accumulated and the appropriate exception status",
      "bits in the FPSCR are updated at the completion of execution of the",
      "instruction.",
      "Otherwise, behavior is the same as any vector floating-point",
      "instruction that can cause an exception.",
      "Taking a Program interrupt on a trap-enabled exception when",
      "interrupts are enabled by MSR.FE0 and MSR.FE1",
      "is still supported, albeit with ACC[AT] updated based on",
      "a trap-disabled result.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Equal To Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpeqdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "99",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Equal To Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpeqdp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "99",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[XT] are set",
      "to all 1s if src1 is equal to src2, and is",
      "set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return true for that",
      "element.",
      "",
      "",
      "Two infinity inputs of same signs return true for that element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Equal To Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpeqsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "67",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Equal To Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpeqsp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "67",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[XT] are",
      "set to all 1s if src1 is equal to src2, and",
      "is set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return true for that",
      "element.",
      "",
      "",
      "Two infinity inputs of same signs return true for that element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Greater Than or Equal To Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgedp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "115",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Greater Than or Equal To Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgedp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "115",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[XT] are set to all 1s if src1 is greater than or",
      "equal to the double-precision floating-point operand in doubleword",
      "element i of src2, and is set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return true for that",
      "element.",
      "",
      "",
      "Two infinity inputs of same signs return true for that element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Greater Than or Equal To Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgesp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "83",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Greater Than or Equal To Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgesp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "83",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[XT] are",
      "set to all 1s if src1 is greater than or equal to",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return true for that",
      "element.",
      "",
      "",
      "Two infinity inputs of same signs return true for that element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Greater Than Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgtdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "107",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Greater Than Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgtdp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "107",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of doubleword element i of VSR[XT] are set to all 1s if src1 is greater than",
      "src2, and is set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return false for that",
      "element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Compare Greater Than Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgtsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "0"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "75",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Compare Greater Than Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcmpgtsp.",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [
          {
            "field": "Rc",
            "value": "1"
          }
        ],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "Rc",
            "size": "1"
          },
          {
            "name": "75",
            "size": "7"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src1 is compared to src2.",
      "",
      "",
      "The contents of word element i of VSR[XT] are",
      "set to all 1s if src1 is greater than src2,",
      "and is set to all 0s otherwise.",
      "",
      "",
      "A NaN input causes the comparison to return false for that element.",
      "",
      "",
      "Two zero inputs of same or different signs return false for that",
      "element.",
      "",
      "",
      "If Rc=1, CR Field 6 is set as follows.",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT] and the contents of CR",
      "field 6 are undefined if Rc is equal to 1.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Copy Sign Double-Precision",
        "form": "XX3",
        "mnemonic": "xvcpsgndp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "240",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of bit 0 of doubleword element i of",
      "VSR[XA] are concatenated with the contents of bits 1:63",
      "of doubleword element i of VSR[XB] and placed",
      "into doubleword element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Copy Sign Single-Precision",
        "form": "XX3",
        "mnemonic": "xvcpsgnsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "208",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of bit 0 of word element i of VSR[XA] are concatenated with the contents of bits 1:31 of word",
      "element i of VSR[XB] and placed into word",
      "element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert bfloat16 to Single-Precision format Non-signaling",
        "form": "XX2",
        "mnemonic": "xvcvbf16spn",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "16",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of the rightmost halfword of word element i",
      "of VSR[XB] are placed into the leftmost halfword of word",
      "element i of VSR[XT].",
      "",
      "",
      "The contents of the rightmost halfword of word element i",
      "of VSR[XT] are set to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Double-Precision to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvdpsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "393",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to single-precision using the rounding",
      "mode specified by RN.",
      "",
      "",
      "The result is placed into bits 0:31 and bits 32:63 of doubleword",
      "element i of VSR[XT] in single-precision",
      "format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Double-Precision to Signed Doubleword format",
        "form": "XX2",
        "mnemonic": "xvcvdpsxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "472",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "",
      "The result is placed into doubleword element i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Double-Precision to Signed Word format",
        "form": "XX2",
        "mnemonic": "xvcvdpsxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "216",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000 and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "",
      "The result is placed into bits 0:31 of doubleword element i of VSR[XT].",
      "",
      "",
      "The result is also placed into bits 32:63 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Double-Precision to Unsigned Doubleword format",
        "form": "XX2",
        "mnemonic": "xvcvdpuxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "456",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, if the rounded value is less than 0, the result is",
      "0x0000_0000_0000_0000 and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Double-Precision to Unsigned Word format",
        "form": "XX2",
        "mnemonic": "xvcvdpuxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "200",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, if the rounded value is less than 0, the",
      "result is 0x0000_0000 and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "",
      "The result is placed into bits 0:31 of doubleword element i of VSR[XT].",
      "",
      "",
      "The result is also placed into bits 32:63 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert Half-Precision to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvhpsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "24",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the half-precision floating-point value in the",
      "rightmost halfword of word element i of VSR[XB].",
      "",
      "",
      "If src is an SNaN, the result is the single-precision",
      "representation of that SNaN converted to a QNaN.",
      "",
      "",
      "Otherwise, if src is a QNaN, the result is the",
      "single-precision representation of that QNaN.",
      "",
      "",
      "Otherwise, if src is an Infinity, the result is the",
      "single-precision representation of Infinity with the same sign as",
      "src.",
      "",
      "",
      "Otherwise, if src is a Zero, the result is the",
      "single-precision representation of Zero with the same sign as",
      "src.",
      "",
      "",
      "Otherwise, if src is a denormal value, the result is the",
      "normalized single-precision representation of src.",
      "",
      "",
      "Otherwise, the result is the single-precision representation of",
      "src.",
      "",
      "",
      "The result is placed into word element i of VSR[XT].",
      "",
      "",
      "If a trap-enabled exception occurs, VSR[XT] is not",
      "modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Single-Precision to bfloat16 format",
        "form": "XX2",
        "mnemonic": "xvcvspbf16",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "17",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "word element i of VSR[XB].",
      "",
      "",
      "If src is an SNaN, let result be the bfloat16",
      "representation of that SNaN converted to a QNaN.",
      "",
      "",
      "Otherwise, if src is a QNaN, let result be",
      "the bfloat16 representation of that QNaN.",
      "",
      "",
      "Otherwise, if src is an Infinity, let result",
      "be the bfloat16 representation of Infinity with the same sign as",
      "src.",
      "",
      "",
      "Otherwise, if src is a Zero, let result be",
      "the bfloat16 representation of Zero with the same sign as src.",
      "",
      "",
      "Otherwise, let result be the bfloat16 representation of",
      "src rounded to bfloat16 precision using the rounding mode",
      "specified in RN.",
      "",
      "",
      "result is placed into rightmost halfword of word element",
      "i of VSR[XT].",
      "",
      "",
      "The leftmost halfword of word element i of VSR[XT] is set to 0x0000.",
      "",
      "",
      "If a trap-enabled exception occurs, VSR[XT] is not",
      "modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert Single-Precision to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvspdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "457",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "bits 0:31 of doubleword element i of VSR[XB].",
      "",
      "",
      "src is placed into doubleword element i of",
      "VSR[XT] in double-precison format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Single-Precision to Half-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvsphp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "25",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "word element i of VSR[XB].",
      "",
      "",
      "If src is an SNaN, the result is the half-precision",
      "representation of that SNaN converted to a QNaN.",
      "",
      "",
      "Otherwise, if src is a QNaN, the result is the",
      "half-precision representation of that QNaN.",
      "",
      "",
      "Otherwise, if src is an Infinity, the result is the",
      "half-precision representation of Infinity with the same sign as",
      "src.",
      "",
      "",
      "Otherwise, if src is a Zero, the result is the",
      "half-precision representation of Zero with the same sign as",
      "src.",
      "",
      "",
      "Otherwise, the result is the half-precision representation of",
      "src rounded to half-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is zero-extended and placed into word element i of VSR[XT].",
      "",
      "",
      "If a trap-enabled exception occurs, VSR[XT] is not",
      "modified.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Single-Precision to Signed Doubleword format",
        "form": "XX2",
        "mnemonic": "xvcvspsxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "408",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i2 of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Single-Precision to Signed Word format",
        "form": "XX2",
        "mnemonic": "xvcvspsxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "152",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0x7FFF_FFFF, and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000, and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "signed-integer format, and if the result is inexact (i.e., not equal",
      "to src), XX is set to 1.",
      "",
      "",
      "The result is placed into word element i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Single-Precision to Unsigned Doubleword format",
        "form": "XX2",
        "mnemonic": "xvcvspuxds",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "392",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i2 of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, if the rounded value is less than 0, the result is",
      "0x0000_0000_0000_0000 and VXCVI is set to",
      "1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 64-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "",
      "The result is placed into doubleword element i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round to zero Single-Precision to Unsigned Word format",
        "form": "XX2",
        "mnemonic": "xvcvspuxws",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "136",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
      "If src is an SNaN, VXSNAN is also set to 1.",
      "",
      "",
      "Otherwise, src is rounded to a floating-point integer",
      "using the rounding mode Round Toward Zero.",
      "",
      "",
      "If the rounded value is greater than 2-1, the result is",
      "0xFFFF_FFFF and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, if the rounded value is less than 0, the",
      "result is 0x0000_0000 and VXCVI is set to 1.",
      "",
      "",
      "Otherwise, the result is the rounded value converted to 32-bit",
      "unsigned-integer format, and if the result is inexact (i.e., not",
      "equal to src), XX is set to 1.",
      "",
      "",
      "The result is placed into word element i of VSR[XT].",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Signed Doubleword to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvsxddp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "504",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the signed integer in doubleword element",
      "i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to double-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Signed Doubleword to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvsxdsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "440",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the signed integer in doubleword element",
      "i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to single-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into bits 0:31 of doubleword element i of VSR[XT] in single-precision format.",
      "",
      "",
      "The result is also placed into bits 32:63 of doubleword element",
      "i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert Signed Word to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvsxwdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "248",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the signed integer value in bits 0:31 of",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Signed Word to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvsxwsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "184",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the signed integer in word element i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to single-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Unsigned Doubleword to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvuxddp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "488",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the unsigned integer in doubleword element",
      "i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to double-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Unsigned Doubleword to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvuxdsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "424",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the unsigned integer in doubleword element",
      "i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to single-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into bits 0:31 of doubleword element i of VSR[XT] in single-precision format.",
      "",
      "",
      "The result is also placed into bits 32:63 of doubleword element",
      "i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert Unsigned Word to Double-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvuxwdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "232",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the unsigned integer value in bits 0:31 of",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Convert with round Unsigned Word to Single-Precision format",
        "form": "XX2",
        "mnemonic": "xvcvuxwsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "168",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the unsigned integer value in word element",
      "i of VSR[XB].",
      "",
      "",
      "src is converted to an unbounded-precision floating-point",
      "value and rounded to single-precision using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Divide Double-Precision",
        "form": "XX3",
        "mnemonic": "xvdivdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "120",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src1 is divided by",
      "src2, producing a quotient having unbounded range and",
      "precision.",
      "",
      "",
      "The quotient is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Divide Single-Precision",
        "form": "XX3",
        "mnemonic": "xvdivsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "88",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src1 is divided by",
      "src2, producing a quotient having unbounded range and",
      "precision.",
      "",
      "",
      "The quotient is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update)",
        "form": "XX3",
        "mnemonic": "xvf16ger2",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "19",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "18",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf16ger2pn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "146",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf16ger2np",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "82",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf16ger2nn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "210",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf16ger2",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "19",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "18",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf16ger2pn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "146",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf16ger2np",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "82",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf16ger2nn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "210",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of single-precision floating-point values.",
      "",
      "Let result be a 44 matrix of word",
      "elements to be used as a temporary Accumulator.",
      "",
      "For xvf16ger2, xvf16ger2pp,",
      "xvf16ger2pn, xvf16ger2np,",
      "or xvf16ger2nn, let PMSK=0b11,",
      "XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let src10 be",
      "the half-precision floating-point value in hword 0 of word element",
      "i of VSR[XA] and let src20 be the",
      "half-precision floating-point value in hword 0 of word element",
      "j of VSR[XB].",
      "Otherwise, let src10 be the value 0.0 and let src20 be the value 0.0, causing the product of src10 and",
      "src20 to be 0.0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let src11 be",
      "the half-precision floating-point value in hword 1 of word element",
      "i of VSR[XA] and let src21 be the",
      "half-precision floating-point value in hword 1 of word element",
      "j of VSR[XB].",
      "Otherwise, let src11 be the value 0.0 and let src21 be the value 0.0, causing the product of src11 and",
      "src21 to be 0.0.",
      "",
      "",
      "Let prod be the single-precision product of src10 and src20.",
      "",
      "",
      "Let msum be the sum of prod added to the",
      "product of src11 and src21.",
      "msum is rounded to single-precision using the rounding",
      "mode specified in RN.",
      "",
      "",
      "For [pm]xvf16ger2, the",
      "rounded msum is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "For [pm]xvf16ger2pp, the",
      "rounded msum is added to the single-precision",
      "floating-point value in word element j of ACC[AT][i], rounded to single-precision using the rounding mode",
      "specified in RN, and placed into word element j of ACC[AT][i] in single-precision floating-point",
      "format.",
      "",
      "",
      "For [pm]xvf16ger2pn, the",
      "rounded msum is added to the negation of the",
      "single-precision floating-point value in word element j",
      "of ACC[AT][i], rounded to single-precision using the",
      "rounding mode specified in RN, and placed into word",
      "element j of ACC[AT][i] in single-precision",
      "floating-point format.",
      "",
      "",
      "For [pm]xvf16ger2np, the",
      "negation of the rounded msum is added to the",
      "single-precision floating-point value in word element j",
      "of ACC[AT][i], rounded to single-precision using the",
      "rounding mode specified in RN, and placed into word",
      "element j of ACC[AT][i] in single-precision",
      "floating-point format.",
      "",
      "",
      "For [pm]xvf16ger2nn, the",
      "negation of the rounded msum is added to the negation of",
      "the single-precision floating-point value in word element j of ACC[AT][i], rounded to single-precision using the",
      "rounding mode specified in RN, and placed into word",
      "element j of ACC[AT][i] in single-precision",
      "floating-point format.",
      "",
      "",
      "",
      "Otherwise, the contents of ACC[AT][i][j] are set to",
      "0x0000_0000.",
      "",
      "",
      "Unlike most other VSX Vector Floating-Point instructions,",
      "this instruction always updates the target register (here, ACC[AT],",
      "even when a trap-enabled exception occurs.",
      "For every multiply-add operation that is performed as part of the",
      "execution of this instruction, the operation is performed as if all",
      "exception enable bits are zero, and the trap-disabled result is",
      "returned.",
      "If the operation causes underflow or produces an inexact result,",
      "whether the operation causes an Underflow or Inexact exception is",
      "based on the actual contents of the Underflow and Overflow Enable",
      "bits.",
      "Exception status is accumulated and the appropriate exception status",
      "bits in the FPSCR are updated at the completion of execution of the",
      "instruction.",
      "Otherwise, behavior is the same as any vector floating-point",
      "instruction that can cause an exception.",
      "Taking a Program interrupt on a trap-enabled exception when",
      "interrupts are enabled by MSR.FE0 and MSR.FE1",
      "is still supported, albeit with ACC[AT] updated based on",
      "a trap-disabled result.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update)",
        "form": "XX3",
        "mnemonic": "xvf32ger",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "27",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf32gerpp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "26",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf32gerpn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "154",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf32gernp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "90",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf32gernn",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "218",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf32ger",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "27",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf32gerpp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "26",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf32gerpn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "154",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf32gernp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "90",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf32gernn",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "218",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of single-precision floating-point values.",
      "",
      "For xvf32ger, xvf32gerpp, xvf32gerpn, xvf32gernp, or",
      "xvf32gernn, let XMSK=0b1111 and",
      "YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "Let prod be the product of the single-precision",
      "floating-point value in word element i of VSR[XA] and the single-precision floating-point value in word",
      "element j of VSR[XB], having unbounded range",
      "and precision.",
      "",
      "",
      "For [pm]xvf32ger, prod is rounded to single-precision using the rounding mode",
      "specified in RN.",
      "The rounded result is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "For [pm]xvf32gerpp, the single-precision floating-point",
      "value in word element j of ACC[AT][i] is",
      "added to prod.",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "For [pm]xvf32gerpn, the single-precision floating-point",
      "value in word element j of ACC[AT][i] is",
      "subtracted from prod.",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is placed into word element j of",
      "ACC[AT][i] in single-precision floating-point format.",
      "",
      "",
      "For [pm]xvf32gernp, the single-precision floating-point",
      "value in word element j of ACC[AT][i] is",
      "subtracted from prod.",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is negated and placed into word element j of ACC[AT][i] in single-precision floating-point",
      "format.",
      "",
      "",
      "For [pm]xvf32gernn, the single-precision floating-point",
      "value in word element j of ACC[AT][i] is",
      "added to prod.",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is negated and placed into word element j of ACC[AT][i] in single-precision floating-point",
      "format.",
      "",
      "",
      "",
      "Otherwise, the contents of word element j of ACC[AT][i] are set to 0x0000_0000.",
      "",
      "",
      "Unlike other vector floating-point instructions, ACC[AT]",
      "is always updated by the execution of the instruction, even when a",
      "trap-enabled exception occurs.",
      "For every multiply-add operation that is performed as part of the",
      "execution of this instruction, if an exception occurs as the result",
      "of that particular multiply-add operation, the trap-disabled",
      "exception result is returned, even if that exception type is",
      "trap-enabled.",
      "Exception detection is based on the trap-disable definition.",
      "Exception status is  and the appropriate exception status bits in the",
      "FPSCR are updated at the completion of execution of the instruction.",
      "Otherwise, behavior is the same as any vector floating-point",
      "instruction that can cause an exception.",
      "Taking a Program interrupt on a trap-enabled exception when",
      "interrupts are enabled by MSR.FE0 and MSR.FE1",
      "is still supported, albeit with the ACC[AT] updated based",
      "on a trap-disabled result.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update)",
        "form": "XX3",
        "mnemonic": "xvf64ger",
        "operands": [
          "AT",
          "XAp",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "59",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf64gerpp",
        "operands": [
          "AT",
          "XAp",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "58",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf64gerpn",
        "operands": [
          "AT",
          "XAp",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "186",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvf64gernp",
        "operands": [
          "AT",
          "XAp",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "122",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
        "form": "XX3",
        "mnemonic": "xvf64gernn",
        "operands": [
          "AT",
          "XAp",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "250",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf64ger",
        "operands": [
          "AT",
          "XAp",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "59",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf64gerpp",
        "operands": [
          "AT",
          "XAp",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "58",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf64gerpn",
        "operands": [
          "AT",
          "XAp",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "186",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf64gernp",
        "operands": [
          "AT",
          "XAp",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "122",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvf64gernn",
        "operands": [
          "AT",
          "XAp",
          "XB",
          "XMSK",
          "YMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "Ap",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "250",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "Let XAp be the value of 32AX + Ap.",
      "If XAp is odd, or is in the range 4AT to 4AT+3, the instruction form",
      "is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 42",
      "matrix of double-precision floating-point values.",
      "",
      "Let vsrcX be the concatenation of the contents of",
      "VSR[XAp] and VSR[XAp+1].",
      "",
      "Let vsrcY be the contents of VSR[XB].",
      "",
      "For xvf64ger, xvf64gerpp, xvf64gerpn, xvf64gernp, and",
      "xvf64gernn, let XMSK=0b1111 and",
      "YMSK=0b11.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 1, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1",
      "and bit j of YMSK is equal to 1,",
      "do the following.",
      "",
      "",
      "",
      "Let prod be the product of the double-precision",
      "floating-point value in doubleword element i of",
      "vsrcX and the double-precision floating-point value in",
      "doubleword element j of vsrcY, having",
      "unbounded range and precision.",
      "",
      "",
      "For [pm]xvf64ger, prod is rounded to double-precision using the rounding mode",
      "specified in RN.",
      "The rounded result is placed into doubleword element j of",
      "ACC[AT][i] in double-precision floating-point format.",
      "",
      "",
      "For [pm]xvf64gerpp, prod is added to the",
      "double-precision floating-point value in doubleword element",
      "j of ACC[AT][i].",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is placed into doubleword element j of",
      "ACC[AT][i] in double-precision floating-point format.",
      "",
      "",
      "For [pm]xvf64gerpn, prod is added to the",
      "negation of the double-precision floating-point value in doubleword",
      "element j of ACC[AT][i].",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is placed into doubleword element j of",
      "ACC[AT][i] in double-precision floating-point format.",
      "",
      "",
      "For [pm]xvf64gernn, prod is added to the",
      "double-precision floating-point value in doubleword element",
      "j of ACC[AT][i].",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is negated and placed into doubleword element",
      "j of ACC[AT][i] in double-precision",
      "floating-point format.",
      "",
      "",
      "For [pm]xvf64gernp, prod is added to the",
      "negation of the double-precision floating-point value in doubleword",
      "element j of ACC[AT][i].",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified in RN.",
      "The rounded result is negated and placed into doubleword element",
      "j of ACC[AT][i] in double-precision",
      "floating-point format.",
      "",
      "",
      "",
      "Otherwise, the contents of doubleword element j of",
      "ACC[AT][i] are set to 0x0000_0000_0000_0000.",
      "",
      "",
      "Unlike most other VSX Vector Floating-Point instructions,",
      "this instruction always updates the target register (here, ACC[AT],",
      "even when a trap-enabled exception occurs.",
      "For every multiply-add operation that is performed as part of the",
      "execution of this instruction, the operation is performed as if all",
      "exception enable bits are zero, and the trap-disabled result is",
      "returned.",
      "If the operation causes underflow or produces an inexact result,",
      "whether the operation causes an Underflow or Inexact exception is",
      "based on the actual contents of the Underflow and Overflow Enable",
      "bits.",
      "Exception status is accumulated and the appropriate exception status",
      "bits in the FPSCR are updated at the completion of execution of the",
      "instruction.",
      "Otherwise, behavior is the same as any vector floating-point",
      "instruction that can cause an exception.",
      "Taking a Program interrupt on a trap-enabled exception when",
      "interrupts are enabled by MSR.FE0 and MSR.FE1",
      "is still supported, albeit with ACC[AT] updated based on",
      "a trap-disabled result.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 4-bit Signed Integer GER (rank-8 update)",
        "form": "XX3",
        "mnemonic": "xvi4ger8",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvi4ger8pp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "34",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi4ger8",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "8"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "35",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi4ger8pp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "8"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "34",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of 32-bit signed integer values.",
      "",
      "For xvi4ger8 or xvi4ger8pp, let",
      "PMSK=0b11111111, XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let",
      "prod0 be the product of the 4-bit signed integer value in",
      "nibble 0 of word element i of VSR[XA]",
      "(X[i][0]) and the 4-bit signed integer value in byte 0 of",
      "word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
      "Otherwise, let prod0 be the value 0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let",
      "prod1 be the product of the 4-bit signed integer value in",
      "nibble 1 of word element i of VSR[XA]",
      "(X[i][1]) and the 4-bit signed integer value in nibble 1",
      "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
      "Otherwise, let prod1 be the value 0.",
      "",
      "",
      "If bit 2 of PMSK is equal to 1, let",
      "prod2 be the product of the 4-bit signed integer value in",
      "nibble 2 of word element i of VSR[XA]",
      "(X[i][2]) and the 4-bit signed integer value in nibble 2",
      "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
      "Otherwise, let prod2 be the value 0.",
      "",
      "",
      "If bit 3 of PMSK is equal to 1, let",
      "prod3 be the product of the 4-bit signed integer value in",
      "nibble 3 of word element i of VSR[XA]",
      "(X[i][3]) and the 4-bit signed integer value in nibble 3",
      "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
      "Otherwise, let prod3 be the value 0.",
      "",
      "",
      "If bit 4 of PMSK is equal to 1, let",
      "prod4 be the product of the 4-bit signed integer value in",
      "nibble 4 of word element i of VSR[XA]",
      "(X[i][4]) and the 4-bit signed integer value in nibble 4",
      "of word element j of VSR[XB] (Y[j][4]), sign-extended to 32 bits.",
      "Otherwise, let prod4 be the value 0.",
      "",
      "",
      "If if bit 5 of PMSK is equal to 1, let",
      "prod5 be the product of the 4-bit signed integer value in",
      "nibble 5 of word element i of VSR[XA]",
      "(X[i][5]) and the 4-bit signed integer value in nibble 5",
      "of word element j of VSR[XB] (Y[j][5]), sign-extended to 32 bits.",
      "Otherwise, let prod5 be the value 0.",
      "",
      "",
      "If bit 6 of PMSK is equal to 1, let",
      "prod6 be the product of the 4-bit signed integer value in",
      "nibble 6 of word element i of VSR[XA]",
      "(X[i][6]) and the 4-bit signed integer value in nibble 6",
      "of word element j of VSR[XB] (Y[j][6]), sign-extended to 32 bits.",
      "Otherwise, let prod6 be the value 0.",
      "",
      "",
      "If bit 7 of PMSK is equal to 1, let",
      "prod7 be the product of the 4-bit signed integer value in",
      "nibble 7 of word element i of VSR[XA]",
      "(X[i][7]) and the 4-bit signed integer value in nibble 7",
      "of word element j of VSR[XB] (Y[j][7]), sign-extended to 32 bits.",
      "Otherwise, let prod7 be the value 0.",
      "",
      "",
      "Let psum be the sum of prod0, prod1, prod2, prod3, prod4,",
      "prod5, prod6, and prod7.",
      "",
      "",
      "For [pm]xvi4ger8, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
      "",
      "",
      "For [pm]xvi4ger8pp, psum is added to the",
      "32-bit signed integer value in word element j of",
      "ACC[AT][i], and the result is placed into word element",
      "j of ACC[AT][i] in 32-bit signed integer",
      "format.",
      "",
      "",
      "",
      "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
        "form": "XX3",
        "mnemonic": "xvi8ger4",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvi8ger4pp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "2",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi8ger4",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "3",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi8ger4pp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "2",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of 32-bit signed integer values.",
      "",
      "For xvi8ger4 or xvi8ger4pp, let",
      "PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let",
      "prod0 be the product of the 8-bit signed integer value in",
      "byte 0 of word element i of VSR[XA]",
      "(X[i][0]) and the 8-bit unsigned integer value in byte 0",
      "of word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
      "Otherwise, let prod0 be the value 0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let",
      "prod1 be the product of the 8-bit signed integer value in",
      "byte 1 of word element i of VSR[XA]",
      "(X[i][1]) and the 8-bit unsigned integer value in byte 1",
      "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
      "Otherwise, let prod1 be the value 0.",
      "",
      "",
      "If bit 2 of PMSK is equal to 1, let",
      "prod2 be the product of the 8-bit signed integer value in",
      "byte 2 of word element i of VSR[XA]",
      "(X[i][2]) and the 8-bit unsigned integer value in byte 2",
      "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
      "Otherwise, let prod2 be the value 0.",
      "",
      "",
      "If bit 3 of PMSK is equal to 1, let",
      "prod3 be the product of the 8-bit signed integer value in",
      "byte 3 of word element i of VSR[XA]",
      "(X[i][3]) and the 8-bit unsigned integer value in byte 3",
      "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
      "Otherwise, let prod3 be the value 0.",
      "",
      "",
      "Let sum be the sum of prod0, prod1, prod2, and prod3.",
      "",
      "",
      "For [pm]xvi8ger4, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
      "",
      "",
      "For [pm]xvi8ger4pp, psum is added to the",
      "32-bit signed integer value in word element j of",
      "ACC[AT][i], and the result is placed into word element",
      "j of ACC[AT][i] in 32-bit signed integer",
      "format.",
      "",
      "",
      "",
      "Otherwise, let word element j of ACC[AT][i]",
      "is set to 0x0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturation Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvi8ger4spp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "2",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturation Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi8ger4spp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "4"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "2",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of 32-bit signed integer values.",
      "",
      "For xvi8ger4spp, let PMSK=0b1111,",
      "XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3, and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let",
      "prod0 be the product of the 8-bit signed integer value in",
      "byte 0 of word element i of VSR[XA]",
      "(X[i][0]) and the 8-bit unsigned integer value in byte 0",
      "of word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
      "Otherwise, let prod0 be the value 0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let",
      "prod1 be the product of the 8-bit signed integer value in",
      "byte 1 of word element i of VSR[XA]",
      "(X[i][1]) and the 8-bit unsigned integer value in byte 1",
      "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
      "Otherwise, let prod1 be the value 0.",
      "",
      "",
      "If bit 2 of PMSK is equal to 1, let",
      "prod2 be the product of the 8-bit signed integer value in",
      "byte 2 of word element i of VSR[XA]",
      "(X[i][2]) and the 8-bit unsigned integer value in byte 2",
      "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
      "Otherwise, let prod2 be the value 0.",
      "",
      "",
      "If bit 3 of PMSK is equal to 1, let",
      "prod3 be the product of the 8-bit signed integer value in",
      "byte 3 of word element i of VSR[XA]",
      "(X[i][3]) and the 8-bit unsigned integer value in byte 3",
      "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
      "Otherwise, let prod3 be the value 0.",
      "",
      "",
      "Let psum be the sum of prod0, prod1, prod2, and prod3.",
      "",
      "",
      "psum is added to the 32-bit signed integer value in word",
      "element j of ACC[AT][i] and the result is",
      "placed into word element j of ACC[AT][i] in",
      "32-bit signed integer format.",
      "",
      "",
      "If the result is less than -2, the result saturates to",
      "-2 and SAT is set to 1.",
      "",
      "",
      "If the result is greater than 2-1, the result",
      "saturates to 2-1 and SAT is set to 1.",
      "",
      "",
      "",
      "Otherwise, let word element j of ACC[AT][i]",
      "is set to 0x0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update)",
        "form": "XX3",
        "mnemonic": "xvi16ger2",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "11",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvi16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "10",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update)",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi16ger2",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "11",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi16ger2pp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "10",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of 32-bit signed integer values.",
      "",
      "For xvi16ger2 or xvi16ger2pp, let",
      "PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3 and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let",
      "prod0 be the product of the 16-bit signed integer value",
      "in halfword 0 of word element i of VSR[XA]",
      "and the 16-bit signed integer value in halfword 0 of word element",
      "j of VSR[XB].",
      "Otherwise, let  prod0 be the value 0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let",
      "prod1 be the product of the 16-bit signed integer value",
      "in halfword 1 of word element i of VSR[XA]",
      "and the 16-bit signed integer value in halfword 1 of word element",
      "j of VSR[XB].",
      "Otherwise, let  prod1 be the value 0.",
      "",
      "",
      "Let psum be the sum of prod0 and prod1.",
      "",
      "",
      "For [pm]xvi16ger2, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
      "",
      "",
      "For [pm]xvi16ger2pp,",
      "psum is added to the 32-bit signed integer value in word",
      "element j of ACC[AT][i], and the result is",
      "placed into word element j of ACC[AT][i] in",
      "32-bit signed integer format.",
      "",
      "",
      "",
      "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
        "form": "XX3",
        "mnemonic": "xvi16ger2s",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "43",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
        "form": "XX3",
        "mnemonic": "xvi16ger2spp",
        "operands": [
          "AT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "42",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi16ger2s",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "43",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      },
      {
        "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
        "form": "MMIRR:XX3",
        "mnemonic": "pmxvi16ger2spp",
        "operands": [
          "AT",
          "XA",
          "XB",
          "XMSK",
          "YMSK",
          "PMSK"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "121",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "PMSK",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "6"
          },
          {
            "name": "XMSK",
            "size": "4"
          },
          {
            "name": "YMSK",
            "size": "4"
          },
          {
            "name": "59",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "42",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value of 32AX + A.",
      "If XA is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let XB be the value of 32BX + B.",
      "If XB is in the range 4AT to",
      "4AT+3, the instruction form is invalid.",
      "",
      "Let the contents of ACC[AT] be a 44",
      "matrix of 32-bit signed integer values.",
      "",
      "For xvi16ger2s or xvi16ger2spp, let",
      "PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
      "",
      "For each integer value i from 0 to 3 and each integer",
      "value j from 0 to 3, do the following.",
      "",
      "",
      "",
      "If bit i of XMSK is equal to 1 and bit",
      "j of YMSK is equal to 1, do the following.",
      "",
      "",
      "",
      "If bit 0 of PMSK is equal to 1, let",
      "prod0 be the product of the 16-bit signed integer value",
      "in halfword 0 of word element i of VSR[XA]",
      "and the 16-bit signed integer value in halfword 0 of word element",
      "j of VSR[XB].",
      "Otherwise, let  prod0 be the value 0.",
      "",
      "",
      "If bit 1 of PMSK is equal to 1, let",
      "prod1 be the product of the 16-bit signed integer value",
      "in halfword 1 of word element i of VSR[XA]",
      "and the 16-bit signed integer value in halfword 1 of word element",
      "j of VSR[XB].",
      "Otherwise, let  prod1 be the value 0.",
      "",
      "",
      "Let sum be the sum of prod0 and prod1.",
      "",
      "",
      "For [pm]xvi16ger2s, let",
      "result be psum.",
      "",
      "",
      "For [pm]xvi16ger2spp, let",
      "result be the sum of psum to the 32-bit",
      "signed integer value in word element j of ACC[AT][i].",
      "",
      "",
      "If result is less than -2, result",
      "saturates to -2 and",
      "SAT is set to 1.",
      "",
      "",
      "If result is greater than 2-1, result saturates to 2-1 and SAT is set to 1.",
      "",
      "",
      "result is placed into word element j of",
      "ACC[AT][i] in 32-bit signed integer format.",
      "",
      "",
      "",
      "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Insert Exponent Double-Precision",
        "form": "XX3",
        "mnemonic": "xviexpdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "248",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XA be the sum 32AX + A.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in doubleword",
      "element i of VSR[XA].",
      "",
      "",
      "Let src2 be the unsigned integer value in doubleword",
      "element i of VSR[XB].",
      "",
      "",
      "The contents of bits 0 of src1 are placed into bit 0 of",
      "doubleword element i of VSR[XT].",
      "",
      "",
      "The contents of bits 53:63 of src2 are placed into bits",
      "1:11 of doubleword element i of VSR[XT].",
      "",
      "",
      "The contents of bits 12:63 of src1 are placed into bits",
      "12:63 of doubleword element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Insert Exponent Single-Precision",
        "form": "XX3",
        "mnemonic": "xviexpsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "216",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XA be the sum 32AX + A.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the unsigned integer value in word element",
      "i of VSR[XA].",
      "",
      "",
      "Let src2 be the unsigned integer value in word element",
      "i of VSR[XB].",
      "",
      "",
      "The contents of bits 0 of src1 are placed into bit 0 of",
      "word element i of VSR[XT].",
      "",
      "",
      "The contents of bits 24:31 of src2 are placed into bits",
      "1:8 of word element i of VSR[XT].",
      "",
      "",
      "The contents of bits 9:31 of src1 are placed into bits",
      "9:31 of word element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply-Add Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmaddadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "97",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Multiply-Add Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmaddmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "105",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "For xvmaddadp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvmaddmdp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply-Add Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmaddasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "65",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Multiply-Add Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmaddmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "73",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For xvmaddasp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvmaddmsp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Maximum Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmaxdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "224",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "If src1 is greater than src2, src1 is placed into doubleword element i of VSR[XT] in double-precision format.",
      "Otherwise, src2 is placed into doubleword element",
      "i of VSR[XT] in double-precision format.",
      "",
      "",
      "The maximum of +0 and -0 is +0.",
      "The maximum of a QNaN and any value is that value.",
      "The maximum of any value and an SNaN when VE=0 is that",
      "SNaN converted to a QNaN.",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Maximum Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmaxsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "192",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "If src1 is greater than src2, src1 is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "Otherwise, src2 is placed into word element i of",
      "VSR[XT] in single-precision format.",
      "",
      "",
      "The maximum of +0 and 0 is +0.",
      "The maximum of a QNaN and any value is that value.",
      "The maximum of any value and an SNaN when VE=0 is that SNaN converted",
      "to a QNaN.",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Minimum Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmindp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "232",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "If src1 is less than src2, src1",
      "is placed into doubleword element i of VSR[XT] in double-precision format.",
      "Otherwise, src2 is placed into doubleword element",
      "i of VSR[XT] in double-precision format.",
      "",
      "",
      "The minimum of +0 and -0 is -0.",
      "The minimum of a QNaN and any value is that value.",
      "The minimum of any value and an SNaN when VE=0 is that",
      "SNaN converted to a QNaN.",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Minimum Single-Precision",
        "form": "XX3",
        "mnemonic": "xvminsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "200",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "If src1 is less than src2, src1",
      "is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "Otherwise, src2 is placed into word element i",
      "of VSR[XT] in single-precision format.",
      "",
      "",
      "The minimum of +0 and -0 is -0.",
      "The minimum of a QNaN and any value is that value.",
      "The minimum of any value and an SNaN when VE=0 is that",
      "SNaN converted to a QNaN.",
      "",
      "",
      "See Table .",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply-Subtract Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmsubadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "113",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Multiply-Subtract Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmsubmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "121",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "For xvmsubadp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvmsubmdp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply-Subtract Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmsubasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "81",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Multiply-Subtract Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmsubmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "89",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For xvmsubasp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvmsubmsp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply Double-Precision",
        "form": "XX3",
        "mnemonic": "xvmuldp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "112",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src1 is multiplied by src2, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "The product is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Multiply Single-Precision",
        "form": "XX3",
        "mnemonic": "xvmulsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "80",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src1 is multiplied by src2, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "The product is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Absolute Double-Precision",
        "form": "XX2",
        "mnemonic": "xvnabsdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "489",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of doubleword element i of VSR[XB], with bit 0 set to 1, is placed into doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Absolute Single-Precision",
        "form": "XX2",
        "mnemonic": "xvnabssp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "425",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of word element i of VSR[XB],",
      "with bit 0 set to 1, is placed into word element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negate Double-Precision",
        "form": "XX2",
        "mnemonic": "xvnegdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "505",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of doubleword element i of VSR[XB], with bit 0 complemented, is placed into doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negate Single-Precision",
        "form": "XX2",
        "mnemonic": "xvnegsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "441",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of word element i of VSR[XB],",
      "with bit 0 complemented, is placed into word element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Multiply-Add Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xvnmaddadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "225",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Negative Multiply-Add Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xvnmaddmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "233",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "For xvnmaddadp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvnmaddmdp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into doubleword element i of VSR[XT] in double-precision format.",
      "",
      "",
      "See",
      "Table,",
      "Vector Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Multiply-Add Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xvnmaddasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "193",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Negative Multiply-Add Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xvnmaddmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "201",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For xvnmaddasp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvnmaddmsp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into word element i of",
      "VSR[XT] in single-precision format.",
      "",
      "",
      "See",
      "Table,",
      "Vector Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Multiply-Subtract Type-A Double-Precision",
        "form": "XX3",
        "mnemonic": "xvnmsubadp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "241",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Negative Multiply-Subtract Type-M Double-Precision",
        "form": "XX3",
        "mnemonic": "xvnmsubmdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "249",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "For xvmsubadp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvmsubmdp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into doubleword element i of VSR[XT] in double-precision format.",
      "",
      "",
      "See",
      "Table,",
      "Vector Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Negative Multiply-Subtract Type-A Single-Precision",
        "form": "XX3",
        "mnemonic": "xvnmsubasp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "209",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      },
      {
        "name": "VSX Vector Negative Multiply-Subtract Type-M Single-Precision",
        "form": "XX3",
        "mnemonic": "xvnmsubmsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "217",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "For xvnmsubasp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "For xvnmsubmsp, do the following.",
      "",
      "",
      "",
      "",
      "",
      "",
      "src1 is multiplied by src3, producing a product having",
      "unbounded range and precision.",
      "",
      "",
      "See part 1 of Table .",
      "",
      "",
      "src2 is negated and added to the product, producing a sum",
      "having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See part 2 of Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is negated and placed into word element i of",
      "VSR[XT] in single-precision format.",
      "",
      "",
      "See",
      "Table,",
      "Vector Floating-Point Final Result with Negation, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Double-Precision Integer using round to Nearest Away",
        "form": "XX2",
        "mnemonic": "xvrdpi",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "201",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round to Nearest Away.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Double-Precision Integer Exact using Current rounding mode",
        "form": "XX2",
        "mnemonic": "xvrdpic",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "235",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "specified by RN.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Double-Precision Integer using round toward -Infinity",
        "form": "XX2",
        "mnemonic": "xvrdpim",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "249",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward -Infinity.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Double-Precision Integer using round toward +Infinity",
        "form": "XX2",
        "mnemonic": "xvrdpip",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "233",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward +Infinity.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Double-Precision Integer using round toward Zero",
        "form": "XX2",
        "mnemonic": "xvrdpiz",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "217",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward Zero.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Reciprocal Estimate Double-Precision",
        "form": "XX2",
        "mnemonic": "xvredp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "218",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "A double-precision floating-point estimate of the reciprocal of",
      "src is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "Unless the reciprocal of src would be a zero, an",
      "infinity, or a QNaN, the estimate has a relative error in precision",
      "no greater than one part in 16384 of the reciprocal of src. That is,",
      "",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Reciprocal Estimate Single-Precision",
        "form": "XX2",
        "mnemonic": "xvresp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "154",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "A single-precision floating-point estimate of the reciprocal of",
      "src is placed into word element i of",
      "VSR[XT] in single-precision format.",
      "",
      "",
      "Unless the reciprocal of src would be a zero, an",
      "infinity, or a QNaN, the estimate has a relative error in precision",
      "no greater than one part in 16384 of the reciprocal of src. That is,",
      "",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Single-Precision Integer using round to Nearest Away",
        "form": "XX2",
        "mnemonic": "xvrspi",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "137",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round to Nearest Away.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Single-Precision Integer Exact using Current rounding mode",
        "form": "XX2",
        "mnemonic": "xvrspic",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "171",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer value using the rounding",
      "mode specified by RN.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Single-Precision Integer using round toward -Infinity",
        "form": "XX2",
        "mnemonic": "xvrspim",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "185",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward -Infinity.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Single-Precision Integer using round toward +Infinity",
        "form": "XX2",
        "mnemonic": "xvrspip",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "169",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward +Infinity.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Round to Single-Precision Integer using round toward Zero",
        "form": "XX2",
        "mnemonic": "xvrspiz",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "153",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "src is rounded to an integer using the rounding mode",
      "Round toward Zero.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Reciprocal Square Root Estimate Double-Precision",
        "form": "XX2",
        "mnemonic": "xvrsqrtedp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "202",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "A double-precision floating-point estimate of the reciprocal square",
      "root of src is placed into doubleword element i of VSR[XT] in double-precision format.",
      "",
      "",
      "Unless the reciprocal of the square root of src would be",
      "a zero, an infinity, or a QNaN, the estimate has a relative error in",
      "precision no greater than one part in 16384 of the reciprocal of the",
      "square root of src. That is,",
      "",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Reciprocal Square Root Estimate Single-Precision",
        "form": "XX2",
        "mnemonic": "xvrsqrtesp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "138",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "A single-precision floating-point estimate of the reciprocal square",
      "root of src is placed into word element i of",
      "VSR[XT] in single-precision format.",
      "",
      "",
      "Unless the reciprocal of the square root of src would be",
      "a zero, an infinity, or a QNaN, the estimate has a relative error in",
      "precision no greater than one part in 16384 of the reciprocal of the",
      "square root of src. That is,",
      "",
      "",
      "Operation with various special values of the operand is summarized",
      "below.",
      "",
      "",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "The results of executing this instruction is permitted to vary",
      "between implementations, and between different executions on the same",
      "implementation.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Square Root Double-Precision",
        "form": "XX2",
        "mnemonic": "xvsqrtdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "203",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "The unbounded-precision square root of src is produced.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of",
      "VSR[XT] in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Square Root Single-Precision",
        "form": "XX2",
        "mnemonic": "xvsqrtsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "139",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the",
      "following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "The unbounded-precision square root of src is produced.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Subtract Double-Precision",
        "form": "XX3",
        "mnemonic": "xvsubdp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "104",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "src2 is negated and added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to double-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into doubleword element i of VSR[XT]",
      "in double-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Subtract Single-Precision",
        "form": "XX3",
        "mnemonic": "xvsubsp",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "72",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "src2 is negated and added to src1, producing a",
      "sum having unbounded range and precision.",
      "",
      "",
      "The sum is normalized.",
      "",
      "",
      "See Table .",
      "",
      "",
      "The intermediate result is rounded to single-precision using the",
      "rounding mode specified by RN.",
      "",
      "",
      "See Table,",
      "Scalar Floating-Point Intermediate Result Handling, on",
      "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
      "",
      "",
      "The result is placed into word element i of VSR[XT] in",
      "single-precision format.",
      "",
      "",
      "See Table,",
      "Vector Floating-Point Final Result, on",
      "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
      "",
      "",
      "If a trap-enabled exception occurs in any element of the vector, no",
      "results are written to VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test for software Divide Double-Precision",
        "form": "XX3",
        "mnemonic": "xvtdivdp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "125",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "fe_flag is initialized to 0.",
      "",
      "fg_flag is initialized to 0.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src1 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XA].",
      "",
      "",
      "Let src2 be the double-precision floating-point operand",
      "in doubleword element i of VSR[XB].",
      "",
      "",
      "Let e_a be the unbiased exponent of src1.",
      "",
      "",
      "Let e_b be the unbiased exponent of src2.",
      "",
      "",
      "fe_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "",
      "",
      "fg_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test for software Divide Single-Precision",
        "form": "XX3",
        "mnemonic": "xvtdivsp",
        "operands": [
          "BF",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "93",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "fe_flag is initialized to 0.",
      "",
      "fg_flag is initialized to 0.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src1 be the single-precision floating-point operand",
      "in word element i of VSR[XA].",
      "",
      "",
      "Let src2 be the single-precision floating-point operand",
      "in word element i of VSR[XB].",
      "",
      "",
      "Let e_a be the unbiased exponent of src1.",
      "",
      "",
      "Let e_b be the unbiased exponent of src2.",
      "",
      "",
      "fe_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "",
      "",
      "fg_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test for software Square Root Double-Precision",
        "form": "XX2",
        "mnemonic": "xvtsqrtdp",
        "operands": [
          "BF",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "234",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "fe_flag is initialized to 0.",
      "",
      "fg_flag is initialized to 0.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point operand in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "Let e_b be the unbiased exponent of src.",
      "",
      "",
      "fe_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "",
      "",
      "fg_flag is set to 1 for the following",
      "condition.",
      "",
      "",
      "",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test for software Square Root Single-Precision",
        "form": "XX2",
        "mnemonic": "xvtsqrtsp",
        "operands": [
          "BF",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "7"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "170",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "fe_flag is initialized to 0.",
      "",
      "fg_flag is initialized to 0.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point operand in",
      "word element i of VSR[XB].",
      "",
      "",
      "Let e_b be the unbiased exponent of src.",
      "",
      "",
      "fe_flag is set to 1 for any of the following",
      "conditions.",
      "",
      "",
      "",
      "",
      "",
      "",
      "fg_flag is set to 1 for the following",
      "condition.",
      "",
      "",
      "",
      "",
      "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test Data Class Double-Precision",
        "form": "XX2",
        "mnemonic": "xvtstdcdp",
        "operands": [
          "XT",
          "XB",
          "DCMX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "dcmx2",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "15",
            "size": "4"
          },
          {
            "name": "dcmx0",
            "size": "1"
          },
          {
            "name": "5",
            "size": "3"
          },
          {
            "name": "dcmx1",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let DCMX be the value dc concatenated with",
      "dm concatenated with dx.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "If src matches one of the 7 possible data classes",
      "specified by DCMX (Data Class Mask), the contents of",
      "doubleword element i of VSR[XT] are set to",
      "0xFFFF_FFFF_FFFF_FFFF.",
      "Otherwise, the contents of doubleword element i of",
      "VSR[XT] are set to 0x0000_0000_0000_0000.",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test Data Class Single-Precision",
        "form": "XX2",
        "mnemonic": "xvtstdcsp",
        "operands": [
          "XT",
          "XB",
          "DCMX"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "dcmx2",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "13",
            "size": "4"
          },
          {
            "name": "dcmx0",
            "size": "1"
          },
          {
            "name": "5",
            "size": "3"
          },
          {
            "name": "dcmx1",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let DCMX be the value dc concatenated with",
      "dm concatenated with dx.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "word element i of VSR[XB].",
      "",
      "",
      "If src matches one of the 7 possible data classes",
      "specified by DCMX (Data Class Mask), the contents of word",
      "element i of VSR[XT] are set to 0xFFFF_FFFF.",
      "Otherwise, the contents of word element i of VSR[XT] are set to 0x0000_0000.",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Test Least-Significant Bit by Byte",
        "form": "XX2",
        "mnemonic": "xvtlsbb",
        "operands": [
          "BF",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "BF",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Set CR field BF to indicate if bit 7 of every byte",
      "element in VSR[XB] is equal to 1 (ALL_TRUE)",
      "or equal to 0 (ALL_FALSE).",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Extract Exponent Double-Precision",
        "form": "XX2",
        "mnemonic": "xvxexpdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "The value of the exponent field in src is placed into",
      "doubleword element i of VSR[XT] in unsigned",
      "integer format.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Extract Exponent Single-Precision",
        "form": "XX2",
        "mnemonic": "xvxexpsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "8",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "word element i of VSR[XB].",
      "",
      "",
      "The value of the exponent field in src is placed into",
      "word element i of VSR[XT] in unsigned integer",
      "format.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Extract Significand Double-Precision",
        "form": "XX2",
        "mnemonic": "xvxsigdp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "Let src be the double-precision floating-point value in",
      "doubleword element i of VSR[XB].",
      "",
      "",
      "The significand of src is placed into doubleword element",
      "i of VSR[XT] in unsigned integer format.",
      "If src is a normal value, the implicit leading bit is set",
      "to 1.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Extract Significand Single-Precision",
        "form": "XX2",
        "mnemonic": "xvxsigsp",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "9",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "Let XB be the sum 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "Let src be the single-precision floating-point value in",
      "word element i of VSR[XB].",
      "",
      "",
      "The significand of src is placed into word element",
      "i of VSR[XT] in unsigned integer format.",
      "If src is a normal value, the implicit leading bit is set",
      "to 1.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Blend Variable Byte",
        "form": "8RR:XX4",
        "mnemonic": "xxblendvb",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "20"
          },
          {
            "name": "33",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "0",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "If the contents of bit 0 of byte element i of VSR[XC] is equal to 0, the contents of byte element i of",
      "VSR[XA] are placed into byte element i of",
      "VSR[XT].",
      "Otherwise, the contents of byte element i of VSR[XB] are placed into byte element i of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Blend Variable Halfword",
        "form": "8RR:XX4",
        "mnemonic": "xxblendvh",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "20"
          },
          {
            "name": "33",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "1",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "If the contents of bit 0 of halfword element i of",
      "VSR[XC] is equal to 0, the contents of halfword element",
      "i of VSR[XA] are placed into halfword element",
      "i of VSR[XT].",
      "Otherwise, the contents of halfword element i of",
      "VSR[XB] are placed into halfword element i of",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Blend Variable Word",
        "form": "8RR:XX4",
        "mnemonic": "xxblendvw",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "20"
          },
          {
            "name": "33",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "2",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "If the contents of bit 0 of word element i of VSR[XC] is equal to 0, the contents of word element i of",
      "VSR[XA] are placed into word element i of",
      "VSR[XT].",
      "Otherwise, the contents of word element i of VSR[XB] are placed into word element i of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Blend Variable Doubleword",
        "form": "8RR:XX4",
        "mnemonic": "xxblendvd",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "20"
          },
          {
            "name": "33",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "3",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "If the contents of bit 0 of doubleword element i of",
      "VSR[XC] is equal to 0, the contents of doubleword element",
      "i of VSR[XA] are placed into doubleword",
      "element i of VSR[XT].",
      "Otherwise, the contents of doubleword element i of",
      "VSR[XB] are placed into doubleword element i",
      "of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Byte-Reverse Doubleword",
        "form": "XX2",
        "mnemonic": "xxbrd",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "23",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 1, do the following.",
      "",
      "",
      "",
      "The contents of byte 7 of doubleword element i of",
      "VSR[XB] are placed into byte 0 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 6 of doubleword element i of",
      "VSR[XB] are placed into byte 1 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 5 of doubleword element i of",
      "VSR[XB] are placed into byte 2 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 4 of doubleword element i of",
      "VSR[XB] are placed into byte 3 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 3 of doubleword element i of",
      "VSR[XB] are placed into byte 4 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 2 of doubleword element i of",
      "VSR[XB] are placed into byte 5 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 1 of doubleword element i of",
      "VSR[XB] are placed into byte 6 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 0 of doubleword element i of",
      "VSR[XB] are placed into byte 7 of doubleword element",
      "i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Byte-Reverse Halfword",
        "form": "XX2",
        "mnemonic": "xxbrh",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "7",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 7, do the following.",
      "",
      "",
      "",
      "The contents of byte 1 of halfword element i of",
      "VSR[XB] are placed into byte 0 of halfword element",
      "i of VSR[XT].",
      "",
      "",
      "The contents of byte 0 of halfword element i of",
      "VSR[XB] are placed into byte 1 of halfword element",
      "i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Byte-Reverse Quadword",
        "form": "XX2",
        "mnemonic": "xxbrq",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "31",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "The contents of byte sub-element 15-i of VSR[XB] are placed into byte sub-element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Byte-Reverse Word",
        "form": "XX2",
        "mnemonic": "xxbrw",
        "operands": [
          "XT",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "15",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "475",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "For each integer value i from 0 to 3, do the following.",
      "",
      "",
      "",
      "The contents of byte 3 of word element i of VSR[XB] are placed into byte 0 of word element i of",
      "VSR[XT].",
      "",
      "",
      "The contents of byte 2 of word element i of VSR[XB] are placed into byte 1 of word element i of",
      "VSR[XT].",
      "",
      "",
      "The contents of byte 1 of word element i of VSR[XB] are placed into byte 2 of word element i of",
      "VSR[XT].",
      "",
      "",
      "The contents of byte 0 of word element i of VSR[XB] are placed into byte 3 of word element i of",
      "VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Evaluate",
        "form": "8RR:XX4",
        "mnemonic": "xxeval",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC",
          "IMM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "12"
          },
          {
            "name": "IMM",
            "size": "8"
          },
          {
            "name": "34",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "1",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i, 0 to 127, do the following.",
      "",
      "",
      "",
      "Let j be the value of the concatenation of the contents",
      "of bit i of VSR[XA], bit i of",
      "VSR[XB], bit i of VSR[XC].",
      "",
      "",
      "The value of bit j of IMM is placed into bit",
      "i of VSR[XT].",
      "",
      "",
      "See",
      "Table,",
      "xxeval(A, B, C, IMM) Equivalent Functions, on",
      "pagetable:PPC1ChVSX-xxeval-A,-B,-C,-IMM-Equivalent-Functions",
      "for the equivalent function evaluated by this instruction for any",
      "given value of IMM.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Extract Unsigned Word",
        "form": "XX2",
        "mnemonic": "xxextractuw",
        "operands": [
          "XT",
          "XB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "165",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of byte elements UIM:UIM+3 of VSR[XB]  are placed into word element 1 of VSR[XT].",
      "The contents of the remaining word elements of VSR[XT]",
      "are set to 0.",
      "",
      "If the value of UIM is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Insert Word",
        "form": "XX2",
        "mnemonic": "xxinsertw",
        "operands": [
          "XT",
          "XB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "UIM",
            "size": "4"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "181",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of word element 1 of VSR[XB] are placed into",
      "byte elements UIM:UIM+3 of VSR[XT].",
      "The contents of the remaining byte elements of VSR[XT]",
      "are not modified.",
      "",
      "If the value of UIM is greater than 12, the results are",
      "undefined.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Generate PCV from Byte Mask",
        "form": "X",
        "mnemonic": "xxgenpcvbm",
        "operands": [
          "XT",
          "VRB",
          "IMM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "IMM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "919",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "If IMM=0b00000, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
      "leftmost byte elements of a source vector into the byte elements of a",
      "result vector specified by the byte-element mask in VSR[VRB+32].",
      "",
      "If IMM=0b00001, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
      "byte elements in a source vector specified by the byte-element mask",
      "in VSR[VRB+32] into the leftmost byte elements of a",
      "result vector.",
      "",
      "If IMM=0b00010, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
      "rightmost byte elements of a source vector into the byte elements of",
      "a result vector specified by the byte-element mask in VSR[VRB+32].",
      "",
      "If IMM=0b00011, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
      "sparse byte elements in a source vector specified by the byte-element",
      "mask in VSR[VRB+32] into the rightmost byte elements of a",
      "result vector.",
      "",
      "pcv is placed into VSR[XT].",
      "",
      "Unused values of IMM are reserved.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Generate PCV from Halfword Mask",
        "form": "X",
        "mnemonic": "xxgenpcvhm",
        "operands": [
          "XT",
          "VRB",
          "IMM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "IMM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "919",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "If IMM=0b00000, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
      "leftmost halfword elements of a source vector into the halfword",
      "elements of a result vector specified by the halfword-element mask in",
      "VSR[VRB+32].",
      "",
      "If IMM=0b00001, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
      "halfword elements in a source vector specified by the",
      "halfword-element mask in VSR[VRB+32] into the leftmost",
      "halfword elements of a result vector.",
      "",
      "If IMM=0b00010, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
      "rightmost halfword elements of a source vector into the halfword",
      "elements of a result vector specified by the halfword-element mask in",
      "VSR[VRB+32].",
      "",
      "If IMM=0b00011, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
      "sparse halfword elements in a source vector specified by the",
      "halfword-element mask in VSR[VRB+32] into the rightmost",
      "halfword elements of a result vector.",
      "",
      "pcv is placed into VSR[XT].",
      "",
      "Unused values of IMM are reserved.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Generate PCV from Word Mask",
        "form": "X",
        "mnemonic": "xxgenpcvwm",
        "operands": [
          "XT",
          "VRB",
          "IMM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "IMM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "919",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "If IMM=0b00000, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
      "leftmost word elements of a source vector into the word elements of a",
      "result vector specified by the word-element mask in VSR[VRB+32].",
      "",
      "If IMM=0b00001, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
      "word elements in a source vector specified by the word-element mask",
      "in VSR[VRB+32] into the leftmost word elements of a",
      "result vector.",
      "",
      "If IMM=0b00010, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
      "rightmost word elements of a source vector into the word elements of",
      "a result vector specified by the word-element mask in VSR[VRB+32].",
      "",
      "If IMM=0b00011, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
      "sparse word elements in a source vector specified by the word-element",
      "mask in VSR[VRB+32] into the rightmost word elements of a",
      "result vector.",
      "",
      "pcv is placed into VSR[XT].",
      "",
      "Unused values of IMM are reserved.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Generate PCV from Doubleword Mask",
        "form": "X",
        "mnemonic": "xxgenpcvdm",
        "operands": [
          "XT",
          "VRB",
          "IMM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "IMM",
            "size": "5"
          },
          {
            "name": "VRB",
            "size": "5"
          },
          {
            "name": "919",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "If IMM=0b00000, let pcv be the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
      "leftmost doubleword elements of a source vector into the doubleword",
      "elements of a result vector specified by the doubleword-element mask",
      "in VSR[VRB+32].",
      "",
      "If IMM=0b00001, let pcv be the the permute",
      "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
      "doubleword elements in a source vector specified by the",
      "doubleword-element mask in VSR[VRB+32] into the leftmost",
      "doubleword elements of a result vector.",
      "",
      "If IMM=0b00010, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
      "rightmost doubleword elements of a source vector into the doubleword",
      "elements of a result vector specified by the doubleword-element mask",
      "in VSR[VRB+32].",
      "",
      "If IMM=0b00011, let pcv be the permute",
      "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
      "sparse doubleword elements in a source vector specified by the",
      "doubleword-element mask in VSR[VRB+32] into the rightmost",
      "doubleword elements of a result vector.",
      "",
      "pcv is placed into VSR[XT].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical AND",
        "form": "XX3",
        "mnemonic": "xxland",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "130",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ANDed with the contents of",
      "VSR[XB] and the result is placed into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical AND with Complement",
        "form": "XX3",
        "mnemonic": "xxlandc",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "138",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ANDed with the complement of",
      "the contents of VSR[XB] and the result is placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical Equivalence",
        "form": "XX3",
        "mnemonic": "xxleqv",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "186",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are exclusive-ORed with the",
      "contents of VSR[XB] and the complemented result is placed",
      "into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical NAND",
        "form": "XX3",
        "mnemonic": "xxlnand",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "178",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ANDed with the contents of",
      "VSR[XB] and the complemented result is placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical OR with Complement",
        "form": "XX3",
        "mnemonic": "xxlorc",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "170",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ORed with the complement of",
      "the contents of VSR[XB] and the result is placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical NOR",
        "form": "XX3",
        "mnemonic": "xxlnor",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "162",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ORed with the contents of",
      "VSR[XB] and the complemented result is placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical OR",
        "form": "XX3",
        "mnemonic": "xxlor",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "146",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are ORed with the contents of",
      "VSR[XB] and the result is placed into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Logical XOR",
        "form": "XX3",
        "mnemonic": "xxlxor",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "154",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of VSR[XA] are exclusive-ORed with the",
      "contents of VSR[XB] and the result is placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Merge High Word",
        "form": "XX3",
        "mnemonic": "xxmrghw",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "18",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of word element 0 of VSR[XA] are",
      "placed into word element 0 of VSR[XT].",
      "",
      "The contents of word element 0 of VSR[XB] are",
      "placed into word element 1 of VSR[XT].",
      "",
      "The contents of word element 1 of VSR[XA] are",
      "placed into word element 2 of VSR[XT].",
      "",
      "The contents of word element 1 of VSR[XB] are",
      "placed into word element 3 of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Merge Low Word",
        "form": "XX3",
        "mnemonic": "xxmrglw",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "50",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of word element 2 of VSR[XA] are",
      "placed into word element 0 of VSR[XT].",
      "",
      "The contents of word element 2 of VSR[XB] are",
      "placed into word element 1 of VSR[XT].",
      "",
      "The contents of word element 3 of VSR[XA] are",
      "placed into word element 2 of VSR[XT].",
      "",
      "The contents of word element 3 of VSR[XB] are",
      "placed into word element 3 of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Move From Accumulator",
        "form": "X",
        "mnemonic": "xxmfacc",
        "operands": [
          "AS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "AS",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "0",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "177",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, the contents of row",
      "i of ACC[AS] are placed into VSR[4AS+i].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Move To Accumulator",
        "form": "X",
        "mnemonic": "xxmtacc",
        "operands": [
          "AT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "1",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "177",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, the contents of",
      "VSR[4AT+i] are placed into row i of",
      "ACC[AT].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Permute",
        "form": "XX3",
        "mnemonic": "xxperm",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "26",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let bytes 0:15 of src be the contents of VSR[XA].",
      "",
      "Let bytes 16:31 of src be the contents of VSR[XT].",
      "",
      "Let the permute control vector pcv be the contents of",
      "VSR[XB].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let idx be the unsigned integer in bits 3:7 of byte",
      "element i of pcv.",
      "",
      "",
      "The contents of byte element idx of src is",
      "placed into byte element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Permute Right-indexed",
        "form": "XX3",
        "mnemonic": "xxpermr",
        "operands": [
          "XT",
          "XA",
          "XB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "58",
            "size": "8"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let bytes 0:15 of src be the contents of VSR[XA].",
      "",
      "Let bytes 16:31 of src be the contents of VSR[XT].",
      "",
      "Let the permute control vector pcv be the contents of",
      "VSR[XB].",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let idx be the unsigned integer in bits 3:7 of byte",
      "element i of pcv.",
      "",
      "",
      "The contents of byte element 31-idx of src is",
      "placed into byte element i of VSR[XT].",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Permute Doubleword Immediate",
        "form": "XX3",
        "mnemonic": "xxpermdi",
        "operands": [
          "XT",
          "XA",
          "XB",
          "DM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "0",
            "size": "1"
          },
          {
            "name": "DM",
            "size": "2"
          },
          {
            "name": "10",
            "size": "5"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "If DM.bit[0]=0, the contents of doubleword element",
      "0 of VSR[XA] are placed into doubleword",
      "element 0 of VSR[XT].",
      "Otherwise the contents of doubleword element 1 of",
      "VSR[XA] are placed into doubleword element 0",
      "of VSR[XT].",
      "",
      "If DM.bit[1]=0, the contents of doubleword element",
      "0 of VSR[XB] are placed into doubleword",
      "element 1 of VSR[XT].",
      "Otherwise the contents of doubleword element 1 of",
      "VSR[XB] are placed into doubleword element 1",
      "of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Permute Extended",
        "form": "8RR:XX4",
        "mnemonic": "xxpermx",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "17"
          },
          {
            "name": "UIM",
            "size": "3"
          },
          {
            "name": "34",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "0",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "Let UIM specify which 32-byte section of the long vector",
      "that src contains.",
      "",
      "Let src be the concatenation VSR[XA] and",
      "VSR[XB], comprising a 32-byte section of up to a 256-byte",
      "vector.",
      "",
      "For each integer value i from 0 to 15, do the following.",
      "",
      "",
      "",
      "Let eidx be the contents of bits 3:7 of byte element",
      "i of VSR[XC].",
      "",
      "",
      "If UIM is equal to the contents of bits 0:2 of byte",
      "element i of VSR[XC], the contents of byte",
      "element eidx of src are placed into byte",
      "element i of VSR[XT].",
      "Otherwise, the contents of byte element i of VSR[XT] are set to 0.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Select",
        "form": "XX4",
        "mnemonic": "xxsel",
        "operands": [
          "XT",
          "XA",
          "XB",
          "XC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "C",
            "size": "5"
          },
          {
            "name": "3",
            "size": "2"
          },
          {
            "name": "CX",
            "size": "1"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let XC be the value 32CX + C.",
      "",
      "Let src1 be the contents of VSR[XA].",
      "",
      "Let src2 be the contents of VSR[XB].",
      "",
      "Let mask be the contents of VSR[XC].",
      "",
      "The value, (src1mask)|(src2mask), is",
      "placed into VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Set Accumulator to Zero",
        "form": "X",
        "mnemonic": "xxsetaccz",
        "operands": [
          "AT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "AT",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "3",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "177",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "For each integer value i from 0 to 3, the contents of row",
      "i of ACC[AT] are set to 0.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Shift Left Double by Word Immediate",
        "form": "XX3",
        "mnemonic": "xxsldwi",
        "operands": [
          "XT",
          "XA",
          "XB",
          "SHW"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "A",
            "size": "5"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "0",
            "size": "1"
          },
          {
            "name": "SHW",
            "size": "2"
          },
          {
            "name": "2",
            "size": "5"
          },
          {
            "name": "AX",
            "size": "1"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XA be the value 32AX + A.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "Let vsrc be the concatenation of the contents of",
      "VSR[XA] followed by the contents of VSR[XB].",
      "",
      "Words SHW:SHW+3 of vsrc are placed into",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Splat Immediate Byte",
        "form": "X",
        "mnemonic": "xxspltib",
        "operands": [
          "XT",
          "IMM8"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "0",
            "size": "2"
          },
          {
            "name": "IMM8",
            "size": "8"
          },
          {
            "name": "360",
            "size": "10"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the sum 32TX + T.",
      "",
      "The value IMM8 is copied into each byte element of",
      "VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Splat Immediate Double-Precision",
        "form": "8RR:D",
        "mnemonic": "xxspltidp",
        "operands": [
          "XT",
          "IMM32"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "imm0",
            "size": "16"
          },
          {
            "name": "32",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "2",
            "size": "4"
          },
          {
            "name": "TX",
            "size": "1"
          },
          {
            "name": "imm1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let IMM32 be the concatenation of imm0 and",
      "imm1, representing a single-precision value.",
      "",
      "IMM32 is converted to double-precision format and placed",
      "into each doubleword element of VSR[XT].",
      "",
      "If IMM32 specifies a single-precision denormal value",
      "(i.e., bits 1:8 equal to 0 and bits 9:31 not equal to 0), the result",
      "is undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Splat Immediate Word",
        "form": "8RR:D",
        "mnemonic": "xxspltiw",
        "operands": [
          "XT",
          "IMM32"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "imm0",
            "size": "16"
          },
          {
            "name": "32",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "3",
            "size": "4"
          },
          {
            "name": "TX",
            "size": "1"
          },
          {
            "name": "imm1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let IMM32 be the concatenation of imm0 and",
      "imm1.",
      "",
      "IMM32 is placed into each word element of VSR[XT].",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Splat Immediate32 Doubleword Indexed",
        "form": "8RR:D",
        "mnemonic": "xxsplti32dx",
        "operands": [
          "XT",
          "IX",
          "IMM32"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "80",
            "size": "12"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "imm0",
            "size": "16"
          },
          {
            "name": "32",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "0",
            "size": "3"
          },
          {
            "name": "IX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          },
          {
            "name": "imm1",
            "size": "16"
          }
        ],
        "release": "v3.1"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let IMM32 be the concatenation of imm0 and",
      "imm1.",
      "",
      "IMM32 is placed into word element IX of each",
      "doubleword element of VSR[XT].",
      "The contents of the remaining word elements are not modified.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "VSX Vector Splat Word",
        "form": "XX2",
        "mnemonic": "xxspltw",
        "operands": [
          "XT",
          "XB",
          "UIM"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "60",
            "size": "6"
          },
          {
            "name": "T",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "UIM",
            "size": "2"
          },
          {
            "name": "B",
            "size": "5"
          },
          {
            "name": "164",
            "size": "9"
          },
          {
            "name": "BX",
            "size": "1"
          },
          {
            "name": "TX",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "",
      "Let XT be the value 32TX + T.",
      "",
      "Let XB be the value 32BX + B.",
      "",
      "The contents of word element UIM of VSR[XB]",
      "are replicated in each word element of VSR[XT].",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Instruction Cache Block Invalidate",
        "form": "X",
        "mnemonic": "icbi",
        "operands": [
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "982",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is Memory Coherence Required and a block containing the byte",
      "addressed by EA is in the instruction cache of any processors, the",
      "block is invalidated in those instruction caches.",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is not Memory Coherence Required and the block is in the instruction",
      "cache of this processor, the block is invalidated in that instruction",
      "cache.",
      "",
      "The function of this instruction is independent of whether the block",
      "containing the byte addressed by EA is in storage that is Write",
      "Through Required or Caching Inhibited.",
      "",
      "This instruction is treated as a Load (see Section",
      "), except",
      "that reference and change recording need not be done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Instruction Cache Block Touch",
        "form": "X",
        "mnemonic": "icbt",
        "operands": [
          "CT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "CT",
            "size": "4"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "22",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The icbt instruction provides a hint that the",
      "program will probably soon execute code from the block containing the",
      "byte addressed by EA, and that the block containing the byte",
      "addressed by EA is to be loaded into the cache specified by the CT",
      "field.",
      "(See",
      "Section",
      "of Book II.) If the CT field is set to a value not supported by the",
      "implementation, no operation is performed.",
      "",
      "The hint is ignored if the block is Caching Inhibited.",
      "",
      "This instruction treated as a Load (see Section",
      "), except",
      "that the system data storage error handler is not invoked, and",
      "reference and change recording need not be done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Data Cache Block Touch",
        "form": "X",
        "mnemonic": "dcbt",
        "operands": [
          "RA",
          "RB",
          "TH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "TH",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "278",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The dcbt instruction provides a hint that",
      "describes a block or data stream to which the program may perform a",
      "Load access.",
      "The instruction is also used to indicate imminent access or end of",
      "access to described load and store data streams.",
      "A hint that the program will probably soon load from a given storage",
      "location is ignored if the location is Caching Inhibited or Guarded.",
      "",
      "The only operation that is caused by the dcbt",
      "instruction is the providing of the hint.",
      "The actions (if any) taken by the processor in response to the hint",
      "are not considered to be caused by or associated with the",
      "dcbt instruction (e.g., dcbt",
      "is considered not to cause any data accesses).",
      "No means are provided by which software can synchronize these actions",
      "with the execution of the instruction stream.",
      "For example, these actions are not ordered by memory barriers.",
      "",
      "The dcbt instruction may complete before the",
      "operation it causes has been performed.",
      "",
      "The nature of the hint depends, in part, on the value of the TH",
      "field, as specified at the beginning of this section.",
      "If TH0b01010 and TH0b01011, this instruction is",
      "treated as a Load (see Section",
      "), except",
      "that the system data storage error handler is not invoked, and",
      "reference and change recording need not be done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Data Cache Block Touch for Store",
        "form": "X",
        "mnemonic": "dcbtst",
        "operands": [
          "RA",
          "RB",
          "TH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "TH",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "246",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The dcbtst instruction provides a hint that",
      "describes a block or data stream to which the program may perform a",
      "Store access, or indicates the expected use thereof.",
      "A hint that the program will soon store to a given storage location",
      "is ignored if the location is Caching Inhibited or Guarded.",
      "",
      "The only operation that is caused by the dcbtst instruction is the providing of the hint.",
      "The actions (if any) taken by the processor in response to the hint",
      "are not considered to be caused by or associated with the",
      "dcbtst instruction (e.g., dcbtst is considered not to cause any data accesses).",
      "No means are provided by which software can synchronize these actions",
      "with the execution of the instruction stream.",
      "For example, these actions are not ordered by memory barriers.",
      "",
      "The dcbtst instruction may complete before the",
      "operation it causes has been performed.",
      "",
      "The nature of the hint depends, in part, on the value of the TH",
      "field, as specified at the beginning of this section.",
      "If TH0b01010 and TH0b01011, this instruction is",
      "treated as a Store (see Section",
      "), except",
      "that the system data storage error handler is not invoked, reference",
      "recording need not be done, and change recording is not done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Data Cache Block set to Zero",
        "form": "X",
        "mnemonic": "dcbz",
        "operands": [
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1014",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "All bytes in the block containing the byte addressed by EA are set to",
      "zero.",
      "",
      "This instruction is treated as a Store (see Section",
      ").",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Data Cache Block Store",
        "form": "X",
        "mnemonic": "dcbst",
        "operands": [
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "54",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is Memory Coherence Required and a block containing the byte",
      "addressed by EA is in the data cache of any processor and any",
      "locations in the block are considered to be modified there, those",
      "locations are written to main storage, additional locations in the",
      "block may be written to main storage, and the block ceases to be",
      "considered to be modified in that data cache.",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is not Memory Coherence Required and the block is in the data cache",
      "of this processor and any locations in the block are considered to be",
      "modified there, those locations are written to main storage,",
      "additional locations in the block may be written to main storage, and",
      "the block ceases to be considered to be modified in that data cache.",
      "",
      "The function of this instruction is independent of whether the block",
      "containing the byte addressed by EA is in storage that is Write",
      "Through Required or Caching Inhibited.",
      "",
      "This instruction is treated as a Load (see Section",
      "), except",
      "that reference and change recording need not be done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Data Cache Block Flush",
        "form": "X",
        "mnemonic": "dcbf",
        "operands": [
          "RA",
          "RB",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "L",
            "size": "2"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "86",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "L=0",
      "",
      "",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is Memory Coherence Required and a block containing the byte",
      "addressed by EA is in the data cache of any processor and any",
      "locations in the block are considered to be modified there, those",
      "locations are written to main storage and additional locations in the",
      "block may be written to main storage.",
      "The block is invalidated in the data caches of all processors.",
      "",
      "",
      "If the block containing the byte addressed by EA is in storage that",
      "is not Memory Coherence Required and the block is in the data cache",
      "of this processor and any locations in the block are considered to be",
      "modified there, those locations are written to main storage and",
      "additional locations in the block may be written to main storage.",
      "The block is invalidated in the data cache of this processor.",
      "",
      "",
      "L=1 (dcbf local)",
      "",
      "",
      "",
      "The L=1 form of the dcbf instruction permits a",
      "program to limit the scope of the flush operation to the data",
      "cache of this processor.",
      "If the block containing the byte addressed by EA is in the data cache",
      "of this processor, it is removed from this cache.",
      "The coherence of the block is maintained to the extent required by",
      "the Memory Coherence Required storage attribute.",
      "",
      "",
      "L = 3 (dcbf local primary)",
      "",
      "",
      "",
      "The L=3 form of the dcbf instruction permits a",
      "program to limit the scope of the flush operation to the primary",
      "data cache of this processor.",
      "If the block containing the byte addressed by EA is in the primary",
      "data cache of this processor, it is removed from this cache.",
      "The coherence of the block is maintained to the extent required by",
      "the Memory Coherence Required storage attribute.",
      "",
      "",
      "L = 4 (data cache block flush to persistent storage)",
      "",
      "",
      "",
      "The L=4 form of the dcbf instruction performs all",
      "of the functions of dcbf with L=0.",
      "After all writes to main storage, caused by these functions, have",
      "updated main storage, if the block maps to main storage that is",
      "backed by persistent storage then all locations in the block in main",
      "storage that are considered to be modified relative to persistent",
      "storage are written to persistent storage and additional locations in",
      "the block in main storage may be written to persistent storage.",
      "",
      "",
      "L = 6 (data cache block store to persistent storage)",
      "",
      "",
      "",
      "The L=6 form of the dcbf instruction performs all",
      "of the functions of dcbst.",
      "After all writes to main storage, caused by these functions, have",
      "updated main storage, if the block maps to main storage that is",
      "backed by persistent storage then all locations in the block in main",
      "storage that are considered to be modified relative to persistent",
      "storage are written to persistent storage and additional locations in",
      "the block in main storage may be written to persistent storage.",
      "Programming NoteThis form of the  instruction is considered",
      "to be a functional extension of , and its",
      "extended mnemonic reflects that association.",
      "",
      "",
      "For the L operand, the values 2, 5, and 7 are reserved.",
      "The results of executing a dcbf instruction with",
      "L=2, 5, or 7 are boundedly undefined.",
      "",
      "The function of this instruction is independent of whether the block",
      "containing the byte addressed by EA is in storage that is Write",
      "Through Required or Caching Inhibited.",
      "",
      "This instruction is treated as a Load (see Section",
      "), except",
      "that reference and change recording need not be done.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Copy",
        "form": "X",
        "mnemonic": "copy",
        "operands": [
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "774",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "The 128 bytes in storage, and associated metadata,  addressed by EA",
      "is loaded into the copy buffer.",
      "",
      "If the EA is not a multiple of 128, the system alignment error",
      "handler is invoked.",
      "",
      "If the specified block is in storage that is Caching Inhibited, the",
      "system data storage error handler is invoked",
      "",
      "This instruction is treated as a Load (see",
      "Section,",
      "Cache Management Instructions ), except that the data transfer",
      "ordering is described in",
      "Section,",
      "Storage Ordering of Copy/Paste-Initiated Data Transfers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Paste",
        "form": "X",
        "mnemonic": "paste.",
        "operands": [
          "RA",
          "RB",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "902",
            "size": "10"
          },
          {
            "name": "Rc",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "If there was a copy-paste sequence error or a translation conflict,",
      "set CR0 to indicate failure.  Otherwise, continue as follows.",
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If L=1, then set metadata bits in the copy buffer to zero.",
      "",
      "The physical target of the operation, and by implication the function",
      "to be performed, is determined by the real address that is translated",
      "from EA.",
      "If the real address is in the platforms system memory, a simple copy",
      "is performed.",
      "If the real address has an associated mapping to another system, the",
      "copy buffer is transmitted to the other system.",
      "If the real address is control memory for a device, the contents of",
      "the copy buffer is queued to the device.",
      "There is a wait for completion status on the data transfer.",
      "CR0 is set as follows based on the completion status.",
      "",
      "",
      "",
      "",
      "The state of the Copy-Paste Facility is cleared.",
      "",
      "If MSRPR=1, paste. with L=0 is an invalid form.",
      "",
      "If the EA is not a multiple of 128, the system alignment error",
      "handler is invoked.",
      "",
      "If the specified block is in storage that is Caching Inhibited, the",
      "system data storage error handler is invoked.",
      "",
      "If the associated copy specified control memory",
      "or the paste.",
      "specifies control memory that was not properly configured, the data",
      "storage error handler will be invoked.",
      "",
      "This instruction is treated as a Store (see",
      "Section,",
      "Cache Management Instructions ), except that the data transfer",
      "ordering is described in",
      "Section,",
      "Storage Ordering of Copy/Paste-Initiated Data Transfers.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Copy-Paste Abort",
        "form": "X",
        "mnemonic": "cpabort",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "838",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The cpabort instruction causes a data transfer to",
      "fail if one is in progress.",
      "",
      "Any pending errors in the Copy-Paste Facility are cleared and the",
      "state is reset to prepare for a new copy.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word Atomic",
        "form": "X",
        "mnemonic": "lwat",
        "operands": [
          "RT",
          "RA",
          "FC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "FC",
            "size": "5"
          },
          {
            "name": "582",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be (RA).",
      "The least significant word of RT and the word of storage at EA are",
      "updated as specified by load atomic function code FC.",
      "The most significant word of RT is set to zero.",
      "Input operands are function code specific, and may include the least",
      "significant words of RT+1 and RT+2, and  mem(EA-4,12)",
      "",
      "Figure",
      "contains the defined function codes.",
      "An attempt to execute lwat specifying a reserved",
      "function code will cause the system data storage error handler to be",
      "invoked.",
      "",
      "EA must be a multiple of 4, and the portion of mem(EA-4,12) accessed",
      "by the instruction must be contained within an aligned 32-byte block",
      "of storage.",
      "If either of these requirements is not satisfied, the system",
      "alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword Atomic",
        "form": "X",
        "mnemonic": "ldat",
        "operands": [
          "RT",
          "RA",
          "FC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "FC",
            "size": "5"
          },
          {
            "name": "614",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be (RA).",
      "RT and the doubleword of storage at EA are updated as specified by",
      "load atomic function code FC.",
      "Input operands are function code specific, and may include RT+1,",
      "RT+2, and  mem(EA-8,24)",
      "",
      "Figure",
      "contains the defined function codes.",
      "An attempt to execute ldat specifying a reserved",
      "function code will cause the system data storage error handler to be",
      "invoked.",
      "",
      "EA must be a multiple of 8, and the portion of mem(EA-8,24) accessed",
      "by the instruction must be contained within an aligned 32-byte block",
      "of storage.",
      "If either of these requirements is not satisfied, the system",
      "alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word Atomic",
        "form": "X",
        "mnemonic": "stwat",
        "operands": [
          "RS",
          "RA",
          "FC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "FC",
            "size": "5"
          },
          {
            "name": "710",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be (RA).",
      "Four or eight bytes of storage at EA are updated as specified by",
      "store atomic function code FC.",
      "Input operands are function code specific, and may include",
      "RS and  mem(EA,8).",
      "",
      "Figure",
      "contains the defined function codes.",
      "An attempt to execute stwat specifying a reserved",
      "function code will cause the system data storage error handler to be",
      "invoked.",
      "",
      "EA must be a multiple of 4, and the portion of  mem(EA,8) accessed by",
      "the instruction must be contained within an aligned 32-byte block of",
      "storage.",
      "If either of these requirements is not satisfied, the system",
      "alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword Atomic",
        "form": "X",
        "mnemonic": "stdat",
        "operands": [
          "RS",
          "RA",
          "FC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "FC",
            "size": "5"
          },
          {
            "name": "742",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be (RA).",
      "Eight or sixteen bytes of storage at EA are updated as specified by",
      "store atomic function code FC.",
      "Input operands are function code specific, and may include RS and",
      "mem(EA,16).",
      "",
      "Figure",
      "contains the defined function codes.",
      "An attempt to execute stdat specifying a reserved",
      "function code will cause the system data storage error handler to be",
      "invoked.",
      "",
      "EA must be a multiple of 8, and the portion of  mem(EA,16) accessed",
      "by the instruction must be contained within an aligned 32-byte block",
      "of storage.",
      "If either of these requirements is not satisfied, the system",
      "alignment error handler is invoked.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Instruction Synchronize",
        "form": "XL",
        "mnemonic": "isync",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "150",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "Executing an isync instruction ensures that all",
      "instructions preceding the isync instruction have",
      "completed before the isync instruction completes,",
      "and that no subsequent instructions are initiated until after the",
      "isync instruction completes.",
      "It also ensures that all instruction cache block invalidations caused",
      "by icbi instructions preceding the",
      "isync instruction have been performed with",
      "respect to the processor executing the isync",
      "instruction, and then causes any prefetched instructions to be",
      "discarded.",
      "",
      "Except as described in the preceding sentence, the isync instruction may complete before storage accesses associated",
      "with instructions preceding the isync instruction",
      "have been performed.",
      "",
      "This instruction is context synchronizing (see Book III).",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte And Reserve Indexed",
        "form": "X",
        "mnemonic": "lbarx",
        "operands": [
          "RT",
          "RA",
          "RB",
          "EH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "52",
            "size": "10"
          },
          {
            "name": "EH",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63. RT0:55 are set to 0.",
      "",
      "This instruction creates a reservation for use by a",
      "stbcx. or waitrsv",
      "instruction.",
      "A real address computed from the EA as described in Section",
      " is associated with the",
      "reservation, and replaces any address previously associated with the",
      "reservation.",
      "A length of 1 byte is associated with the reservation, and replaces",
      "any length previously associated with the reservation.",
      "",
      "The value of EH provides a hint as to whether the program will",
      "perform a subsequent store to the byte in storage addressed by EA",
      "before some other processor attempts to modify it.",
      "",
      "",
      "",
      "[0.72in][l]0Other programs might attempt to modify the byte",
      "in storage addressed by EA regardless of the result of the",
      "corresponding stbcx. instruction.",
      "",
      "",
      "[0.72in][l]1Other programs will not attempt to modify the",
      "byte in storage addressed by EA until the program that has acquired",
      "the lock performs a subsequent store releasing the lock.",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword And Reserve Indexed",
        "form": "X",
        "mnemonic": "lharx",
        "operands": [
          "RT",
          "RA",
          "RB",
          "EH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "116",
            "size": "10"
          },
          {
            "name": "EH",
            "size": "1"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63. RT0:47 are set to 0.",
      "",
      "This instruction creates a reservation for use by a",
      "sthcx. or waitrsv",
      "instruction.",
      "A real address computed from the EA as described in Section",
      " is associated with the",
      "reservation, and replaces any address previously associated with the",
      "reservation.",
      "A length of 2 bytes is associated with the reservation, and replaces",
      "any length previously associated with the reservation.",
      "",
      "The value of EH provides a hint as to whether the program will",
      "perform a subsequent store to the halfword in storage addressed by EA",
      "before some other processor attempts to modify it.",
      "",
      "",
      "",
      "[0.72in][l]0Other programs might attempt to modify the",
      "halfword in storage addressed by EA regardless of the result of the",
      "corresponding sthcx. instruction.",
      "",
      "",
      "[0.72in][l]1Other programs will not attempt to modify the",
      "halfword in storage addressed by EA until the program that has",
      "acquired the lock performs a subsequent store releasing the lock.",
      "",
      "",
      "EA must be a multiple of 2.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word And Reserve Indexed",
        "form": "X",
        "mnemonic": "lwarx",
        "operands": [
          "RT",
          "RA",
          "RB",
          "EH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "20",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The word in storage addressed by EA is loaded into",
      "RT32:63. RT0:31 are set to 0.",
      "",
      "This instruction creates a reservation for use by a",
      "stwcx. or waitrsv",
      "instruction.",
      "A real address computed from the EA as described in Section",
      " is associated with the",
      "reservation, and replaces any address previously associated with the",
      "reservation.",
      "A length of 4 bytes is associated with the reservation, and replaces",
      "any length previously associated with the reservation.",
      "",
      "The value of EH provides a hint as to whether the program will",
      "perform a subsequent store to the word in storage addressed by EA",
      "before some other processor attempts to modify it.",
      "",
      "",
      "",
      "[0.72in][l]0Other programs might attempt to modify the word",
      "in storage addressed by EA regardless of the result of the",
      "corresponding stwcx. instruction.",
      "",
      "",
      "[0.72in][l]1Other programs will not attempt to modify the",
      "word in storage addressed by EA until the program that has acquired",
      "the lock performs a subsequent store releasing the lock.",
      "",
      "",
      "EA must be a multiple of 4.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte Conditional Indexed",
        "form": "X",
        "mnemonic": "stbcx.",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1389",
            "size": "11"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If a reservation exists, the length associated with the reservation",
      "is 1 byte, and the real storage location specified by the",
      "stbcx. is the same as the real storage location",
      "specified by the lbarx instruction that",
      "established the reservation, (RS)56:63 are stored",
      "into the byte in storage addressed by EA.",
      "",
      "If a reservation exists, and either the length associated with the",
      "reservation is not 1 byte or the real storage location specified by",
      "the stbcx. is not the same as the real storage",
      "location specified by the lbarx instruction that",
      "established the reservation, the following applies.",
      "Let z denote the smallest real page size supported by the",
      "implementation.",
      "If the real storage location specified by the stbcx. is in the same aligned z-byte block of real storage as the",
      "real storage location specified by the lbarx",
      "instruction that established the reservation, it is undefined whether",
      "(RS)56:63 are stored into the byte in storage",
      "addressed by EA. Otherwise, no store is performed.",
      "",
      "If a reservation does not exist, no store is performed.",
      "",
      "CR Field 0 is set as follows.",
      "n is a 1-bit value that indicates whether the store was performed,",
      "except that if, per the preceding description, it is undefined",
      "whether the store is performed, the value of n is undefined (and need",
      "not reflect whether the store was performed).",
      "",
      "CR0LT GT EQ SO = 0b00 || n || XERSO",
      "",
      "The reservation is cleared.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword Conditional Indexed",
        "form": "X",
        "mnemonic": "sthcx.",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1453",
            "size": "11"
          }
        ],
        "release": "v2.06"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If a reservation exists, the length associated with the reservation",
      "is 2 bytes, and the real storage location specified by the",
      "sthcx. is the same as the real storage location",
      "specified by the lharx instruction that",
      "established the reservation, (RS)48:63 are stored",
      "into the halfword in storage addressed by EA.",
      "",
      "If a reservation exists, and either the length associated with the",
      "reservation is not 2 bytes or the real storage location specified by",
      "the sthcx. is not the same as the real storage",
      "location specified by the lharx instruction that",
      "established the reservation, the following applies.",
      "Let z denote the smallest real page size supported by the",
      "implementation.",
      "If the real storage location specified by the sthcx. is in the same aligned z-byte block of real storage as the",
      "real storage location specified by the lharx",
      "instruction that established the reservation, it is undefined whether",
      "(RS)48:63 are stored into the halfword in storage",
      "addressed by EA. Otherwise, no store is performed.",
      "",
      "If a reservation does not exist, no store is performed.",
      "",
      "CR Field 0 is set as follows.",
      "n is a 1-bit value that indicates whether the store was performed,",
      "except that if, per the preceding description, it is undefined",
      "whether the store is performed, the value of n is undefined (and need",
      "not reflect whether the store was performed).",
      "",
      "CR0LT GT EQ SO = 0b00 || n ||",
      "XERSO",
      "",
      "The reservation is cleared.",
      "",
      "EA must be a multiple of 2.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word Conditional Indexed",
        "form": "X",
        "mnemonic": "stwcx.",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "301",
            "size": "11"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If a reservation exists, the length associated with the reservation",
      "is 4 bytes, and the real storage location specified by the",
      "stwcx. is the same as the real storage location",
      "specified by the lwarx instruction that",
      "established the reservation, (RS)32:63 are stored",
      "into the word in storage addressed by EA.",
      "",
      "If a reservation exists, and either the length associated with the",
      "reservation is not 4 bytes or the real storage location specified by",
      "the stwcx. is not the same as the real storage",
      "location specified by the lwarx instruction that",
      "established the reservation, the following applies.",
      "Let z denote the smallest real page size supported by the",
      "implementation.",
      "If the real storage location specified by the stwcx. is in the same aligned z-byte block of real storage as the",
      "real storage location specified by the lwarx",
      "instruction that established the reservation, it is undefined whether",
      "(RS)32:63 are stored into the word in storage",
      "addressed by EA. Otherwise, no store is performed.",
      "",
      "If a reservation does not exist, no store is performed.",
      "",
      "CR Field 0 is set as follows.",
      "n is a 1-bit value that indicates whether the store was performed,",
      "except that if, per the preceding description, it is undefined",
      "whether the store is performed, the value of n is undefined (and need",
      "not reflect whether the store was performed).",
      "",
      "CR0LT GT EQ SO = 0b00 || n ||",
      "XERSO",
      "",
      "The reservation is cleared.",
      "",
      "EA must be a multiple of 4.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword And Reserve Indexed",
        "form": "X",
        "mnemonic": "ldarx",
        "operands": [
          "RT",
          "RA",
          "RB",
          "EH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "84",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The doubleword in storage addressed by EA is loaded into RT.",
      "",
      "This instruction creates a reservation for use by a",
      "stdcx. or waitrsv",
      "instruction.",
      "A real address computed from the EA as described in Section",
      " is associated with the",
      "reservation, and replaces any address previously associated with the",
      "reservation.",
      "A length of 8 bytes is associated with the reservation, and replaces",
      "any length previously associated with the reservation.",
      "",
      "The value of EH provides a hint as to whether the program will",
      "perform a subsequent store to the doubleword in storage addressed by",
      "EA before some other processor attempts to modify it.",
      "",
      "",
      "",
      "[0.72in][l]0Other programs might attempt to modify the",
      "doubleword in storage addressed by EA regardless of the result of the",
      "corresponding stdcx. instruction.",
      "",
      "",
      "[0.72in][l]1Other programs will not attempt to modify the",
      "doubleword in storage addressed by EA until the program that has",
      "acquired the lock performs a subsequent store releasing the lock.",
      "",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword Conditional Indexed",
        "form": "X",
        "mnemonic": "stdcx.",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "429",
            "size": "11"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If a reservation exists, the length associated with the reservation",
      "is 8 bytes, and the real storage location specified by the",
      "stdcx. is the same as the real storage location",
      "specified by the ldarx instruction that",
      "established the reservation, (RS) is stored into the doubleword in",
      "storage addressed by EA.",
      "",
      "If a reservation exists, and either the length associated with the",
      "reservation is not 8 bytes or the real storage location specified by",
      "the stdcx. is not the same as the real storage",
      "location specified by the ldarx instruction that",
      "established the reservation, the following applies.",
      "Let z denote the smallest real page size supported by the",
      "implementation.",
      "If the real storage location specified by the stdcx. is in the same aligned z-byte block of real storage as the",
      "real storage location specified by the ldarx",
      "instruction that established the reservation, it is undefined whether",
      "(RS) is stored into the doubleword in storage addressed by EA.",
      "Otherwise, no store is performed.",
      "",
      "If a reservation does not exist, no store is performed.",
      "",
      "CR Field 0 is set as follows.",
      "n is a 1-bit value that indicates whether the store was performed,",
      "except that if, per the preceding description, it is undefined",
      "whether the store is performed, the value of n is undefined (and need",
      "not reflect whether the store was performed).",
      "",
      "CR0LT GT EQ SO = 0b00 || n ||",
      "XERSO",
      "",
      "The reservation is cleared.",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Quadword And Reserve Indexed",
        "form": "X",
        "mnemonic": "lqarx",
        "operands": [
          "RTp",
          "RA",
          "RB",
          "EH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RTp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "276",
            "size": "10"
          },
          {
            "name": "EH",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The quadword in storage addressed by EA is loaded into RTp.",
      "",
      "This instruction creates a reservation for use by a",
      "stqcx. or waitrsv",
      "instruction.",
      "A real address computed from the EA as described in Section",
      " is associated with the",
      "reservation, and replaces any address previously associated with the",
      "reservation.",
      "A length of 16 bytes is associated with the reservation, and replaces",
      "any length previously associated with the reservation.",
      "",
      "The value of EH provides a hint as to whether the program will",
      "perform a subsequent store to the doubleword in storage addressed by",
      "EA before some other processor attempts to modify it.",
      "",
      "",
      "",
      "[0.72in][l]0Other programs might attempt to modify the",
      "doubleword in storage addressed by EA regardless of the result of the",
      "corresponding stqcx. instruction.",
      "",
      "",
      "[0.72in][l]1Other programs will not attempt to modify the",
      "doubleword in storage addressed by EA until the program that has",
      "acquired the lock performs a subsequent store releasing the lock.",
      "",
      "",
      "EA must be a multiple of 16.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      "If RTp is odd, RTp=RA, or RTp=RB the instruction form is invalid.",
      "If RTp=RA or RTp=RB, an attempt to execute this instruction will",
      "invoke the system illegal instruction error handler.",
      "(The RTp=RA case includes the case of RTp=RA=0.)",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Quadword Conditional Indexed",
        "form": "X",
        "mnemonic": "stqcx.",
        "operands": [
          "RSp",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RSp",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "365",
            "size": "11"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "",
      "If a reservation exists, the length associated with the reservation",
      "is 16 bytes, and the real storage location specified by the",
      "stqcx. is the same as the real storage location",
      "specified by the lqarx instruction that",
      "established the reservation, (RSp) is stored into the quadword in",
      "storage addressed by EA.",
      "",
      "If a reservation exists, and either the length associated with the",
      "reservation is not 16 bytes or the real storage location specified by",
      "the stqcx. is not the same as the real storage",
      "location specified by the lqarx instruction that",
      "established the reservation, the following applies.",
      "Let z denote the smallest real page size supported by the",
      "implementation.",
      "If the real storage location specified by the stqcx. is in the same aligned z-byte block of real storage as the",
      "real storage location specified by the lqarx",
      "instruction that established the reservation, it is undefined whether",
      "(RSp) is stored into the quadword in storage addressed by EA.",
      "Otherwise, no store is performed.",
      "",
      "If a reservation does not exist, no store is performed.",
      "",
      "CR Field 0 is set as follows.",
      "n is a 1-bit value that indicates whether the store was performed,",
      "except that if, per the preceding description, it is undefined",
      "whether the store is performed, the value of n is undefined (and need",
      "not reflect whether the store was performed).",
      "",
      "CR0LT GT EQ SO = 0b00 || n ||",
      "XERSO",
      "",
      "The reservation is cleared.",
      "",
      "EA must be a multiple of 16.",
      "If it is not, either the system alignment error handler is invoked or",
      "the results are boundedly undefined.",
      "",
      "If RSp is odd, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Synchronize",
        "form": "X",
        "mnemonic": "sync",
        "operands": [
          "L",
          "SC"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "L",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "598",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "",
      "",
      "case(0): hwsync",
      "",
      "",
      " case(1): lwsync",
      "",
      "",
      " case(2): ptesync",
      "",
      "",
      " case(4): phwsync",
      "",
      "",
      " case(5): plwsync",
      "",
      "",
      "The sync instruction creates a memory barrier",
      "(see Section ).",
      "The set of storage accesses and/or data transfers that is ordered by",
      "the memory barrier depends on the contents of the L and SC fields as",
      "follows.",
      "",
      "SC0",
      "",
      "",
      "",
      "SC=0",
      "",
      "",
      "",
      "The ordering done by the memory barrier is cumulative (regardless of",
      "the L and SC values).",
      "",
      "If L=0 or L=4 (or L=2), the sync instruction has",
      "the following additional properties.",
      "",
      "",
      "Programming NoteSection  contains a detailed",
      "description of how to modify instructions such that a well-defined",
      "result is obtained.",
      "",
      "The L values 3, 6, and 7 are reserved.",
      "",
      "The sync instruction may complete before storage",
      "accesses associated with instructions preceding the",
      "sync instruction have been performed.",
      "",
      "Figure",
      "shows the valid combinations of SC and L values.",
      "Instructions that use any of these combinations will execute",
      "correctly on processors that comply with versions of the architecture",
      "that precede Version 3.1 (in which versions the L field is two bits",
      "long, the SC field does not exist, and bits 8 and 14:15 of the",
      "sync instruction are reserved) and on processors",
      "that comply with Version 3.1 and subsequent versions of the",
      "architecture.",
      "If any other combination is used, the instruction form is invalid.",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Enforce In-order Execution of I/O",
        "form": "X",
        "mnemonic": "eieio",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "854",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The eieio instruction creates a memory barrier",
      "(see Section, Storage",
      "Access Ordering    ), which provides an ordering function for the",
      "storage accesses caused by Load, Store, and",
      "dcbz instructions executed by the processor",
      "executing the eieio instruction.",
      "These storage accesses are divided into the two sets listed below.",
      "The storage access caused by a dcbz instruction",
      "is ordered as a store.",
      "",
      "",
      "",
      "The operations caused by the stream variants of the",
      "dcbt and dcbtst instructions",
      "(i.e., the providing of hints) are ordered by eieio as a third set of operations, the operations caused by",
      "tlbie and tlbsync",
      "instructions (see Book III) are ordered by eieio",
      "as a fourth set of operations, and the operations caused by",
      "slbieg or slbiag and",
      "slbsync instructions (see Book III) are ordered",
      "by eieio as a fifth set of operations.",
      "",
      "Each of the five sets of storage accesses or operations is ordered",
      "independently of the other four sets.",
      "The ordering done by eieio's memory barrier for",
      "the second set is cumulative; the ordering done by eieio's memory barrier for the other four sets is not cumulative.",
      "",
      "The eieio instruction may complete before storage",
      "accesses associated with instructions preceding the",
      "eieio instruction have been performed.",
      "The eieio instruction may complete before",
      "operations caused by dcbt and dcbtst instructions preceding the eieio",
      "instruction have been performed",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Wait",
        "form": "X",
        "mnemonic": "wait",
        "operands": [
          "WC",
          "PL"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "WC",
            "size": "2"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "30",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "The wait instruction causes",
      "instruction fetching and execution to be suspended under certain",
      "conditions, depending on the values of the WC and PL fields.",
      "Instruction fetching and execution are resumed when the events",
      "specified by the WC field occur or in the rare case of an",
      "implementation-dependent event.",
      "",
      "The values of the WC field are as follows.",
      "",
      "",
      "[0.5in][l]0Resume instruction fetching and execution when",
      "an exception or event-based branch exception occurs.",
      "",
      "",
      "[0.5in][l]1Resume instruction fetching and execution when",
      "an exception or event-based branch exception occurs, or when a",
      "reservation made by the processor does not exist (see Section",
      ").",
      "",
      "",
      "[0.5in][l]2Resume instruction fetching and execution when",
      "an exception or event-based branch exception occurs, or when the",
      "amount of time specified by the PL field has passed.",
      "",
      "",
      "[0.5in][l]3Reserved.",
      "",
      "The values of the PL field are as follows.",
      "",
      "",
      "[0.5in][l]0b00A short wait time is specified.",
      "",
      "",
      "[0.5in][l]0b01:11Reserved.",
      "",
      "If WC=0, or if WC=1 and a reservation made by the processor exists,",
      "or if WC=2 and a value for PL that is not reserved is specified, the",
      "following applies.",
      "",
      "",
      "Engineering NoteBecause the waiting begins when the instruction completes, if the",
      "waiting is ended by an exception that causes a change of control flow",
      "(interrupt, event-based branch), the SPR that is set to reflect the",
      "point in the instruction stream at which the change of control flow",
      "occurred (e.g., SRR0 for a Decrementer interrupt) will contain the EA",
      "of the instruction following the  instruction.",
      "",
      "If WC=1 and a reservation made by the processor does not exist, or if",
      "WC=2 and a reserved value of PL is specified, the instruction is",
      "treated as a no-op.",
      "Engineering NoteBits 6 and 7 of the  instruction may be used",
      "in some implementations for an implementation-dependent field.",
      "Unless the intention is to use the implementation-dependent field,",
      "these bits must be coded zero.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Time Base",
        "form": "XFX",
        "mnemonic": "mftb",
        "operands": [
          "RT",
          "TBR"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "tbr1",
            "size": "5"
          },
          {
            "name": "tbr0",
            "size": "5"
          },
          {
            "name": "371",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "This instruction behaves as if it were an mfspr",
      "instruction; see the mfspr instruction",
      "description in",
      "Section",
      "of Book I.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Return from Event-Based Branch",
        "form": "XL",
        "mnemonic": "rfebb",
        "operands": [
          "S"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "14"
          },
          {
            "name": "S",
            "size": "1"
          },
          {
            "name": "146",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "BESCRGE is set to S.",
      "",
      "If there are no pending event-based exceptions, then the next",
      "instruction is fetched from the address EBBRR0:61 ||",
      "0b00 (when MSRSF=1) or 320 ||",
      "EBBRR32:61 || 0b00 (when MSRSF=0).",
      "If one or more pending event-based exceptions exist, an event-based",
      "branch is generated; in this case the value placed into EBBRR by the",
      "Event-Based Branch facility is the address of the instruction that",
      "would have been executed next had the event-based branch not occurred.",
      "",
      "If BESCR32:330b00 the instruction is treated",
      "as if the instruction form were invalid.",
      "",
      "See",
      "Section",
      "of Book III for additional information about this instruction.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Clear BHRB",
        "form": "X",
        "mnemonic": "clrbhrb",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "430",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "All BHRB entries are set to 0s.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Branch History Rolling Buffer Entry",
        "form": "XFX",
        "mnemonic": "mfbhrbe",
        "operands": [
          "RT",
          "BHRBE"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "bhrb1",
            "size": "5"
          },
          {
            "name": "bhrb0",
            "size": "5"
          },
          {
            "name": "302",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "The BHRBE field denotes an entry in the BHRB.",
      "If the designated entry is within the range of BHRB entries",
      "implemented and Performance Monitor alterts are disable (see",
      "Section of",
      "Book III), the contents of the designated BHRB entry are placed into",
      "register RT; otherwise, zero is placed into register RT.",
      "",
      "In order to ensure that the current BHRB contents are read by this",
      "instruction, one of the following must have occurred prior to this",
      "instruction and after all previous Branch and",
      "clrbhrb instructions have completed.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "System Call",
        "form": "SC",
        "mnemonic": "sc",
        "operands": [
          "LEV"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "17",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "14"
          },
          {
            "name": "LEV",
            "size": "7"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "1",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The effective address of the instruction following the System Call instruction is placed into SRR0.",
      "Bits 0:32, 37:41, and 48:63 of the MSR are placed into the",
      "corresponding bits of SRR1, and bits 33:36 and 42:47 of SRR1 are set",
      "to zero.",
      "",
      "Then a System Call interrupt is generated.",
      "The interrupt causes the MSR to be set as described in",
      "Section,",
      "Interrupt Definitions on",
      "pagesec:PPC3SChInterrupts-Interrupt-Definitions.",
      "The setting of the MSR is affected by the contents of the LEV field.",
      "LEV values greater than 2 are reserved.",
      "Bits 0:4 of the LEV field (instruction bits 20:24) are treated as a",
      "reserved field.",
      "",
      "The interrupt causes the next instruction to be fetched from",
      "effective address 0x0000000000000C00.",
      "",
      "This instruction is context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "System Call Vectored",
        "form": "SC",
        "mnemonic": "scv",
        "operands": [
          "LEV"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "17",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "14"
          },
          {
            "name": "LEV",
            "size": "7"
          },
          {
            "name": "reserved",
            "size": "3"
          },
          {
            "name": "1",
            "size": "2"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The effective address of the instruction following the System Call Vectored instruction is placed into the Link Register.",
      "Bits 0:32, 37:41, and 48:63 of the MSR are placed into the",
      "corresponding bits of Count Register, and bits 33:36 and 42:47 of",
      "Count Register are set to undefined values.",
      "",
      "Then a System Call Vectored interrupt is generated.",
      "The interrupt causes the MSR to be altered as described in Section",
      ".",
      "",
      "The interrupt causes the next instruction to be fetched as specified",
      "in LPCRAIL or LPCRHAIL as appropriate",
      "(see Section",
      ").",
      "",
      "The SRRs are not affected.",
      "",
      "This instruction is context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Return From System Call Vectored",
        "form": "XL",
        "mnemonic": "rfscv",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "82",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      " The result of ORing bits 48 and 49 of the Count Register is placed",
      "into MSR48.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of the Count Register is complemented and",
      "then ANDed with the result of ORing bits 58 and 49 of the Count",
      "Register and placed into MSR58.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of the Count Register is complemented and",
      "then ANDed with the result of ORing bits 59 and 49 of the Count",
      "Register and placed into MSR59.",
      "Bits 0:2, 4:32, 37:40, 49:50, 52:57, and 60:63 of the Count Register",
      "are placed into the corresponding bits of the MSR.",
      "",
      "If the new MSR value does not enable any pending exceptions, then the",
      "next instruction is fetched, under control of the new MSR value, from",
      "the address LR0:61 || 0b00 (when SF=1 in the new MSR",
      "value) or 320 || LR32:61 || 0b00",
      "(when SF=0 in the new MSR value).",
      "If the new MSR value enables one or more pending exceptions, the",
      "interrupt associated with the highest priority pending exception is",
      "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
      "by the interrupt processing mechanism (see Section",
      ") is the address of",
      "the instruction that would have been executed next had the interrupt",
      "not occurred.",
      "",
      "This instruction is privileged and context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Return From Interrupt Doubleword",
        "form": "XL",
        "mnemonic": "rfid",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "18",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "If MSR3=1 then bits 3 and 51 of SRR1 are placed into",
      "the corresponding bits of the MSR.",
      "The result of ORing bits 48 and 49 of SRR1 is placed into",
      "MSR48.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of SRR1 is complemented and then ANDed with",
      "the result of ORing bits 58 and 49 of SRR1 and placed into",
      "MSR58.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of SRR1 is complemented and then ANDed with",
      "the result of ORing bits 59 and 49 of SRR1 and placed into",
      "MSR59.",
      "Bits 0:2, 4:32, 37:40, 49:50, 52:57, and 60:63 of SRR1 are placed",
      "into the corresponding bits of the MSR.",
      "",
      "If  the new MSR value does not enable any pending exceptions, then",
      "the next instruction is fetched, under control of the new MSR value,",
      "from the address SRR00:61 || 0b00 (when SF=1 in the",
      "new MSR value) or 320 || SRR032:61",
      "|| 0b00 (when SF=0 in the new MSR value).",
      "If the new MSR value enables one or more pending exceptions, the",
      "interrupt associated with the highest priority pending exception is",
      "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
      "by the interrupt processing mechanism (see Section",
      ") is the address of",
      "the instruction that would have been executed next had the interrupt",
      "not occurred.",
      "",
      "This instruction is privileged and context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Hypervisor Return From Interrupt Doubleword",
        "form": "XL",
        "mnemonic": "hrfid",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "274",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.02"
      }
    ],
    "body": [
      "",
      "The result of ORing bits 48 and 49 of HSRR1 is placed into",
      "MSR48.",
      "The result of ANDing bit 41 of the MSR with bit 3 of HSRR1 and with",
      "the complement of bit 49 of HSRR1 is complemented and then ANDed with",
      "the result of ORing bits 58 and 49 of HSRR1 and placed into",
      "MSR58.",
      "The result of ANDing bit 41 of the MSR with bit 3 of HSRR1 and with",
      "the complement of bit 49 of HSRR1 is complemented and then ANDed with",
      "the result of ORing bits 59 and 49 of HSRR1 and placed into",
      "MSR59.",
      "Bits 0:32, 37:40, 49:57, and 60:63 of HSRR1 are placed into the",
      "corresponding bits of the MSR.",
      "",
      "If the new MSR value does not enable any pending exceptions, then the",
      "next instruction is fetched, under control of the new MSR value, from",
      "the address HSRR00:61 || 0b00 (when SF=1 in the new",
      "MSR value) or 320 || HSRR032:61 ||",
      "0b00 (when SF=0 in the new MSR value).",
      "If the new MSR value enables one or more pending exceptions, the",
      "interrupt associated with the highest priority pending exception is",
      "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
      "by the interrupt processing mechanism (see Section",
      ") is the address of",
      "the instruction that would have been executed next had the interrupt",
      "not occurred.",
      "",
      "This instruction is hypervisor privileged and context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Ultravisor Return From Interrupt Doubleword",
        "form": "XL",
        "mnemonic": "urfid",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "306",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0C"
      }
    ],
    "body": [
      "",
      "The result of ORing bits 48 and 49 of USRR1 is placed into",
      "MSR48.",
      "The result of ANDing bit 41 of USRR1 with bit 3 of USRR1 and with the",
      "complement of bit 49 of USRR1 is complemented and then ANDed with the",
      "result of ORing bits 58 and 49 of USRR1 and placed into",
      "MSR58.",
      "The result of ANDing bit 41 of USRR1 with bit 3 of USRR1 and with the",
      "complement of bit 49 of USRR1 is complemented and then ANDed with the",
      "result of ORing bits 59 and 49 of USRR1 and placed into",
      "MSR59.",
      "Bits 0:32, 37:41, 49:57, and 60:63 of USRR1 are placed into the",
      "corresponding bits of the MSR.",
      "",
      "If the new MSR value does not enable any pending exceptions, then the",
      "next instruction is fetched, under control of the new MSR value, from",
      "the address USRR00:61 || 0b00 (when SF=1 in the new",
      "MSR value) or 320 || USRR032:61 ||",
      "0b00 (when SF=0 in the new MSR value).",
      "If the new MSR value enables one or more pending exceptions, the",
      "interrupt associated with the highest priority pending exception is",
      "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
      "by the interrupt processing mechanism (see Section",
      ") is the address of",
      "the instruction that would have been executed next had the interrupt",
      "not occurred.",
      "",
      "This instruction is ultravisor privileged and context synchronizing.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Stop",
        "form": "XL",
        "mnemonic": "stop",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "19",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "370",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The thread is placed into power-saving mode and execution is stopped.",
      "",
      "The power-saving level that is entered is determined by the contents",
      "of the PSSCR (see Section",
      ").",
      "The thread state that is maintained depends on the power-saving level",
      "that is entered.",
      "The thread state that is maintained at each power-saving level is",
      "implementation-dependent, subject to the restrictions specified in",
      "Section",
      ".MSREE=0)",
      "or in the corresponding interrupt handler (if",
      "MSREE=1).",
      "",
      "The thread remains in power-saving mode until either a System Reset",
      "exception or certain other events occur.",
      "The events that may cause exit from power-saving mode are specified",
      "by PSSCREC, LPCRPECE, and",
      "SMFCTRLUDEE.",
      "If the event that causes the exit is a System Reset, Machine Check,",
      "or Hypervisor Maintenance exception, resource state that would be",
      "lost if the exception occurred when the thread was not in",
      "power-saving mode may be lost.",
      "",
      "This instruction should not be executed in ultravisor state because",
      "that scenario may not be thoroughly verified.",
      "",
      "This instruction is privileged and context synchronizing.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Byte and Zero Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "lbzcix",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "853",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The byte in storage addressed by EA is loaded into",
      "RT56:63. RT0:55 are set to 0.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Halfword and Zero Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "lhzcix",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "821",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The halfword in storage addressed by EA is loaded into",
      "RT48:63. RT0:47 are set to 0.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Word and Zero Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "lwzcix",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "789",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The word in storage addressed by EA is loaded into",
      "RT32:63. RT0:31 are set to 0.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Load Doubleword Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "ldcix",
        "operands": [
          "RT",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "885",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "The doubleword in storage addressed by EA is loaded into RT.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Byte Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "stbcix",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "981",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)56:63 are stored into the byte in storage",
      "addressed by EA.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Halfword Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "sthcix",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "949",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)48:63 are stored into the halfword in storage",
      "addressed by EA.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Word Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "stwcix",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "917",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS)32:63 are stored into the word in storage",
      "addressed by EA.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Store Doubleword Caching Inhibited Indexed",
        "form": "X",
        "mnemonic": "stdcix",
        "operands": [
          "RS",
          "RA",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1013",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "Let the effective address (EA) be the sum (RA|0)+(RB).",
      "(RS) is stored into the doubleword in storage addressed by EA.",
      "",
      "The storage access caused by this instruction is performed as though",
      "the specified storage location is Caching Inhibited and Guarded.",
      "",
      "This instruction is hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Hash Store Privileged",
        "form": "X",
        "mnemonic": "hashstp",
        "operands": [
          "RB",
          "offset(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "D",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "658",
            "size": "10"
          },
          {
            "name": "DX",
            "size": "1"
          }
        ],
        "release": "v3.1B"
      }
    ],
    "body": [
      "",
      "Let DW be the value 32xDX + D.",
      "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
      "Let the effective address (EA) be the sum (RA) + offset.",
      "The doubleword hash value computed from the contents of RA, RB, and",
      "the hypervisor privileged SPR HASHPKEYR, as specified by the",
      "HashDigest function  described in",
      "Section of Book I,",
      "is stored into the doubleword in storage addressed by EA.",
      "",
      "This instruction is privileged.",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either an Alignment interrupt occurs or the results are",
      "boundedly undefined.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Hash Check Privileged",
        "form": "X",
        "mnemonic": "hashchkp",
        "operands": [
          "RB",
          "offset(RA)"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "D",
            "size": "5"
          },
          {
            "name": "RA",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "690",
            "size": "10"
          },
          {
            "name": "DX",
            "size": "1"
          }
        ],
        "release": "v3.1B"
      }
    ],
    "body": [
      "",
      "Let DW be the value 32xDX + D.",
      "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
      "Let the effective address (EA) be the sum (RA) + offset.",
      "The doubleword in storage addressed by EA is read and compared with",
      "the doubleword hash value computed from the contents of RA, RB, and",
      "the hypervisor privileged SPR HASHPKEYR, as specified by the",
      "HashDigest function described in",
      "Section of Book I.",
      "If the values are unequal, the system trap handler is invoked.",
      "",
      "This instruction is treated as a Load; see",
      "Section",
      "of Book II.",
      "",
      "This instruction is privileged.",
      "",
      "If the values are unequal, this instruction is context synchronizing",
      "(see Book III).",
      "",
      "EA must be a multiple of 8.",
      "If it is not, either an Alignment interrupt occurs or the results are",
      "boundedly undefined.",
      "",
      "If RA=0, the instruction form is invalid.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Special Purpose Register",
        "form": "XFX",
        "mnemonic": "mtspr",
        "operands": [
          "SPR",
          "RS"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "spr1",
            "size": "5"
          },
          {
            "name": "spr0",
            "size": "5"
          },
          {
            "name": "467",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The SPR field denotes a Special Purpose Register, encoded as shown in",
      "Table.",
      "If the SPR field contains the value 158, the instruction is treated",
      "as a privileged no-op.",
      "If the SPR field contains a value from 808 through 811, the",
      "instruction specifies a reserved SPR, and is treated as a no-op;  see",
      "Section, Reserved",
      "Fields, Reserved Values, and Reserved SPRs in Book I.",
      "Otherwise, the contents of register RS are placed into the designated",
      "Special Purpose Register, except as described in the next five",
      "paragraphs.",
      "For Special Purpose Registers that are 32 bits long, the low-order 32",
      "bits of RS are placed into the SPR.",
      "",
      "When the designated SPR is the Authority Mask Register (AMR), (using",
      "SPR 13 or SPR 29), or the designated SPR is the Instruction Authority",
      "Mask Register (IAMR), and MSRHVPR=0b00, the contents",
      "of bit positions of register RS corresponding to 1 bits in the",
      "Authority Mask Override Register (AMOR) are placed into the",
      "corresponding bits of the AMR or IAMR, respectively; the other AMR or",
      "IAMR bits are not modified.",
      "",
      "When the designated SPR is the AMR, using SPR 13, and",
      "MSRPR=1, the contents of bit positions of register RS",
      "corresponding to 1 bits in the User Authority Mask Override Register",
      "(UAMOR) are placed into the corresponding bits of the AMR; the other",
      "AMR bits are not modified.",
      "",
      "When the designated SPR is the UAMOR and",
      "MSRHVPR=0b00, the contents of register RS are ANDed",
      "with the contents of the AMOR and the result is placed into the UAMOR.",
      "",
      "When the designated SPR is the Hypervisor Maintenance Exception",
      "Register (HMER), the contents of register RS are ANDed with the",
      "contents of the HMER and the result is placed into the HMER.",
      "",
      "For this instruction, SPRs TBL and TBU are treated as separate 32-bit",
      "registers; setting one leaves the other unaltered.",
      "",
      "spr0=1 if and only if writing the register is",
      "privileged.",
      "Execution of this instruction specifying an SPR number with",
      "spr0=1 when the privilege state of the thread does",
      "not permit the access causes one of the following.",
      "",
      "",
      "",
      "Execution of this instruction specifying an SPR number that is",
      "undefined for the implementation causes one of the following.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Special Purpose Register",
        "form": "XFX",
        "mnemonic": "mfspr",
        "operands": [
          "RT",
          "SPR"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "spr1",
            "size": "5"
          },
          {
            "name": "spr0",
            "size": "5"
          },
          {
            "name": "339",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The SPR field denotes a Special Purpose Register, encoded as shown in",
      "Table.",
      "If the SPR field contains a value from 808 through 811, the",
      "instruction specifies a reserved SPR, and is treated as a no-op; see",
      "Section, Reserved",
      "Fields, Reserved Values, and Reserved SPRs in Book I.",
      "Otherwise, the contents of the designated Special Purpose Register",
      "are placed into register RT.",
      "For Special Purpose Registers that are 32 bits long, the low-order 32",
      "bits of RT receive the contents of the Special Purpose Register and",
      "the high-order 32 bits of RT are set to zero.",
      "",
      "spr0=1 if and only if reading the register is",
      "privileged.",
      "Execution of this instruction specifying an SPR number with",
      "spr0=1 when the privilege state of the thread does",
      "not permit the access causes one of the following.",
      "",
      "",
      "",
      "Execution of this instruction specifying an SPR number that is not",
      "defined for the implementation causes one of the following.",
      "",
      "",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Machine State Register",
        "form": "X",
        "mnemonic": "mtmsr",
        "operands": [
          "RS",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "146",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The MSR is set based on the contents of register RS and of the L",
      "field.",
      "",
      "L=0:",
      "",
      "",
      "",
      "The result of ORing bits 48 and 49 of register RS is placed into",
      "MSR48.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of register RS is complemented and then",
      "ANDed with the result of ORing bits 58 and 49 of register RS and",
      "placed into MSR58.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of register RS is complemented and then",
      "ANDed with the result of ORing bits 59 and 49 of register RS and",
      "placed into MSR59.",
      "Bits 32:40, 42:47, 49:50, 52:57, and 60:62 of register RS are placed",
      "into the corresponding bits of the MSR.",
      "",
      "",
      "L=1:",
      "",
      "",
      "",
      "Bits 48 and 62 of register RS are placed into the corresponding bits",
      "of the MSR. The remaining bits of the MSR are unchanged.",
      "",
      "",
      "This instruction is privileged.",
      "",
      "If L=0 this instruction is context synchronizing.",
      "If L=1 this instruction is execution synchronizing; in addition, the",
      "alterations of the EE and RI bits take effect as soon as the",
      "instruction completes.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move To Machine State Register Doubleword",
        "form": "X",
        "mnemonic": "mtmsrd",
        "operands": [
          "RS",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "4"
          },
          {
            "name": "L",
            "size": "1"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "178",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The MSR is set based on the contents of register RS and of the L",
      "field.",
      "",
      "L=0:",
      "",
      "",
      "",
      "The result of ORing bits 48 and 49 of register RS is placed into",
      "MSR48.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of register RS is complemented and then",
      "ANDed with the result of ORing bits 58 and 49 of register RS and",
      "placed into MSR58.",
      "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
      "the complement of bit 49 of register RS is complemented and then",
      "ANDed with the result of ORing bits 59 and 49 of register RS and",
      "placed into MSR59.",
      "Bits 0:2, 4:40 42:47, 49:50, 52:57, and 60:62 of register RS are",
      "placed into the corresponding bits of the MSR.",
      "",
      "",
      "L=1:",
      "",
      "",
      "",
      "Bits 48 and 62 of register RS are placed into the corresponding bits",
      "of the MSR. The remaining bits of the MSR are unchanged.",
      "",
      "",
      "This instruction is privileged.",
      "",
      "If L=0 this instruction is context synchronizing.",
      "If L=1 this instruction is execution synchronizing; in addition, the",
      "alterations of the EE and RI bits take effect as soon as the",
      "instruction completes.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Move From Machine State Register",
        "form": "X",
        "mnemonic": "mfmsr",
        "operands": [
          "RT"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "83",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The contents of the MSR are placed into register RT.",
      "",
      "This instruction is privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Invalidate Entry",
        "form": "X",
        "mnemonic": "slbie",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "434",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The operation performed by this instruction is based on the contents",
      "of register RB. The contents of this register are shown below.",
      "",
      "RB",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "Let the Effective Address (EA) be any EA for which",
      "EA0:35 = (RB)0:35.",
      "Let the class be (RB)36.",
      "Let the segment size be equal to the segment size specified in",
      "(RB)37:38; the allowed values of",
      "(RB)37:38, and the correspondence between the values",
      "and the segment size, are the same as for the B field in the SLBE",
      "(see Figure on",
      "pagefig:PPC3SChStorageControl-SLB-Entry).",
      "",
      "The class value and segment size must be the same as the class value",
      "and segment size in the SLB entry that translates the EA, or the",
      "values that were in the SLB entry that most recently translated the",
      "EA if the translation is no longer in the SLB; if these values are",
      "not the same, it is implementation-dependent whether the SLB entry",
      "(or implementation-dependent translation information) that translates",
      "the EA is invalidated, and the next paragraph need not apply.",
      "",
      "If the SLB contains only a single entry that translates the EA, then",
      "that is the only SLB entry that is invalidated, except that it is",
      "implementation-dependent whether an implementation-specific lookaside",
      "entry for a real mode address translation is invalidated.",
      "If the SLB contains more than one such entry, then zero or more such",
      "entries are invalidated, and similarly for any",
      "implementation-specific lookaside information used in address",
      "translation; additionally, a machine check may occur.",
      "",
      "SLB entries are invalidated by setting the V bit in the entry to 0,",
      "and the remaining fields of the entry are set to undefined values.",
      "",
      "This instruction terminates any Segment Table walks being performed",
      "on behalf of the thread that executes it.",
      "",
      "The hardware ignores the contents of RB listed below and software",
      "must set them to 0s.",
      "",
      "",
      "",
      "If this instruction is executed in 32-bit mode,",
      "(RB)0:31 must be zeros.",
      "",
      "This instruction is privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Invalidate Entry Global",
        "form": "X",
        "mnemonic": "slbieg",
        "operands": [
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "466",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The operation performed by this instruction is based on the contents",
      "of registers RS and RB.",
      "The contents of these registers are shown below.",
      "",
      "RS",
      "",
      "",
      "",
      "",
      "RB",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "Let the target PID be RS0:31.",
      "If the instruction is executed in hypervisor state, let the target",
      "LPID be RS32:63; otherwise let the target LPID be the",
      "contents of LPIDR.",
      "Let the Effective Address (EA) be any EA for which",
      "EA0:35 = (RB)0:35.",
      "Let the class be (RB)36.",
      "Let the segment size be equal to the segment size specified in",
      "(RB)37:38; the allowed values of",
      "(RB)37:38, and the correspondence between the values",
      "and the segment size, are the same as for the B field in the SLBE",
      "(see Figure on",
      "pagefig:PPC3SChStorageControl-SLB-Entry).",
      "",
      "Only SLBs for threads running on behalf of targetLPID and",
      "targetPID are searched.",
      "Software-created entries are not invalidated.",
      "The class value and segment size must be the same as the class value",
      "and segment size in the SLB entry that translates the EA, or the",
      "values that were in the SLB entry that most recently translated the",
      "EA if the translation is no longer in the SLB; if these values are",
      "not the same, it is implementation-dependent whether the SLB entry",
      "(or implementation-dependent translation information) that translates",
      "the EA is invalidated, and the next paragraph need not apply.",
      "",
      "If the SLB contains only a single entry that translates the EA, then",
      "that is the only SLB entry that is invalidated, except that it is",
      "implementation-dependent whether an implementation-specific lookaside",
      "entry for a real mode address translation is invalidated.",
      "If the SLB contains more than one such entry, then zero or more such",
      "entries are invalidated, and similarly for any",
      "implementation-specific lookaside information used in address",
      "translation; additionally, a machine check may occur.",
      "",
      "SLB entries are invalidated by setting the V bit in the entry to 0,",
      "and the remaining fields of the entry are set to undefined values.",
      "",
      "The hardware ignores the contents of RB listed below and software",
      "must set them to 0s.",
      "",
      "",
      "",
      "If this instruction is executed in 32-bit mode,",
      "(RB)0:31 must be zeros.",
      "",
      "The operation performed by this instruction is ordered by the",
      "eieio (or [p]hwsync or ptesync)",
      "instruction with respect to a subsequent slbsync",
      "instruction executed by the thread executing the slbieg instruction.",
      "The operations caused by slbieg and",
      "slbsync are ordered by eieio",
      "as a fifth set of operations, which is independent of the other four",
      "sets that eieio orders.",
      "",
      "This instruction is privileged except when",
      "LPCRGTSE=0, making it hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Invalidate All",
        "form": "X",
        "mnemonic": "slbia",
        "operands": [
          "IH"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "2"
          },
          {
            "name": "IH",
            "size": "3"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "498",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "slbia invalidates the contents of the SLB, and of",
      "implementation-specific lookaside information for effective to real",
      "address translations, based on the contents of the IH field as",
      "described below.",
      "SLB entries are invalidated by setting the V bit in the entry to 0.",
      "When an SLB entry is invalidated, the remaining fields of the entry",
      "are set to undefined values.",
      "",
      "In the description of the IH values, implementation-specific",
      "lookaside information is shorthand for implementation-specific",
      "lookaside information for effective to real address translations,",
      "and when address translation was enabled is shorthand for when",
      "MSRIR was equal to 1 or MSRDR was",
      "equal to 1, as appropriate for the type of access, and",
      "correspondingly for when address translation was disabled.  The",
      "descriptions specify which entries must be invalidated; additional",
      "entries may be invalidated except where the description states that",
      "certain SLB entries are not invalidated.",
      "",
      "",
      "",
      "All other IH values are reserved.",
      "If the IH field contains a reserved value, the set of SLB entries and",
      "implementation-specific lookaside information that is invalidated by",
      "the instruction is undefined.",
      "",
      "When IH=0b000, 0b100, or 0b111, execution of this instruction has the",
      "side effect of clearing the storage access history associated with",
      "the Hypervisor Real Mode Storage Control facility.",
      "See",
      "Section,",
      "Hypervisor Real Mode Storage Control for more details.",
      "",
      "This instruction terminates any Segment Table walks being performed",
      "on behalf of the thread that executes it, and ensures that any new",
      "table walks will be performed using the current PIDR value.",
      "",
      "This instruction is privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Invalidate All Global",
        "form": "X",
        "mnemonic": "slbiag",
        "operands": [
          "RS",
          "L"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "850",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0B"
      }
    ],
    "body": [
      "",
      "The operation performed by this instruction is based on the contents",
      "of register RS. The contents of this register is shown below.",
      "",
      "RS",
      "",
      "",
      "",
      "",
      "[0.5in][l]RSPID",
      "[0.5in][l]RSLPID",
      "",
      "If L=0, let the target PID be RS0:31.",
      "If the instruction is executed in hypervisor state, let the target",
      "LPID be RS32:63; otherwise let the target LPID be the",
      "contents of LPIDR.",
      "",
      "All nest SLBs are searched.",
      "If L=0, each SLBE for process PID in partition LPID is invalidated.",
      "If L=1, each SLBE for partition LPID is invalidated.",
      "",
      "SLB entries are invalidated by setting the V bit in the entry to 0,",
      "and the remaining fields of the entry are set to undefined values.",
      "",
      "All implementation specific lookaside information associated with",
      "SLB-derived translations for the target LPID || PID (L=0) or for the",
      "target LPID (L=1) is invalidated.",
      "Additional implementation specific lookaside information may be",
      "invalidated.",
      "",
      "The operation performed by this instruction is ordered by the",
      "eieio (or [p]hwsync or ptesync)",
      "instruction with respect to a subsequent slbsync",
      "instruction executed by the thread executing the slbiag instruction.",
      "The operations caused by slbiag and",
      "slbsync are ordered by eieio",
      "as a fifth set of operations, which is independent of the other four",
      "sets that eieio orders.",
      "",
      "This instruction is privileged except when",
      "LPCRGTSE=0, making it hypervisor privileged.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Move To Entry",
        "form": "X",
        "mnemonic": "slbmte",
        "operands": [
          "RS",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "402",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.00"
      }
    ],
    "body": [
      "",
      "When LPCRUPRT=0, this instruction is the sole means",
      "for specifying Segment translations to the hardware.",
      "When LPCRUPRT=1, Segment Table walks populate the",
      "SLB, and this instruction is used only to bolt thread-specific",
      "Segment translations.",
      "",
      "The SLB entry specified by bits 52:63 of register RB is loaded from",
      "register RS and from the remainder of register RB.",
      "The contents of these registers are interpreted as shown in",
      "Figure.",
      "",
      "",
      "",
      "On implementations that support a virtual address size of only n",
      "bits, n78, (RS)2:79-n must be zeros.",
      "",
      "When LPCRUPRT=1, the value of index must not exceed",
      "3.  (RB)52:61 are ignored.",
      "",
      "High-order bits of (RB)52:63 that correspond to SLB",
      "entries beyond the size of the SLB provided by the implementation",
      "must be zeros.",
      "",
      "The hardware ignores the contents of RS and RB listed below and",
      "software must set them to 0s.",
      "",
      "",
      "",
      "If this instruction is executed in 32-bit mode,",
      "(RB)0:31 must be zeros (i.e., the ESID must be in the",
      "range 0:15).",
      "",
      "This instruction must not be used to load a segment descriptor that",
      "is in the Segment Table when LPCRUPRT=1, and cannot",
      "be used  to invalidate the translation contained in an SLB entry.",
      "",
      "This instruction is privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Move From Entry VSID",
        "form": "X",
        "mnemonic": "slbmfev",
        "operands": [
          "RT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "851",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.00"
      }
    ],
    "body": [
      "",
      "This instruction is used to read software-loaded SLB entries.",
      "When LPCRUPRT=0, the entry is specified by bits 52:63",
      "of register RB.",
      "When LPCRUPRT=1, only the first four entries can be",
      "read, so bits 52:61 of register RB are ignored.",
      "If the specified entry is valid (V=1), the contents of the B, VSID,",
      "Ks, Kp, N, L, C,  and LP fields of",
      "the entry are placed into register RT.",
      "The contents of these registers are interpreted as shown in",
      "Figure.",
      "",
      "",
      "",
      "On implementations that support a virtual address size of only n",
      "bits, n78, RT2:79-n are set to zeros.",
      "",
      "If the SLB entry specified by bits 52:63 of register RB is invalid",
      "(V=0), the contents of register RT are set to 0.",
      "",
      "High-order bits of (RB)52:63 that correspond to SLB",
      "entries beyond the size of the SLB provided by the implementation",
      "must be zeros.",
      "",
      "The hardware ignores the contents of RB0:51.",
      "",
      "This instruction is privileged.",
      "",
      "The use of the L field is implementation specific.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Move From Entry ESID",
        "form": "X",
        "mnemonic": "slbmfee",
        "operands": [
          "RT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "915",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.00"
      }
    ],
    "body": [
      "",
      "This instruction is used to read software-loaded SLB entries.",
      "When LPCRUPRT=0, the entry is specified by bits 52:63",
      "of register RB.",
      "When LPCRUPRT=1, only the first four entries can be",
      "read, so bits 52:61 of register RB are ignored.",
      "If the specified entry is valid (V=1), the contents of the ESID and V",
      "fields of the entry are placed into register RT.",
      "If LPCRUPRT=1, the value of the BO field of the entry",
      "is also placed into register RT.",
      "The contents of these registers are interpreted as shown in",
      "Figure.",
      "",
      "",
      "",
      "If the SLB entry specified by bits 52:63 of register RB is invalid",
      "(V=0), the contents of register RT are set to 0.",
      "",
      "High-order bits of (RB)52:63 that correspond to SLB",
      "entries beyond the size of the SLB provided by the implementation",
      "must be zeros.",
      "",
      "The hardware ignores the contents of RB0:51.",
      "",
      "This instruction is privileged.",
      "",
      "The use of the L field is implementation specific.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Find Entry ESID",
        "form": "X",
        "mnemonic": "slbfee.",
        "operands": [
          "RT",
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RT",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "5"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "1959",
            "size": "11"
          }
        ],
        "release": "v2.05"
      }
    ],
    "body": [
      "",
      "The SLB is searched for an entry that matches the effective address",
      "specified by register RB.",
      "When LPCRUPRT=1, this instruction is nonfunctional.",
      "The search is performed as if it were being performed for purposes of",
      "address translation.",
      "That is, in order for a given entry to satisfy the search, the entry",
      "must be valid (V=1), and (RB)0:63-s must equal",
      "SLBE[ESID0:63-s] (where 2s is the",
      "segment size selected by the B field in the entry).If exactly one",
      "matching entry is found, the contents of the B, VSID,",
      "Ks, Kp, N, L, C, and LP fields of the",
      "entry are placed into register RT.",
      "If no matching entry is found, register RT is set to 0.",
      "If more than one matching entry is found, either one of the matching",
      "entries is used, as if it were the only matching entry, or a Machine",
      "Check occurs.",
      "If a Machine Check occurs, register RT, and CR Field 0 are set to",
      "undefined values, and the description below of how this register and",
      "this field is set does not apply.",
      "",
      "The contents of registers RT and RB are interpreted as shown in",
      "Figure.",
      "",
      "",
      "",
      "If s  28, RT80-s:51 are set to zeros.",
      "On implementations that support a virtual address size of only n",
      "bits, n78, RT2:79-n are set to zeros.",
      "",
      "CR Field 0 is set as follows.",
      "j is a 1-bit value that is equal to 0b1 if a matching entry was",
      "found. Otherwise, j is 0b0.",
      "When LPCRUPRT0,  j=0b0.",
      "",
      "",
      "",
      "CR0LT GT EQ SO = 0b00 || j || XERSO",
      "",
      "",
      "The hardware ignores the contents of RB36:38 40:63.",
      "",
      "If this instruction is executed in 32-bit mode,",
      "(RB)0:31 must be zeros (i.e., the ESID must be in the",
      "range 0-15).",
      "",
      "This instruction is privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "SLB Synchronize",
        "form": "X",
        "mnemonic": "slbsync",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "338",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "The slbsync instruction provides an ordering",
      "function for the effects of all slbieg and",
      "slbiag instructions executed by the thread",
      "executing the slbsync instruction, with respect",
      "to the memory barrier created by a subsequent ptesync instruction executed by the same thread.",
      "Executing a slbsync instruction ensures that all",
      "of the following will occur.",
      "",
      "",
      "",
      "The operation performed by this instruction is ordered by the",
      "eieio (or [p]hwsync or ptesync)",
      "instruction with respect to preceding slbieg and",
      "slbiag instructions executed by the thread",
      "executing the slbsync instruction.",
      "The operations caused by slbieg or",
      "slbiag and slbsync are",
      "ordered by eieio as a fifth set of operations,",
      "which is independent of the other four sets that eieio orders.",
      "",
      "The slbsync instruction may complete before",
      "operations caused by slbieg",
      "or slbiag instructions preceding the",
      "slbsync instruction have been performed.",
      "",
      "This instruction is privileged except when",
      "LPCRGTSE=0, making it hypervisor privileged.",
      "",
      "See",
      "Section",
      "for a description of other requirements associated with the use of",
      "this instruction.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "TLB Invalidate Entry",
        "form": "X",
        "mnemonic": "tlbie",
        "operands": [
          "RB",
          "RS",
          "RIC",
          "PRS",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "RIC",
            "size": "2"
          },
          {
            "name": "PRS",
            "size": "1"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "306",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "P1"
      }
    ],
    "body": [
      "",
      "The operation performed by this instruction is based on the contents",
      "of registers RS and RB.",
      "The contents of these registers are shown below, where IS is",
      "(RB)52:53   and L is (RB)63.",
      "",
      "RS:",
      "",
      "",
      "",
      "Programming NoteNote that although there is no PID compare for partition-scoped",
      "translation, software must still place the PID in RS when IS=0 or 1.",
      "It may be used, for example, in the TLB hash.",
      "",
      "RB for effR=1 and IS=0b00:",
      "",
      "",
      "",
      "",
      "RB for effR=0, IS=0b00, RIC3, and L=0:",
      "",
      "",
      "",
      "",
      "RB for effR=0, IS=0b00, RIC3, and L=1:",
      "",
      "",
      "",
      "",
      "RB for effR=0, IS=0b00, and RIC=3:",
      "",
      "",
      "",
      "",
      "RB for IS=0b01, 0b10, or 0b11:",
      "",
      "",
      "",
      "",
      "If this instruction is executed in hypervisor state,",
      "RS32:63 contains the searchLPID, which is the",
      "partition ID (LPID) of the partition for which one or more",
      "translations are being invalidated.",
      "Otherwise, the value in LPIDR is used as the searchLPID.",
      "The supported (RS)32:63 values are the same as the",
      "LPID values supported in LPIDR.",
      "RS0:31 contains a PID value.",
      "The supported values of RS0:31 are the same as the",
      "PID values supported in PIDR.",
      "",
      "The following forms are treated as if the instruction form were",
      "invalid.",
      "",
      "",
      "",
      "The results of an attempt to invalidate a translation outside of",
      "quadrant 0 for Radix Tree translation (effR=1, RIC=0,",
      "PRS=1,  IS=0, and EA0:10b00) are boundedly",
      "undefined.",
      "",
      "IS field in RB contains 0b00",
      "",
      "If RIC=0, this is a search for a single TLB entry.",
      "The following relationships must be true and tests and actions are",
      "performed to search for an HPT translation.",
      "",
      "",
      "",
      "Variable i is equal to 63 - log2 (scope of the TLB",
      "entry)",
      "",
      "",
      "If the base page size specified by the PTE that was used to create",
      "the TLB entry to be invalidated is 4 KB, the L field in register RB",
      "must contain 0.",
      "",
      "",
      "If the L field in RB contains 0, the base page size is 4 KB and",
      "RB56:58 (AP - Actual Page size field) must be set to",
      "the SLBEL||LP encoding for the page size",
      "corresponding to the actual page size specified by the PTE that was",
      "used to create the TLB entry to be invalidated.",
      "Thus, b is equal to 12 and p is equal to log2 (actual",
      "page size specified by (RB)56:58).",
      "The Abbreviated Virtual Address (AVA) field in register RB must",
      "contain bits 14:65 of the virtual address translated by the TLB entry",
      "to be invalidated. Variable instAVA is equal to the AVA field of RB.",
      "",
      "",
      "If the L field in RB contains 1, the following rules apply.",
      "",
      "",
      "",
      "",
      "",
      "",
      "Let the segment size be equal to the segment size specified in",
      "(RB)54:55 (B field).",
      "The contents of RB54:55 must be the same as the",
      "contents of the B field of the PTE that was used to create the TLB",
      "entry to be invalidated.",
      "",
      "",
      "RB52:53 and RB59:62 (when",
      "(RB)63 = 0) must contain zeros and are ignored by the",
      "hardware.",
      "",
      "",
      "All TLB entries on all threads that have all of the following",
      "properties are made invalid.",
      "",
      "",
      "",
      "",
      "The following relationships must be true and tests and actions are",
      "performed to search for a Radix Tree translation.",
      "For a partition-scoped invalidation, references to the effective",
      "address are understood to refer to the guest real address.",
      "",
      "",
      "",
      "The page size is encoded in RB56:58 (AP - Actual Page",
      "size field).",
      "Thus p is equal to log2( page size specified by",
      "RB56:58).",
      "The Effective Page Number (EPN) field in register RB must contain the",
      "bits 0:i of the effective address translated by the TLB entry to be",
      "invalidated.  Variable i is equal to 63-p.",
      "",
      "",
      "The fields shown as zeros must be set to zero and are ignored by the",
      "hardware.",
      "",
      "",
      "All TLB entries on all threads that have all of the following",
      "properties are made invalid.",
      "",
      "",
      "",
      "",
      "",
      "",
      "Additional TLB entries may also be made invalid if those TLB entries",
      "contain an LPID that matches searchLPID.",
      "",
      "",
      "If RIC=3, then the TLB entries mapping an aligned sequence of virtual",
      "pages are made invalid on all threads.",
      "The number of virtual pages in the sequence, and their page size",
      "(base page size = actual page size), are provided using an",
      "implementation-specific encoding of the GS field of RB.",
      "The number of virtual pages is a power of two.",
      "The abbreviated virtual address of the beginning of the sequence is",
      "provided by the AVA field of RB with the appropriate number of",
      "low-order bits treated as zero to cause the affected region of VA",
      "space to be aligned at a multiple of its size.",
      "The effect is as if a tlbie instruction with",
      "RIC=PRS=effR=0 were executed for each virtual page in the",
      "sequence, using the supplied contents of RS and RB except using the",
      "AVA value corresponding to the virtual page and using the base and",
      "actual page size provided by GS, and with the additional match",
      "criterion that the base and actual page sizes match the scope of the",
      "TLB entry.",
      "",
      "IS field in RB is non-zero",
      "",
      "If RIC=0 or RIC=2, all partition-scoped TLB entries when PRS=0 and",
      "either MSRHV=1 or effR=0, or all",
      "process-scoped TLB entries when PRS=1 on all threads for which any of",
      "the following conditions are met for the entry are made invalid.",
      "",
      "",
      "",
      "If RIC=1 or RIC=2, if the following conditions are met, the",
      "respective partition-scoped contents when PRS=0 and",
      "MSRHV=1 or process-scoped contents when PRS=1 of the",
      "page walk cache are invalidated.",
      "",
      "",
      "",
      "If RIC=2, if the following conditions are met, the respective",
      "partition and Process Table caching are invalidated for all threads.",
      "",
      "",
      "",
      "When i40, RB40:i-1 may contain any value and are",
      "ignored by the hardware.",
      "",
      "For all IS values",
      "",
      "For all threads, any implementation specific lookaside information",
      "that is based on any TLB entry that would be invalidated by this",
      "instruction will also be invalidated.",
      "",
      "Depending on the variant of the instruction, RB0:51,",
      "RB59:62, RB59:63,",
      "RB54:55, and RB54:63  are the",
      "equivalent of reserved fields, should contain 0s, and are ignored by",
      "the hardware.",
      "When the thread is in privileged non-hypervisor state,",
      "RS32:63 is the equivalent of a reserved field, should",
      "contain 0s, and is ignored by the hardware.",
      "",
      "MSRSF must be 1 when this instruction is executed;",
      "otherwise the results are undefined.",
      "",
      "If the value specified in RS0:31,",
      "RS32:63, RB54:55,",
      "RB56:58, RB44:51, or",
      "RB56:63, when it is needed to perform the specified",
      "operation,  is not supported by the implementation, the instruction",
      "is treated as if the instruction form were invalid.",
      "",
      "The operation performed by this instruction is ordered by the",
      "eieio (or [p]hwsync or ptesync)",
      "instruction with respect to a subsequent tlbsync",
      "instruction executed by the thread executing the tlbie instruction.",
      "The operations caused by tlbie and",
      "tlbsync are ordered by eieio",
      "as a fourth set of operations, which is independent of the other four",
      "sets that eieio orders.",
      "",
      "This instruction is privileged except when LPCRGTSE=0",
      "or when PRS=0 and HR=1, making it hypervisor privileged.",
      "",
      "See",
      "Section,",
      "Translation Table Update Synchronization Requirements for a",
      "description of other requirements associated with the use of this",
      "instruction.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "TLB Invalidate Entry Local",
        "form": "X",
        "mnemonic": "tlbiel",
        "operands": [
          "RB",
          "RS",
          "RIC",
          "PRS",
          "R"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "RS",
            "size": "5"
          },
          {
            "name": "reserved",
            "size": "1"
          },
          {
            "name": "RIC",
            "size": "2"
          },
          {
            "name": "PRS",
            "size": "1"
          },
          {
            "name": "R",
            "size": "1"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "274",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.03"
      }
    ],
    "body": [
      "",
      "The operation performed by this instruction is based on the contents",
      "of registers RS and RB.",
      "The contents of these registers are shown below, where IS is",
      "(RB)52:53 and L is (RB)63.",
      "",
      "RS:",
      "",
      "",
      "",
      "Programming NoteNote that although there is no PID compare for partition-scoped",
      "translation, software must still place the PID in RS when IS=0 or 1.",
      "It may be used, for example, in the TLB hash.",
      "",
      "RB for effR=1 and IS=0b00:",
      "",
      "",
      "",
      "",
      "RB for effR=0, IS=0b00, and L=0:",
      "",
      "",
      "",
      "",
      "RB for effR=0, IS=0b00, and L=1:",
      "",
      "",
      "",
      "",
      "RB for IS=0b01, 0b10, or 0b11:",
      "",
      "",
      "",
      "Programming NoteIn versions of the architecture that precede Version 3.1,",
      " with IS= 1, 2, or 3 invalidated",
      "appropriate entries only in a specific congruence class of the TLB,",
      "specified by SET in register RB.",
      "As a result, software was required to use a  loop to iterate through all congruence classes in order to",
      "invalidate the TLB.",
      "Software that will not be run on hardware complying with those",
      "versions should specify SET=0 in register RB.",
      "The description for  specifies SET instead",
      "of 0 in register RB to illustrate compatibility with software written",
      "to run on hardware complying with those versions.",
      "",
      "LPIDR contains the searchLPID, which is the partition ID (LPID) of",
      "the partition for which the translation is being invalidated.",
      "RS0:31 contains a PID value.",
      "The supported values of RS0:31 are the same as the",
      "PID values supported in PIDR.",
      "",
      "The following forms are invalid.",
      "",
      "",
      "",
      "The following forms are treated as though the instruction form was",
      "invalid.",
      "",
      "",
      "",
      "The results of an attempt to invalidate a translation outside of",
      "quadrant 0 for Radix Tree translation (effR=1, RIC=0,",
      "PRS=1,  IS=0, and EA0:10b00) are boundedly",
      "undefined.",
      "",
      "IS field in RB contains 0b00",
      "",
      "If RIC=0, this is a search for a single TLB entry.",
      "The following relationships must be true and tests and actions are",
      "performed to search for an HPT translation.",
      "",
      "",
      "",
      "Variable i is equal to 63 - log2 (scope of the TLB",
      "entry).",
      "",
      "",
      "If the base page size specified by the PTE that was used to create",
      "the TLB entry to be invalidated is 4 KB, the L field in register RB",
      "must contain 0.",
      "",
      "",
      "If the L field in RB contains 0, the base page size is 4 KB and",
      "RB56:58 (AP - Actual Page size field) must be set to",
      "the SLBEL||LP encoding for the page size",
      "corresponding to the actual page size specified by the PTE that was",
      "used to create the TLB entry to be invalidated.",
      "Thus, b is equal to 12 and p is equal to log2 (actual",
      "page size specified by (RB)56:58).",
      "The Abbreviated Virtual Address (AVA) field in register RB must",
      "contain bits 14:65 of the virtual address translated by the TLB entry",
      "to be invalidated. Variable instAVA is equal to the AVA field of RB.",
      "",
      "",
      "If the L field in RB contains 1, the following rules apply.",
      "",
      "",
      "",
      "",
      "",
      "",
      "Let the segment size be equal to the segment size specified in",
      "(RB)54:55 (B field).",
      "The contents of RB54:55 must be the same as the",
      "contents of the B field of the PTE that was used to create the TLB",
      "entry to be invalidated.",
      "",
      "",
      "All TLB entries that have all of the following properties are made",
      "invalid on the thread executing the tlbiel",
      "instruction.",
      "",
      "",
      "",
      "",
      "The following relationships must be true and tests and actions are",
      "performed to search for a Radix Tree translation.",
      "For a partition-scoped invalidation, references to the effective",
      "address are understood to refer to the guest real address.",
      "",
      "",
      "",
      "The page size is encoded in RB56:58 (AP - Actual Page",
      "size field).",
      "Thus p is equal to log2( page size specified by",
      "RB56:58).",
      "The Effective Page Number (EPN) field in register RB must contain the",
      "bits 0:i of the effective address translated by the TLB entry to be",
      "invalidated.  Variable i is equal to 63-p.",
      "",
      "",
      "The fields shown as zeros must be set to zero and are ignored by the",
      "hardware.",
      "",
      "",
      "All TLB entries that have all of the following properties are made",
      "invalid on the thread executing the tlbiel",
      "instruction..",
      "",
      "",
      "",
      "",
      "Additional TLB entries may also be made invalid if those TLB entries",
      "contain an LPID that matches searchLPID.",
      "",
      "IS field in RB is non-zero",
      "",
      "When SET=0 is specified and either RIC=0 or RIC=2, each",
      "partition-scoped entry when PRS=0 and either MSRHV=1",
      "or effR=0, or each process-scoped entry when PRS=1 is",
      "invalidated if any of the following conditions are met for the entry.",
      "",
      "",
      "",
      "When SET=0  is specified and either RIC=1 or RIC=2, if the following",
      "conditions are met, the respective partition-scoped contents when",
      "PRS=0 and MSRHV=1 or process-scoped contents when",
      "PRS=1 of the page walk cache are invalidated.",
      "",
      "",
      "",
      "When SET=0 is specified and RIC=2, if the following conditions are",
      "met, the respective partition and Process Table caching are",
      "invalidated.",
      "",
      "",
      "",
      "For all IS values",
      "",
      "Any implementation specific lookaside information that is based on",
      "any TLB entry that would be invalidated by this instruction will also",
      "be invalidated.",
      "",
      "Depending on the variant of the instruction, RB0:39,",
      "RB59:62, RB59:63,",
      "RB54:55, and RB54:63  are the",
      "equivalent of reserved fields, should contain 0s, and are ignored by",
      "the hardware.",
      "RS32:63 is always the equivalent of a reserved field,",
      "should contain 0s, and is ignored by the hardware.",
      "",
      "Only TLB entries, page walk caching, and Process and Partition Table",
      "caching on the thread executing the tlbiel",
      "instruction are affected.",
      "",
      "MSRSF must be 1 when this instruction is executed;",
      "otherwise the results are boundedly undefined.",
      "",
      "If the value specified in RS0:31,",
      "RB54:55, RB56:58, or",
      "RB44:51, when it is needed to perform the specified",
      "operation, is not supported by the implementation, the instruction is",
      "treated as if the instruction form were invalid.",
      "",
      "This instruction is privileged except when PRS=0 and HR=1, making it",
      "hypervisor privileged.",
      "",
      "See",
      "Section,",
      "Translation Table Update Synchronization Requirements on",
      "pagesec:PPC3SChStorageControl-Page-Table-Update-Synchronization-Requirements",
      "for a description of other requirements associated with the use of",
      "this instruction.",
      "",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "TLB Synchronize",
        "form": "X",
        "mnemonic": "tlbsync",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "566",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "PPC"
      }
    ],
    "body": [
      "",
      "The tlbsync instruction provides an ordering",
      "function for the effects of all tlbie",
      "instructions executed by the thread executing the tlbsync instruction, with respect to the memory barrier created by a",
      "subsequent ptesync instruction executed by the",
      "same thread.",
      "Executing a tlbsync instruction ensures that all",
      "of the following will occur.",
      "",
      "",
      "",
      "The operation performed by this instruction is ordered by the",
      "eieio (or [p]hwsync or ptesync)",
      "instruction with respect to preceding tlbie",
      "instructions executed by the thread executing the tlbsync instruction.",
      "The operations caused by tlbie and",
      "tlbsync are ordered by eieio",
      "as a fourth set of operations, which is independent of the other",
      "three sets that eieio orders.",
      "",
      "The tlbsync instruction may complete before",
      "operations caused by tlbie instructions preceding",
      "the tlbsync instruction have been performed.",
      "",
      "This instruction is privileged except when",
      "LPCRGTSE=0, making it hypervisor privileged.",
      "",
      "See",
      "Section",
      "for a description of other requirements associated with the use of",
      "this instruction.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Send Ultravisor",
        "form": "X",
        "mnemonic": "msgsndu",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "78",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0C"
      }
    ],
    "body": [
      "",
      "msgsndu sends a message to other threads in the",
      "system.",
      "The message type and destination thread(s) are specified in RB.",
      "",
      "",
      "",
      "",
      "The contents of RB are defined below.",
      "Bits 37:63 are referred to as the message payload.",
      "",
      "",
      "",
      "The actions taken on receipt of a message are defined in",
      "Section.",
      "",
      "This instruction is ultravisor privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Clear Ultravisor",
        "form": "X",
        "mnemonic": "msgclru",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "110",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0C"
      }
    ],
    "body": [
      "",
      "msgclru clears a message previously accepted by",
      "the thread executing the msgclru.",
      "",
      "Let msgtype be (RB)32:36, and let t be the",
      "hypervisor thread number of the thread executing the",
      "msgclru instruction.",
      "",
      "If msgtype = 0x05, then clear any Directed Ultravisor Doorbell",
      "exception that exists on thread t; otherwise, this instruction is",
      "treated as a no-op.",
      "",
      "This instruction is ultravisor privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Send",
        "form": "X",
        "mnemonic": "msgsnd",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "206",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "msgsnd sends a message to other threads in the",
      "system.",
      "The message type and destination thread(s) are specified in RB.",
      "",
      "",
      "",
      "",
      "The contents of RB are defined below.",
      "Bits 37:63 are referred to as the message payload.",
      "",
      "",
      "",
      "The actions taken on receipt of a message are defined in",
      "Section.",
      "",
      "This instruction is hypervisor privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Clear",
        "form": "X",
        "mnemonic": "msgclr",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "238",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "msgclr clears a message previously accepted by",
      "the thread executing the msgclr.",
      "",
      "Let msgtype be (RB)32:36, and let t be the",
      "hypervisor thread number of the thread executing the",
      "msgclr instruction.",
      "",
      "If msgtype = 0x05, then clear any Directed Hypervisor Doorbell",
      "exception that exists on thread t; otherwise, this instruction is",
      "treated as a no-op.",
      "",
      "This instruction is hypervisor privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Send Privileged",
        "form": "X",
        "mnemonic": "msgsndp",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "142",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "msgsndp sends a message to other threads that are",
      "on the same multi-threaded processor (if the processor is not in",
      "sub-processor mode) or to other threads that are on the same",
      "sub-processor (if the processor is in sub-processor mode).",
      "The message type and destination thread(s) are specified in RB.",
      "",
      "",
      "",
      "",
      "The contents of RB are defined below.",
      "Bits 37:63 are referred to as the message payload.",
      "",
      "",
      "",
      "The actions taken on receipt of a message are defined in",
      "Section.",
      "",
      "This instruction is privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Clear Privileged",
        "form": "X",
        "mnemonic": "msgclrp",
        "operands": [
          "RB"
        ],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "10"
          },
          {
            "name": "RB",
            "size": "5"
          },
          {
            "name": "174",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v2.07"
      }
    ],
    "body": [
      "",
      "msgclrp clears a message previously accepted by",
      "the thread executing the msgclrp.",
      "",
      "Let msgtype be (RB)32:36, and let t be the privileged",
      "thread number of the thread executing the msgclrp.",
      "",
      "If msgtype = 0x05, then clear any Directed Privileged Doorbell",
      "exception that exists on thread t by setting",
      "DPDES63-t to 0; otherwise, this instruction is",
      "treated as a no-op.",
      "",
      "This instruction is privileged.",
      ""
    ]
  },
  {
    "mnemonics": [
      {
        "name": "Message Synchronize",
        "form": "X",
        "mnemonic": "msgsync",
        "operands": [],
        "conditions": [],
        "layout": [
          {
            "name": "31",
            "size": "6"
          },
          {
            "name": "reserved",
            "size": "15"
          },
          {
            "name": "886",
            "size": "10"
          },
          {
            "name": "reserved",
            "size": "1"
          }
        ],
        "release": "v3.0"
      }
    ],
    "body": [
      "",
      "In conjunction with the Synchronize and msgsndu or msgsnd instructions, the",
      "msgsync instruction provides an ordering function",
      "for stores that have been performed with respect to the thread",
      "executing the Synchronize and msgsndu",
      "or msgsnd instructions, relative to data accesses",
      "by other threads that are performed after a Directed Ultravisor",
      "Doorbell or Directed Hypervisor Doorbell interrupt has occurred, as",
      "described in the Synchronize instruction description on p.",
      "sec:PPC3SChStorageControl-Synchronize-Instruction.",
      "",
      "This instruction is hypervisor privileged.",
      ""
    ]
  }
]
