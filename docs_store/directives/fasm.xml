<?xml version="1.0" encoding="utf-8"?>
<directives>
	<directive name="include" tool="fasm">
		<description>The include directive includes the specified source file at the position where it is used. It should be followed by the quoted name of file that should be included.</description>
	</directive>
    <directive name="equ" tool="fasm">
        <description>The definition of symbolic constant consists of name of the constant followed by the equ directive. Everything that follows this directive will become the value of constant. If the value of symbolic constant contains other symbolic constants, they are replaced with their values before assigning this value to the new constant.</description>
    </directive>
    <directive name="restore" tool="fasm">
        <description>The restore directive allows to get back previous value of redefined symbolic constant. It should be followed by one more names of symbolic constants, separated with commas.</description>
    </directive>
    <directive name="fix" tool="fasm">
        <description>Symbolic constants can also be defined with the fix directive, which has the same syntax as equ, but defines constants of high priority - they are replaced with their symbolic values even before processing the preprocessor directives and macroinstructions, the only exception is fix directive itself, which has the highest possible priority, so it allows redefinition of constants defined this way. </description>
    </directive>
    <directive name="macro" tool="fasm">
        <description>The macro directive allows you to define your own complex instructions, called macroinstructions, using which can greatly simplify the process of programming. In its simplest form it's similar to symbolic constant definition.</description>
    </directive>
    <directive name="purge" tool="fasm">
        <description>The purge directive allows removing the last definition of specified macroinstruction. It should be followed by one or more names of macroinstructions, separated with commas.</description>
    </directive>
    <directive name="local" tool="fasm">
        <description>The local directive defines local names, which will be replaced with unique values each time the macroinstruction is used. It should be followed by names separated with commas. If the name given as parameter to local directive begins with a dot or two dots, the unique labels generated by each evaluation of macroinstruction will have the same properties.</description>
    </directive>
    <directive name="forward" tool="fasm">
        <description>Divides macroinstruction into blocks, each one processed after the processing of previous is finished.</description>
    </directive>
    <directive name="reverse" tool="fasm">
        <description>A block that follows reverse directive is processed for each group of argument in reverse order - from last to first.</description>
    </directive>
    <directive name="common" tool="fasm">
    <description>A block that follows common directive is processed only once, commonly for all groups of arguments.</description>
    </directive>
    <directive name="#" tool="fasm">
        <description>Inside macroinstruction also special operator # can be used. This operator causes two names to be concatenated into one name. It can be useful, because it's done after the arguments and local names are replaced with their values. The # operator can be also used to concatenate two quoted strings into one.</description>
    </directive>
    <directive name="`" tool="fasm">
        <description>Performs conversion of name into a quoted string is possible inside a macroinstruction.</description>
    </directive>
    <directive name="eqtype" tool="fasm">
        <description>To make macroinstruction behaving differently when some of the arguments are of some special type, for example a quoted strings, you can use eqtype comparision operator.</description>
    </directive>
    <directive name="postpone" tool="fasm">
        <description>The postpone directive can be used to define a special type of macroinstruction that has no name or arguments and will get automatically called when the preprocessor reaches the end of source.</description>
    </directive>
    <directive name="struc" tool="fasm">
        <description>The struc directive is a special variant of macro directive that is used to define data structures. Macroinstruction defined using the struc directive must be preceded by a label (like the data definition directive) when it's used.</description>
    </directive>
    <directive name="restruc" tool="fasm">
        <description>The restruc directive removes the last definition of the structure, just like purge does with macroinstructions and restore with symbolic constants.</description>
    </directive>
    <directive name="rept" tool="fasm">
        <description>The rept directive is a special kind of macroinstruction, which makes given amount of duplicates of the block enclosed with braces. The basic syntax is rept directive followed by number. and then block of source enclosed between the { and } characters.</description>
    </directive>
    <directive name="irp" tool="fasm">
        <description>The irp directive iterates the single argument through the given list of parameters. The syntax is irp followed by the argument name, then the comma and then the list of parameters.</description>
    </directive>
    <directive name="irps" tool="fasm">
        <description>The irps directive iterates through the given list of symbols, it should be followed by the argument name, then the comma and then the sequence of any symbols. Each symbol in this sequence, no matter whether it is the name symbol, symbol character or quoted string, becomes an argument value for one iteration. If there are no symbols following the comma, no iteration is done at all.</description>
    </directive>
    <directive name="irpv" tool="fasm">
        <description>The irpv directive iterates through all of the values that were assigned to the given symbolic variable. It should be followed by the argument name and the name of symbolic variable, separated with comma. When the symbolic variable is treated with restore directive to remove its latest value, that value is removed from the list of values accessed by irpv. But any modifications made to that list during the iterations performed by irpv (by either defining a new value for symbolic variable, or destroying the value with restore directive) do not affect the operation performed by this directive - the list that gets iterated reflects the state of symbolic variable at the time when irpv directive was encountered.</description>
    </directive>
    <directive name="match" tool="fasm">
        <description>The match directive causes some block of source to be preprocessed and passed to assembler only when the given sequence of symbols matches the specified pattern. The pattern comes first, ended with comma, then the symbols that have to be matched with the pattern, and finally the block of source, enclosed within braces as macroinstruction.</description>
    </directive>
    <directive name="format" tool="fasm">
        <description>The format directive followed by the format identifier allows to select the output format. This directive should be put at the beginning of the source. It can always be followed in the same line by the as keyword and the quoted string specifying the default file extension for the output file. Unless the output file name was specified from the command line, assembler will use this extension when generating the output file.</description>
    </directive>
    <directive name="MZ" tool="fasm">
        <description>To select the MZ output format, use format MZ directive. The default code setting for this format is 16-bit. </description>
    </directive>
    <directive name="segment" tool="fasm">
    <description>The segment directive defines a new segment, it should be followed by label, which value will be the number of defined segment, optionally use16 or use32 word can follow to specify whether code in this segment should be 16-bit or 32-bit. The origin of segment is aligned to paragraph (16 bytes). All the labels defined then will have values relative to the beginning of this segment.</description>
    </directive>
    <directive name="entry" tool="fasm">
    <description>MZ: The entry directive sets the entry point for MZ executable, it should be followed by the far address (name of segment, colon and the offset inside segment) of desired entry point.
PE: The entry directive sets the entry point for Portable Executable, the value of entry point should follow. </description>
    </directive>
    <directive name="stack" tool="fasm">
    <description>MZ:The  stack directive sets up the stack for MZ executable. It can be followed by numerical expression specifying the size of stack to be created automatically or by the far address of initial stack frame when you want to set up the stack manually. When no stack is defined, the stack of default size 4096 bytes will be created.
PE: stack directive sets up the size of stack for Portable Executable, value of stack reserve size should follow, optionally value of stack commit separated with comma can follow. When stack is not defined, it's set by default to size of 4096 bytes.</description>
    </directive>
    <directive name="heap" tool="fasm">
    <description>MZ: heap directive should be followed by a 16-bit value defining maximum size of additional heap in paragraphs (this is heap in addition to stack and undefined data). Use heap 0 to always allocate only memory program really needs. Default size of heap is 65535.
PE: The heap directive chooses the size of heap for Portable Executable, value of heap reserve size should follow, optionally value of heap commit separated with comma can follow. When no heap is defined, it is set by default to size of 65536 bytes, when size of heap commit is unspecified, it is by default set to zero.</description>
    </directive>
    <directive name="PE" tool="fasm">
        <description>To select the Portable Executable output format, use format PE directive, it can be followed by additional format settings: first the target subsystem setting, which can be console or GUI for Windows applications, native for Windows drivers, EFI, EFIboot or EFIruntime for the UEFI, it may be followed by the minimum version of system that the executable is targeted to (specified in form of floating-point value).</description>
    </directive>
    <directive name="PE64" tool="fasm">
        <description>To select the Portable Executable output format for the x86-64 architecture, use format PE directive, it can be followed by additional format settings: first the target subsystem setting, which can be console or GUI for Windows applications, native for Windows drivers, EFI, EFIboot or EFIruntime for the UEFI, it may be followed by the minimum version of system that the executable is targeted to (specified in form of floating-point value).</description>
    </directive>
    <directive name="section" tool="fasm">
    <description>PE: section directive defines a new section, it should be followed by quoted string defining the name of section, then one or more section flags can follow. Available flags are: code, data, readable, writeable, executable, shareable, discardable, notpageable. The origin of section is aligned to page (4096 bytes).
COFF: section directive defines a new section, it should be followed by quoted string defining the name of section, then one or more section flags can follow. Section flags available for both COFF variants are code and data, while flags readable, writeable, executable, shareable, discardable, notpageable, linkremove and linkinfo are available only with Microsoft's COFF variant.
ELF:section directive defines a new section, it should be followed by quoted string defining the name of section, then can follow one or both of the executable and writeable flags, optionally also align operator followed by the number specifying the alignment of section (it has to be the power of two), if no alignment is specified, the default value is used, which is 4 or 8, depending on which format variant has been chosen.</description>
    </directive>
    <directive name="code" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="readable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="writeable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="executable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="shareable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="discardable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="notpageable" tool="fasm">
        <description>Flag for the section directive.</description>
    </directive>
    <directive name="data" tool="fasm">
        <description>The data directive begins the definition of special PE data, it should be followed by one of the data identifiers (export, import, resource or fixups) or by the number of data entry in PE header. The data should be defined in next lines, ended with end data directive. Also an available flag for the section directive.</description>
    </directive>
    <directive name="rva" tool="fasm">
    <description>PE: The rva operator can be used inside the numerical expressions to obtain the RVA of the item addressed by the value it is applied to, that is the offset relative to the base of PE image.
    MS COFF: When using the Microsoft's COFF format, the rva operator can be used inside the numerical expressions to obtain the RVA of the item addressed by the value it is applied to.
    ELF: The rva operator can be used also in the case of this format (however not when target architecture is x86-64), it converts the address into the offset relative to the GOT table, so it may be useful to create position-independent code.</description>
    </directive>
    <directive name="COFF" tool="fasm">
        <description>To select Common Object File Format, use format COFF or format MS COFF directive, depending whether you want to create classic (DJGPP) or Microsoft's variant of COFF file.</description>
    </directive>
    <directive name="extrn" tool="fasm">
    <description>COFF: The extrn directive defines the external symbol, it should be followed by the name of symbol and optionally the size operator specifying the size of data labeled by this symbol. The name of symbol can be also preceded by quoted string containing name of the external symbol and the as operator.
ELF: The extrn directive has the same meaning and syntax as when the COFF output format is selected.</description>
    </directive>
    <directive name="public" tool="fasm">
    <description>COFF: The public directive declares the existing symbol as public, it should be followed by the name of symbol, optionally it can be followed by the as operator and the quoted string containing name under which symbol should be available as public.
ELF: The public directive has the same meaning and syntax as when the COFF output format is selected.</description>
    </directive>
    <directive name="static" tool="fasm">
        <description>With COFF format it's possible to specify exported symbol as static, it's done by preceding the name of symbol with the static keyword.</description>
    </directive>
    <directive name="ELF" tool="fasm">
        <description>To select ELF output format, use format ELF directive. The default code setting for this format is 32-bit.</description>
    </directive>
    <directive name="ELF64" tool="fasm">
        <description>To create ELF file for the x86-64 architecture, use format ELF64 directive, in such case the long mode code is generated by default.</description>
    </directive>
    <directive name="plt" tool="fasm">
        <description>Allows to call the external functions through the Procedure Linkage Table.</description>
    </directive>
</directives>
